import{_ as e}from"./supabase-AmyKTmiY.js";import{e as t,i}from"./infectionDataManager-B0goiMHy.js";import{l as n,s as a,b as o,n as r}from"./index-CkRLChmT.js";import"./vendor-BU6HxVpN.js";const s=(e={})=>{let t=a.from("pazienti").select("*",{count:"exact"}).not("user_id","is",null);const{reparto:i,diagnosi:n,stato:o,search:r}=e;return i&&(t=t.eq("reparto_appartenenza",i)),n&&(t=t.eq("diagnosi",n)),"attivo"===o&&(t=t.is("data_dimissione",null)),"dimesso"===o&&(t=t.not("data_dimissione","is",null)),r&&(t=t.or(`nome.ilike.%${r}%,cognome.ilike.%${r}%`)),t},c=async(e={},t={})=>{const{page:i=0,limit:a=10,sortColumn:o="data_ricovero",sortDirection:r="desc"}=t;let c=s(e);const l=i*a,d=l+a-1;c=c.order(o,{ascending:"asc"===r}).range(l,d);const{data:p,error:m,count:g}=await c;if(m)throw m;try{const e=(p||[]).filter(e=>e&&"trasferimento_esterno"===e.tipo_dimissione).slice(0,5).map(e=>({id:e.id,codice_clinica:e.codice_clinica}));n.group("[patientApi.getPaginatedPatients] Result summary"),n.log({total:p?.length||0,count:g,externalTransfersSample:e}),n.groupEnd()}catch(f){}return{patients:p||[],totalCount:g||0}},l=async(e={})=>{const{sortColumn:t="data_ricovero",sortDirection:i="desc"}=e;let a=s(e);a=a.order(t,{ascending:"asc"===i});const{data:o,error:r}=await a;if(r)throw r;try{const e=(o||[]).filter(e=>e&&"trasferimento_esterno"===e.tipo_dimissione).slice(0,5).map(e=>({id:e.id,codice_clinica:e.codice_clinica}));n.group("[patientApi.getAllPatients] Result sample"),n.log({total:o?.length||0,externalTransfersSample:e}),n.groupEnd()}catch(c){}return o||[]},d=async e=>{const{data:t,error:i}=await a.from("pazienti").select("*").eq("id",e).single();if(i)throw i;try{n.log("[patientApi.getPatientById] Loaded",{id:t?.id,tipo_dimissione:t?.tipo_dimissione,codice_clinica:t?.codice_clinica||null})}catch(o){}return t},p=async e=>{const{data:t,error:i}=await a.from("pazienti").insert([e]).select().single();if(i)throw i;return t},m=async(e,t)=>{try{n.group("[patientApi.updatePatient] Update payload"),n.log({id:e,codice_clinica:t?.codice_clinica??null,tipo_dimissione:t?.tipo_dimissione??null}),n.groupEnd()}catch(r){}const{data:i,error:o}=await a.from("pazienti").update(t).eq("id",e).select().single();if(o)throw o;try{n.group("[patientApi.updatePatient] Update result"),n.log({id:i?.id,tipo_dimissione:i?.tipo_dimissione??null,codice_clinica:i?.codice_clinica??null}),n.groupEnd()}catch(r){}return i},g=async e=>{const{error:t}=await a.from("pazienti").delete().eq("id",e);if(t)throw t},f=async(e,t=!1)=>{let i=a.from("pazienti").select("id, nome, cognome, codice_rad, data_ricovero, diagnosi, reparto_appartenenza").not("user_id","is",null).or(`nome.ilike.%${e}%,cognome.ilike.%${e}%,codice_rad.ilike.%${e}%`).order("cognome");t&&(i=i.is("data_dimissione",null));const{data:n,error:o}=await i;if(o)throw o;return n||[]},h=async()=>{const{data:e,error:t}=await a.from("pazienti").select("data_dimissione, diagnosi, reparto_appartenenza").not("user_id","is",null);if(t)throw t;return e||[]};const z=new class{constructor(){this.transactionLogs=new Map,this.maxLogRetention=864e5,this.cleanupInterval=36e5,this.startLogCleanup()}async executePatientWithSurgeryTransaction(e,t){const i=this.generateTransactionId();try{this.initializeTransactionLog(i,"patient_with_surgery",{patientData:this.sanitizeLogData(e),surgeryData:this.sanitizeLogData(t)}),o.setLoading(!0,"Creazione paziente e evento intervento..."),await this.validateSurgeryTransactionData(e,t),this.logTransactionStep(i,"validation","completed",{message:"Dati validati con successo"}),this.logTransactionStep(i,"create_patient","started");const n=await this.createPatientStep(e,!1);this.logTransactionStep(i,"create_patient","completed",{patientId:n.id}),this.logTransactionStep(i,"create_surgery_event","started");const a=await this.createSurgeryEventStep(n.id,t);this.logTransactionStep(i,"create_surgery_event","completed",{eventId:a.id});let s=null;if(t.has_infection&&t.data_infezione){this.logTransactionStep(i,"create_infection_event","started");const e={data_evento:t.data_infezione,agente_patogeno:t.agente_patogeno,descrizione:t.descrizione_infezione};s=await this.createInfectionEventStep(n.id,e),this.logTransactionStep(i,"create_infection_event","completed",{eventId:s.id})}return this.logTransactionStep(i,"verify_synchronization","started"),await this.verifySynchronizationStep(n.id),this.logTransactionStep(i,"verify_synchronization","completed"),this.completeTransactionLog(i,"completed"),r.success("Paziente e evento intervento creati con successo!"),{success:!0,transactionId:i,patient:n,surgeryEvent:a,infectionEvent:s,message:"Transazione completata con successo"}}catch(a){throw n.error(`Errore nella transazione ${i}:`,a),await this.handleTransactionFailure(i,a),a}finally{o.setLoading(!1)}}async executePatientWithSurgeryAndInfectionTransaction(e,t,i){const a=this.generateTransactionId();try{this.initializeTransactionLog(a,"patient_with_surgery_and_infection",{patientData:this.sanitizeLogData(e),surgeryData:this.sanitizeLogData(t),infectionData:this.sanitizeLogData(i)}),o.setLoading(!0,"Creazione paziente, intervento e infezione..."),await this.validateSurgeryTransactionData(e,t),await this.validateTransactionData(e,i),this.logTransactionStep(a,"validation","completed",{message:"Dati validati con successo"}),this.logTransactionStep(a,"create_patient","started");const n=await this.createPatientStep(e,!0);this.logTransactionStep(a,"create_patient","completed",{patientId:n.id}),this.logTransactionStep(a,"create_surgery_event","started");const s=await this.createSurgeryEventStep(n.id,t);this.logTransactionStep(a,"create_surgery_event","completed",{eventId:s.id}),this.logTransactionStep(a,"create_infection_event","started");const c=await this.createInfectionEventStep(n.id,i);return this.logTransactionStep(a,"create_infection_event","completed",{eventId:c.id}),this.logTransactionStep(a,"verify_synchronization","started"),await this.verifySynchronizationStep(n.id),this.logTransactionStep(a,"verify_synchronization","completed"),this.completeTransactionLog(a,"completed"),r.success("Paziente, intervento e infezione creati con successo!"),{success:!0,transactionId:a,patient:n,surgeryEvent:s,infectionEvent:c,message:"Transazione completata con successo"}}catch(s){throw n.error(`Errore nella transazione ${a}:`,s),await this.handleTransactionFailure(a,s),s}finally{o.setLoading(!1)}}async executePatientWithInfectionTransaction(e,t){const i=this.generateTransactionId();try{this.initializeTransactionLog(i,"patient_with_infection",{patientData:this.sanitizeLogData(e),infectionData:this.sanitizeLogData(t)}),o.setLoading(!0,"Creazione paziente e evento infezione..."),await this.validateTransactionData(e,t),this.logTransactionStep(i,"validation","completed",{message:"Dati validati con successo"}),this.logTransactionStep(i,"create_patient","started");const n=await this.createPatientStep(e,!0);this.logTransactionStep(i,"create_patient","completed",{patientId:n.id}),this.logTransactionStep(i,"create_infection_event","started");const a=await this.createInfectionEventStep(n.id,t);return this.logTransactionStep(i,"create_infection_event","completed",{eventId:a.id}),this.logTransactionStep(i,"verify_synchronization","started"),await this.verifySynchronizationStep(n.id),this.logTransactionStep(i,"verify_synchronization","completed"),this.completeTransactionLog(i,"completed"),r.success("Paziente e evento infezione creati con successo!"),{success:!0,transactionId:i,patient:n,infectionEvent:a,message:"Transazione completata con successo"}}catch(a){throw n.error(`Errore nella transazione ${i}:`,a),await this.handleTransactionFailure(i,a),a}finally{o.setLoading(!1)}}async validateSurgeryTransactionData(e,t){if(!e||"object"!=typeof e)throw new Error("Dati paziente non validi");const i=["nome","cognome","data_ricovero"];for(const n of i)if(!e[n]||""===e[n].toString().trim())throw new Error(`Campo paziente obbligatorio mancante: ${n}`);if(!t||"object"!=typeof t)throw new Error("Dati intervento non validi");const a=["data_evento","tipo_intervento"];for(const n of a)if(!t[n]||""===t[n].toString().trim())throw new Error(`Campo intervento obbligatorio mancante: ${n}`);const o=new Date(t.data_evento),r=new Date;if(r.setHours(23,59,59,999),isNaN(o.getTime()))throw new Error("Data evento intervento non valida");if(o>r)throw new Error("La data dell'evento di intervento non può essere nel futuro");if(t.has_infection&&t.data_infezione){const e=new Date(t.data_infezione);if(isNaN(e.getTime()))throw new Error("Data infezione associata non valida");if(e<o)throw new Error("La data dell'infezione non può essere precedente all'intervento")}n.log("Validazione dati transazione intervento completata con successo")}async validateTransactionData(e,t){if(!e||"object"!=typeof e)throw new Error("Dati paziente non validi");const i=["nome","cognome","data_ricovero"];for(const n of i)if(!e[n]||""===e[n].toString().trim())throw new Error(`Campo paziente obbligatorio mancante: ${n}`);if(!t||"object"!=typeof t)throw new Error("Dati infezione non validi");const a=["data_evento"];for(const n of a)if(!t[n]||""===t[n].toString().trim())throw new Error(`Campo infezione obbligatorio mancante: ${n}`);const o=new Date(t.data_evento),r=new Date;if(r.setHours(23,59,59,999),isNaN(o.getTime()))throw new Error("Data evento infezione non valida");if(o>r)throw new Error("La data dell'evento di infezione non può essere nel futuro");n.log("Validazione dati transazione completata con successo")}async createPatientStep(e,t=!1){try{const i={...e,infetto:t,data_infezione:null},a=await p(i);if(!a||!a.id)throw new Error("Creazione paziente fallita: nessun ID restituito");return n.log(`Paziente creato con successo: ID ${a.id}`),a}catch(i){throw n.error("Errore nella creazione paziente:",i),new Error(`Fallimento creazione paziente: ${i.message}`)}}async createSurgeryEventStep(e,i){try{const a={paziente_id:e,tipo_evento:"intervento",data_evento:i.data_evento,tipo_intervento:i.tipo_intervento,descrizione:i.descrizione||null,data_fine_evento:null},o=await t.createEvento(a);if(!o||!o.id)throw new Error("Creazione evento intervento fallita: nessun ID restituito");return n.log(`Evento intervento creato con successo: ID ${o.id}`),o}catch(a){throw n.error("Errore nella creazione evento intervento:",a),new Error(`Fallimento creazione evento intervento: ${a.message}`)}}async createInfectionEventStep(e,i){try{const a={paziente_id:e,tipo_evento:"infezione",data_evento:i.data_evento,agente_patogeno:i.agente_patogeno||null,descrizione:i.descrizione||null,data_fine_evento:null},o=await t.createEvento(a);if(!o||!o.id)throw new Error("Creazione evento infezione fallita: nessun ID restituito");return n.log(`Evento infezione creato con successo: ID ${o.id}`),o}catch(a){throw n.error("Errore nella creazione evento infezione:",a),new Error(`Fallimento creazione evento infezione: ${a.message}`)}}async verifySynchronizationStep(e){try{await new Promise(e=>setTimeout(e,500));const t=await d(e);if(!t)throw new Error("Paziente non trovato durante verifica sincronizzazione");t.infetto||n.warn(`Paziente ${e}: flag infetto non sincronizzato correttamente`),t.data_infezione||n.warn(`Paziente ${e}: data_infezione non sincronizzata correttamente`),n.log(`Sincronizzazione verificata per paziente ${e}`)}catch(t){n.error("Errore nella verifica sincronizzazione:",t),n.warn("Continuando nonostante errore di verifica sincronizzazione")}}async handleTransactionFailure(e,t){const i=this.transactionLogs.get(e);if(!i)return n.error(`Log transazione ${e} non trovato`),void 0;this.logTransactionStep(e,"handle_failure","started",{error:t.message});const a=i.steps.filter(e=>"completed"===e.status),o=a.some(e=>"create_patient"===e.step),r=a.some(e=>"create_infection_event"===e.step);try{r&&!o?(n.warn("Evento infezione creato senza paziente - situazione inconsistente"),await this.handleInconsistentState(e,t)):o&&!r?await this.handlePatientCreatedInfectionFailed(e,t):o?await this.handleLateFailure(e,t):await this.handleEarlyFailure(e,t),this.completeTransactionLog(e,"failed")}catch(s){n.error(`Errore durante gestione fallimento transazione ${e}:`,s),this.completeTransactionLog(e,"rollback_failed")}}async handlePatientCreatedInfectionFailed(e,t){const i=this.transactionLogs.get(e).steps.find(e=>"create_patient"===e.step&&"completed"===e.status);if(!i||!i.data||!i.data.patientId)throw new Error("ID paziente non trovato nel log della transazione");const n=i.data.patientId;throw this.logTransactionStep(e,"recovery_options_presented","completed",{type:"error",title:"Creazione Incompleta",message:`Paziente creato con successo, ma creazione evento infezione fallita. \n                Paziente ID: ${n}\n                Errore: ${t.message}`,actions:[{label:"Riprova Evento Infezione",action:"retry_infection",data:{transactionId:e,patientId:n}},{label:"Completa Manualmente",action:"complete_manually",data:{patientId:n}},{label:"Elimina Paziente",action:"rollback_patient",data:{patientId:n},variant:"danger"}]}),r.error("Paziente creato ma evento infezione fallito. Controlla la sezione notifiche per le opzioni di recovery.",{persistent:!0}),new Error(`Transazione parzialmente completata. Paziente ID: ${n}. ${t.message}`)}async handleEarlyFailure(e,t){this.logTransactionStep(e,"early_failure_handled","completed",{message:"Nessun rollback necessario - nessuna risorsa creata"}),r.error(`Errore nella creazione: ${t.message}`)}async handleLateFailure(e,t){this.logTransactionStep(e,"late_failure_handled","completed",{message:"Transazione sostanzialmente completata nonostante errore finale",originalError:t.message}),r.warning(`Paziente e evento infezione creati, ma si è verificato un errore nella verifica finale: ${t.message}`)}async handleInconsistentState(e,t){this.logTransactionStep(e,"inconsistent_state_detected","completed",{message:"Stato inconsistente rilevato - richiede intervento manuale",originalError:t.message}),r.error(`Stato inconsistente rilevato. Contattare l'amministratore. Transazione ID: ${e}`,{persistent:!0})}async rollbackPatientCreation(e){try{await g(e),n.log(`Rollback completato: paziente ${e} eliminato`),r.success("Rollback completato: paziente eliminato")}catch(t){throw n.error(`Errore nel rollback paziente ${e}:`,t),new Error(`Rollback fallito: ${t.message}`)}}async retryInfectionCreation(e,t,i){const a=`${e}_retry_${Date.now()}`;try{this.initializeTransactionLog(a,"retry_infection_creation",{originalTransactionId:e,patientId:t,infectionData:this.sanitizeLogData(i)});const n=await this.createInfectionEventStep(t,i);return await this.verifySynchronizationStep(t),this.completeTransactionLog(a,"completed"),r.success("Evento infezione creato con successo!"),n}catch(o){throw this.completeTransactionLog(a,"failed"),n.error("Errore nel retry creazione infezione:",o),o}}initializeTransactionLog(e,t,i={}){const a={id:e,type:t,status:"started",steps:[],initialData:i,createdAt:Date.now(),completedAt:null};this.transactionLogs.set(e,a),n.log(`Transazione ${e} inizializzata: ${t}`)}logTransactionStep(e,t,i,a={}){const o=this.transactionLogs.get(e);if(!o)return n.error(`Tentativo di loggare step per transazione inesistente: ${e}`),void 0;const r={step:t,status:i,data:this.sanitizeLogData(a),timestamp:Date.now()};o.steps.push(r),n.log(`Transazione ${e} - Step ${t}: ${i}`)}completeTransactionLog(e,t){const i=this.transactionLogs.get(e);if(!i)return n.error(`Tentativo di completare transazione inesistente: ${e}`),void 0;i.status=t,i.completedAt=Date.now(),n.log(`Transazione ${e} completata con stato: ${t}`)}getTransactionLog(e){return this.transactionLogs.get(e)||null}getAllTransactionLogs(){return Array.from(this.transactionLogs.values())}generateTransactionId(){return`tx_${Date.now()}_${Math.random().toString(36).substr(2,9)}`}sanitizeLogData(e){if(!e||"object"!=typeof e)return e;const t={...e};return["password","token","auth","secret","nome","cognome","codice_fiscale","codice_rad","telefono","email","indirizzo","indirizzo_residenza","citta","cap","note","descrizione"].forEach(e=>{t[e]&&(t[e]="[REDACTED]")}),t}startLogCleanup(){setInterval(()=>{this.cleanupOldLogs()},this.cleanupInterval)}cleanupOldLogs(){const e=Date.now();let t=0;for(const[i,n]of this.transactionLogs.entries())e-n.createdAt>this.maxLogRetention&&(this.transactionLogs.delete(i),t++);t>0&&n.log(`Cleanup log transazioni: ${t} log rimossi`)}getTransactionStats(){const e=Array.from(this.transactionLogs.values());return{total:e.length,byStatus:e.reduce((e,t)=>(e[t.status]=(e[t.status]||0)+1,e),{}),byType:e.reduce((e,t)=>(e[t.type]=(e[t.type]||0)+1,e),{}),oldestLog:e.length>0?Math.min(...e.map(e=>e.createdAt)):null,newestLog:e.length>0?Math.max(...e.map(e=>e.createdAt)):null}}};function u(e){const t=["nome","cognome","data_nascita","data_ricovero","diagnosi","reparto_appartenenza"];for(const i of t)if(!e[i]||""===e[i].toString().trim())throw new Error(`Il campo ${i} è obbligatorio`);if(e.data_nascita){if(new Date(e.data_nascita)>new Date)throw new Error("La data di nascita non può essere nel futuro")}if(e.data_ricovero){if(new Date(e.data_ricovero)>new Date)throw new Error("La data di ricovero non può essere nel futuro")}if(e.data_dimissione){if(new Date(e.data_dimissione)<new Date(e.data_ricovero))throw new Error("La data di dimissione non può essere precedente alla data di ricovero")}if(e.data_infezione){const t=new Date(e.data_infezione),i=new Date(e.data_ricovero),n=new Date;if(t<i)throw new Error("La data di infezione non può essere precedente alla data di ricovero");if(t>n)throw new Error("La data di infezione non può essere nel futuro");if(e.data_dimissione){if(t>new Date(e.data_dimissione))throw new Error("La data di infezione non può essere successiva alla data di dimissione")}}if(e.codice_rad&&""!==e.codice_rad.trim()&&e.codice_rad.length>11)throw new Error("Il codice RAD non può superare i 11 caratteri");if(e.tipo_dimissione){const t=["dimissione","trasferimento_interno","trasferimento_esterno","decesso"];if(!t.includes(e.tipo_dimissione))throw new Error(`Tipo dimissione non valido. Valori ammessi: ${t.join(", ")}`);if("trasferimento_interno"===e.tipo_dimissione&&(!e.reparto_destinazione||""===e.reparto_destinazione.trim()))throw new Error("Il reparto di destinazione è obbligatorio per i trasferimenti interni");if("trasferimento_esterno"===e.tipo_dimissione){if(!e.clinica_destinazione||""===e.clinica_destinazione.trim())throw new Error("La clinica di destinazione è obbligatoria per i trasferimenti esterni");if(!e.codice_clinica)throw new Error("Il codice clinica è obbligatorio per i trasferimenti esterni");const t=["56","60"];if(!t.includes(e.codice_clinica))throw new Error(`Codice clinica non valido. Valori ammessi: ${t.join(", ")}`)}const i=["0","3","6"];if(["dimissione","trasferimento_esterno"].includes(e.tipo_dimissione)){if(!e.codice_dimissione)throw new Error("Il codice dimissione è obbligatorio per il tipo selezionato");if(!i.includes(e.codice_dimissione))throw new Error(`Codice dimissione non valido. Valori ammessi: ${i.join(", ")}`);if("dimissione"===e.tipo_dimissione&&!["0","6"].includes(String(e.codice_dimissione)))throw new Error("Per 'dimissione' sono ammessi solo i codici 0 (ordinaria) o 6 (protetta)");if("trasferimento_esterno"===e.tipo_dimissione&&"3"!==String(e.codice_dimissione))throw new Error("Per 'trasferimento_esterno' è ammesso solo il codice 3")}else if(["trasferimento_interno","decesso"].includes(e.tipo_dimissione)&&e.codice_dimissione)throw new Error("Per 'trasferimento_interno' o 'decesso' il codice dimissione non deve essere valorizzato")}}const _=new class{constructor(){this.cache=new Map,this.cacheTimeout=3e5}async getPatients(e={},t={}){try{o.setLoading(!0,"Caricamento pazienti...");const{page:a=0,limit:r=10}=t,{patients:s,totalCount:l}=await c(e,t);try{const e=(s||[]).filter(e=>e&&"trasferimento_esterno"===e.tipo_dimissione).slice(0,5).map(e=>({id:e.id,codice_clinica:e.codice_clinica}));n.group("[patientService.getPatients] Result summary"),n.log({page:a,limit:r,totalCount:l,sampleExternalTransfers:e}),n.groupEnd()}catch(i){}return{patients:s,totalCount:l,currentPage:a,totalPages:Math.ceil(l/r),hasNextPage:(a+1)*r<l,hasPrevPage:a>0}}catch(a){throw n.error("Errore nel caricamento pazienti:",a),r.error(`Errore nel caricamento: ${a.message}`),a}finally{o.setLoading(!1)}}async getPatientById(e){const t=`patient_${e}`,i=this.cache.get(t);if(i&&Date.now()-i.timestamp<this.cacheTimeout)return i.data;try{const i=await d(e);this.cache.set(t,{data:i,timestamp:Date.now()});try{n.log("[patientService.getPatientById] Received",{id:i?.id,tipo_dimissione:i?.tipo_dimissione,codice_clinica:i?.codice_clinica||null})}catch(a){}return i}catch(o){throw n.error("Errore nel caricamento paziente:",o),r.error(`Errore nel caricamento paziente: ${o.message}`),o}}async createPatient(e){try{o.setLoading(!0,"Creazione paziente..."),u(e);const{data:{user:t}}=await a.auth.getUser();if(!t)throw new Error("Utente non autenticato");const i={...e,user_id:t.id,data_dimissione:null,infetto:Boolean(e.infetto)},n=await p(i);return this.invalidateCache(),r.success("Paziente creato con successo!"),n}catch(t){throw n.error("Errore nella creazione paziente:",t),r.error(`Errore nella creazione: ${t.message}`),t}finally{o.setLoading(!1)}}async updatePatient(e,t,i={showNotification:!0}){try{o.setLoading(!0,"Aggiornamento paziente...");const n=await m(e,t);return this.cache.delete(`patient_${e}`),i.showNotification&&r.success("Paziente aggiornato con successo!"),n}catch(a){throw n.error("Errore nell'aggiornamento paziente:",a),r.error(`Errore nell'aggiornamento: ${a.message}`),a}finally{o.setLoading(!1)}}async deletePatient(e){try{o.setLoading(!0,"Eliminazione paziente..."),await g(e),this.cache.delete(`patient_${e}`),this.invalidateCache(),r.success("Paziente eliminato con successo!")}catch(t){throw n.error("Errore nell'eliminazione paziente:",t),r.error(`Errore nell'eliminazione: ${t.message}`),t}finally{o.setLoading(!1)}}async dischargePatient(e,t=null){try{const i=t||(new Date).toISOString().split("T")[0];await this.updatePatient(e,{data_dimissione:i},{showNotification:!1}),r.success("Paziente dimesso con successo!")}catch(i){throw n.error("Errore nella dimissione:",i),r.error(`Errore nella dimissione: ${i.message}`),i}}async dischargePatientWithTransfer(e,t){try{o.setLoading(!0,"Dimissione paziente..."),function(e){const t=["data_dimissione","tipo_dimissione"];for(const a of t)if(!e[a]||""===e[a].toString().trim())throw new Error(`Il campo ${a} è obbligatorio`);const i=["dimissione","trasferimento_interno","trasferimento_esterno","decesso"];if(!i.includes(e.tipo_dimissione))throw new Error(`Tipo dimissione non valido. Valori ammessi: ${i.join(", ")}`);if(e.data_dimissione&&new Date(e.data_dimissione)>new Date)throw new Error("La data di dimissione non può essere nel futuro");if("trasferimento_interno"===e.tipo_dimissione&&(!e.reparto_destinazione||""===e.reparto_destinazione.trim()))throw new Error("Il reparto di destinazione è obbligatorio per i trasferimenti interni");if("trasferimento_esterno"===e.tipo_dimissione){if(!e.clinica_destinazione||""===e.clinica_destinazione.trim())throw new Error("La clinica di destinazione è obbligatoria per i trasferimenti esterni");if(!e.codice_clinica)throw new Error("Il codice clinica è obbligatorio per i trasferimenti esterni");const t=["56","60"];if(!t.includes(e.codice_clinica))throw new Error(`Codice clinica non valido. Valori ammessi: ${t.join(", ")}`)}const n=["0","3","6"];if(["dimissione","trasferimento_esterno"].includes(e.tipo_dimissione)){if(!e.codice_dimissione)throw new Error("Il codice dimissione è obbligatorio");if(!n.includes(e.codice_dimissione))throw new Error(`Codice dimissione non valido. Valori ammessi: ${n.join(", ")}`);if("dimissione"===e.tipo_dimissione&&!["0","6"].includes(String(e.codice_dimissione)))throw new Error("Per 'dimissione' sono ammessi solo i codici 0 (ordinaria) o 6 (protetta)");if("trasferimento_esterno"===e.tipo_dimissione&&"3"!==String(e.codice_dimissione))throw new Error("Per 'trasferimento_esterno' è ammesso solo il codice 3")}else if(["trasferimento_interno","decesso"].includes(e.tipo_dimissione)&&e.codice_dimissione)throw new Error("Per 'trasferimento_interno' o 'decesso' il codice dimissione non deve essere valorizzato")}(t);const i=await m(e,t);this.cache.delete(`patient_${e}`);return r.success(`Paziente ${"dimissione"===t.tipo_dimissione?"dimesso":"trasferito"} con successo!`),i}catch(i){throw n.error("Errore nella dimissione/trasferimento:",i),r.error(`Errore nella dimissione: ${i.message}`),i}finally{o.setLoading(!1)}}async reactivatePatient(e){try{const t={data_dimissione:null,tipo_dimissione:null,reparto_destinazione:null,clinica_destinazione:null,codice_clinica:null,codice_dimissione:null};await this.updatePatient(e,t,{showNotification:!1}),r.success("Paziente riattivato con successo!")}catch(t){throw n.error("Errore nella riattivazione:",t),r.error(`Errore nella riattivazione: ${t.message}`),t}}async searchPatients(e,t=!1){try{return await f(e,t)}catch(i){throw n.error("Errore nella ricerca pazienti:",i),r.error(`Errore nella ricerca: ${i.message}`),i}}async exportPatients(e={}){try{o.setLoading(!0,"Preparazione esportazione...");const i=await l(e);try{const e=(i||[]).filter(e=>e&&"trasferimento_esterno"===e.tipo_dimissione).slice(0,5).map(e=>({id:e.id,codice_clinica:e.codice_clinica}));n.group("[patientService.exportPatients] Export dataset sample"),n.log({total:i?.length||0,sampleExternalTransfers:e}),n.groupEnd()}catch(t){}if(!i||0===i.length)return r.warning("Nessun dato da esportare per i filtri selezionati."),void 0;!function(e,t){const i=new Blob([e],{type:"text/csv;charset=utf-8;"}),n=document.createElement("a");n.href=URL.createObjectURL(i),n.download=t,document.body.appendChild(n),n.click(),document.body.removeChild(n)}([["Nome","Cognome","Data Nascita","Data Ricovero","Data Dimissione","Diagnosi","Reparto Appartenenza","Reparto Provenienza","Livello Assistenza","Codice RAD","Infetto"],...i.map(e=>[e.nome||"",e.cognome||"",e.data_nascita?new Date(e.data_nascita).toLocaleDateString():"",e.data_ricovero?new Date(e.data_ricovero).toLocaleDateString():"",e.data_dimissione?new Date(e.data_dimissione).toLocaleDateString():"",e.diagnosi||"",e.reparto_appartenenza||"",e.reparto_provenienza||"",e.livello_assistenza||"",e.codice_rad||"",e.infetto?"Sì":"No"])].map(e=>e.map(e=>`"${e.toString().replace(/"/g,'""')}"`).join(",")).join("\n"),"esportazione_pazienti.csv"),r.success(`Esportati ${i.length} pazienti con successo!`)}catch(i){throw n.error("Errore nell'esportazione:",i),r.error(`Errore nell'esportazione: ${i.message}`),i}finally{o.setLoading(!1)}}async getPatientStats(){try{const e=await h(),t={total:e.length,active:e.filter(e=>!e.data_dimissione).length,discharged:e.filter(e=>e.data_dimissione).length,byDiagnosis:{},byDepartment:{}};return e.forEach(e=>{t.byDiagnosis[e.diagnosi]=(t.byDiagnosis[e.diagnosi]||0)+1,t.byDepartment[e.reparto_appartenenza]=(t.byDepartment[e.reparto_appartenenza]||0)+1}),t}catch(e){throw n.error("Errore nel caricamento statistiche:",e),e}}async getTransferHistory(e){try{const t=await this.getPatientById(e);if(!t)throw new Error("Paziente non trovato");const i=[];return t.data_dimissione&&t.tipo_dimissione&&i.push({data:t.data_dimissione,tipo:t.tipo_dimissione,reparto_destinazione:t.reparto_destinazione,clinica_destinazione:t.clinica_destinazione,codice_clinica:t.codice_clinica,codice_dimissione:t.codice_dimissione}),i}catch(t){throw n.error("Errore nel caricamento cronologia trasferimenti:",t),r.error(`Errore nel caricamento cronologia: ${t.message}`),t}}invalidateCache(){this.cache.clear()}async createPatientWithInfection(e,t){try{if(n.log("Avvio creazione paziente con infezione:",{patientName:`${e.nome} ${e.cognome}`,infectionDate:t.data_evento}),u(e),i.setInfectionData(t),!i.hasValidInfectionData()){const e=i.getValidationErrors().map(e=>e.message).join(", ");throw new Error(`Dati infezione non validi: ${e}`)}const a=await z.executePatientWithInfectionTransaction(e,t);return i.clearInfectionData(),this.invalidateCache(),n.log("Creazione paziente con infezione completata con successo:",{transactionId:a.transactionId,patientId:a.patient?.id,infectionEventId:a.infectionEvent?.id}),a}catch(a){throw n.error("Errore nella creazione paziente con infezione:",a),a.message.includes("Dati infezione non validi")?r.error(`Errore nei dati di infezione: ${a.message}`):a.message.includes("Transazione parzialmente completata")?n.warn("Transazione parzialmente completata - recovery options presentate"):r.error(`Errore nella creazione: ${a.message}`),a}}async handleInfectionEventCreation(e,a){try{n.log(`Creazione evento infezione per paziente ${e}`);if(!(await this.getPatientById(e)))throw new Error(`Paziente con ID ${e} non trovato`);if(i.setInfectionData(a),!i.hasValidInfectionData()){const e=i.getValidationErrors().map(e=>e.message).join(", ");throw new Error(`Dati infezione non validi: ${e}`)}const o=(await t.getEventiByPaziente(e,{tipo_evento:"infezione"})).filter(e=>!e.data_fine_evento);if(o.length>0)throw n.warn(`Paziente ${e} ha già un'infezione attiva`),r.warning(`Il paziente ha già un'infezione attiva dal ${o[0].data_evento}. Vuoi comunque creare un nuovo evento di infezione?`,{persistent:!0,actions:[{label:"Crea Comunque",action:"force_create_infection"},{label:"Annulla",action:"cancel_infection"}]}),new Error("Paziente ha già un'infezione attiva");const s={paziente_id:e,tipo_evento:"infezione",data_evento:a.data_evento,agente_patogeno:a.agente_patogeno||null,descrizione:a.descrizione||null,data_fine_evento:null},c=await t.createEvento(s);return i.clearInfectionData(),this.cache.delete(`patient_${e}`),n.log(`Evento infezione creato con successo: ID ${c.id}`),c}catch(o){if(n.error(`Errore nella creazione evento infezione per paziente ${e}:`,o),o.message.includes("già un'infezione attiva"))throw o;throw o.message.includes("Dati infezione non validi")?r.error(`Errore nei dati di infezione: ${o.message}`):o.message.includes("non trovato")?r.error("Paziente non trovato"):r.error(`Errore nella creazione evento infezione: ${o.message}`),o}}async retryInfectionEventCreation(e,t,i){try{return n.log(`Retry creazione evento infezione - Transazione: ${e}, Paziente: ${t}`),await z.retryInfectionCreation(e,t,i)}catch(a){throw n.error("Errore nel retry creazione evento infezione:",a),r.error(`Errore nel retry: ${a.message}`),a}}async rollbackPatientCreation(e){try{n.log(`Rollback creazione paziente: ${e}`),await z.rollbackPatientCreation(e),this.cache.delete(`patient_${e}`),this.invalidateCache()}catch(t){throw n.error(`Errore nel rollback paziente ${e}:`,t),r.error(`Errore nel rollback: ${t.message}`),t}}async forceCreateInfectionEvent(e,a){try{if(n.log(`Creazione forzata evento infezione per paziente ${e}`),i.setInfectionData(a),!i.hasValidInfectionData()){const e=i.getValidationErrors().map(e=>e.message).join(", ");throw new Error(`Dati infezione non validi: ${e}`)}const o={paziente_id:e,tipo_evento:"infezione",data_evento:a.data_evento,agente_patogeno:a.agente_patogeno||null,descrizione:a.descrizione||null,data_fine_evento:null},s=await t.createEvento(o);return i.clearInfectionData(),this.cache.delete(`patient_${e}`),r.success("Nuovo evento infezione creato con successo!"),s}catch(o){throw n.error("Errore nella creazione forzata evento infezione:",o),r.error(`Errore nella creazione: ${o.message}`),o}}async createPatientWithSurgery(t,i){try{n.log("Avvio creazione paziente con intervento chirurgico:",{patientName:`${t.nome} ${t.cognome}`,surgeryDate:i.data_evento,surgeryType:i.tipo_intervento}),u(t);const{default:a}=await e(async()=>{const{default:e}=await import("./surgeryDataManager-CbtGeuzn.js");return{default:e}},[]);if(a.setSurgeryData(i),!a.hasValidSurgeryData()){const e=a.getValidationErrors().map(e=>e.message).join(", ");throw new Error(`Dati intervento non validi: ${e}`)}const o=await z.executePatientWithSurgeryTransaction(t,i);return a.clearSurgeryData(),this.invalidateCache(),n.log("Creazione paziente con intervento completata con successo:",{transactionId:o.transactionId,patientId:o.patient?.id,surgeryEventId:o.surgeryEvent?.id}),o}catch(a){throw n.error("Errore nella creazione paziente con intervento:",a),a.message.includes("Dati intervento non validi")?r.error(`Errore nei dati di intervento: ${a.message}`):a.message.includes("Transazione parzialmente completata")?n.warn("Transazione parzialmente completata - recovery options presentate"):r.error(`Errore nella creazione: ${a.message}`),a}}async createPatientWithSurgeryAndInfection(t,a,o){try{n.log("Avvio creazione paziente con intervento e infezione:",{patientName:`${t.nome} ${t.cognome}`,surgeryDate:a.data_evento,infectionDate:o.data_evento||a.data_infezione}),u(t);const{default:r}=await e(async()=>{const{default:e}=await import("./surgeryDataManager-CbtGeuzn.js");return{default:e}},[]);if(r.setSurgeryData(a),!r.hasValidSurgeryData()){const e=r.getValidationErrors().map(e=>e.message).join(", ");throw new Error(`Dati intervento non validi: ${e}`)}let s=o;if(!s&&r.hasAssociatedInfection()&&(s=r.prepareInfectionEventData()),s&&(i.setInfectionData(s),!i.hasValidInfectionData())){const e=i.getValidationErrors().map(e=>e.message).join(", ");throw new Error(`Dati infezione non validi: ${e}`)}const c=await z.executePatientWithSurgeryAndInfectionTransaction(t,a,s);return r.clearSurgeryData(),s&&i.clearInfectionData(),this.invalidateCache(),n.log("Creazione paziente con intervento e infezione completata con successo:",{transactionId:c.transactionId,patientId:c.patient?.id,surgeryEventId:c.surgeryEvent?.id,infectionEventId:c.infectionEvent?.id}),c}catch(s){throw n.error("Errore nella creazione paziente con intervento e infezione:",s),s.message.includes("non validi")?r.error(`Errore nei dati: ${s.message}`):s.message.includes("Transazione parzialmente completata")?n.warn("Transazione parzialmente completata - recovery options presentate"):r.error(`Errore nella creazione: ${s.message}`),s}}getTransactionStats(){return z.getTransactionStats()}getTransactionLog(e){return z.getTransactionLog(e)}async handleTemporaryEventsCreation(e,i){try{o.setLoading(!0,"Salvataggio eventi clinici...");for(const n of i){const i={...n};delete i.id,delete i.isTemporary,i.paziente_id=e,await t.createEvento(i)}r.success(`${i.length} eventi clinici salvati con successo`)}catch(a){throw n.error("Errore nella creazione eventi temporanei:",a),r.error("Errore nel salvare gli eventi clinici"),a}finally{o.setLoading(!1)}}async createPatientWithTemporaryEvents(e,i){try{o.setLoading(!0,"Creazione paziente ed eventi clinici...");const n=await p(e);for(const e of i){const i={...e};delete i.id,delete i.isTemporary,i.paziente_id=n.id,await t.createEvento(i)}return r.success(`Paziente e ${i.length} eventi clinici creati con successo`),{patient:n,events:i,success:!0}}catch(a){throw n.error("Errore nella creazione paziente con eventi temporanei:",a),r.error("Errore nella creazione del paziente e degli eventi"),a}finally{o.setLoading(!1)}}};export{_ as patientService};
