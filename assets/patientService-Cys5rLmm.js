import{l as e,c as t,f as i,_ as n}from"./index-Bv42dTXT.js";import{a,c as o,n as r}from"./notificationErrorHandler-s5LKbSWA.js";const s=10,c=(e={})=>{let i=t.from("pazienti").select("*",{count:"exact"}).not("user_id","is",null);const{reparto:n,diagnosi:a,stato:o,search:r,infetto:s}=e;if(n&&(i=i.eq("reparto_appartenenza",n)),a&&(i=i.eq("diagnosi",a)),"attivo"===o&&(i=i.is("data_dimissione",null)),"dimesso"===o&&(i=i.not("data_dimissione","is",null)),void 0!==s&&(i=i.eq("infetto","true"===s)),r){const e=r.trim().split(/\s+/).filter(e=>e.length>0);if(1===e.length)i=i.or(`nome.ilike.%${e[0]}%,cognome.ilike.%${e[0]}%,codice_rad.ilike.%${e[0]}%`);else if(2===e.length){const[t,n]=e;i=i.or([`and(nome.ilike.%${t}%,nome.ilike.%${n}%)`,`and(cognome.ilike.%${t}%,cognome.ilike.%${n}%)`,`and(nome.ilike.%${t}%,cognome.ilike.%${n}%)`,`and(cognome.ilike.%${t}%,nome.ilike.%${n}%)`,`codice_rad.ilike.%${t}%${n}%`,`codice_rad.ilike.%${n}%${t}%`].join(","))}else{const t=[];e.forEach(e=>{t.push(`nome.ilike.%${e}%`,`cognome.ilike.%${e}%`,`codice_rad.ilike.%${e}%`)}),i=i.or(t.join(","))}}return i},l={getPaginatedPatients:async(t={},i={})=>{const{page:n=0,limit:a=s,sortColumn:o="data_ricovero",sortDirection:r="desc"}=i;let l=c(t);const d=n*a,u=d+a-1;l=l.order(o,{ascending:"asc"===r}).range(d,u);const{data:p,error:h,count:g}=await l;if(h)throw h;try{const t=(p||[]).filter(e=>e&&"trasferimento_esterno"===e.tipo_dimissione).slice(0,5).map(e=>({id:e.id,codice_clinica:e.codice_clinica}));e.group("[patientApi.getPaginatedPatients] Result summary"),e.log({total:p?.length||0,count:g,externalTransfersSample:t}),e.groupEnd()}catch(f){}return{patients:p||[],totalCount:g||0}},getAllPatients:async(t={})=>{const{sortColumn:i="data_ricovero",sortDirection:n="desc"}=t;let a=c(t);a=a.order(i,{ascending:"asc"===n}).limit(5e3);const{data:o,error:r}=await a;if(r)throw r;try{const t=(o||[]).filter(e=>e&&"trasferimento_esterno"===e.tipo_dimissione).slice(0,5).map(e=>({id:e.id,codice_clinica:e.codice_clinica}));e.group("[patientApi.getAllPatients] Result sample"),e.log({total:o?.length||0,externalTransfersSample:t}),e.groupEnd()}catch(s){}return o||[]},getPatientById:async i=>{const{data:n,error:a}=await t.from("pazienti").select("*").eq("id",i).single();if(a)throw a;try{e.log("[patientApi.getPatientById] Loaded",{id:n?.id,tipo_dimissione:n?.tipo_dimissione,codice_clinica:n?.codice_clinica||null})}catch(o){}return n},createPatient:async e=>{const i={...e},{id:n,...a}=i,{data:o,error:r}=await t.from("pazienti").insert(a).select("*").single();if(r)throw r;return o},updatePatient:async(i,n)=>{try{e.group("[patientApi.updatePatient] Update payload"),e.log({id:i,codice_clinica:n?.codice_clinica??null,tipo_dimissione:n?.tipo_dimissione??null}),e.groupEnd()}catch(r){}const{data:a,error:o}=await t.from("pazienti").update(n).eq("id",i).select().single();if(o)throw o;try{e.group("[patientApi.updatePatient] Update result"),e.log({id:a?.id,tipo_dimissione:a?.tipo_dimissione??null,codice_clinica:a?.codice_clinica??null}),e.groupEnd()}catch(r){}return a},deletePatient:async e=>{const{error:i}=await t.from("pazienti").delete().eq("id",e);if(i)throw i},searchPatients:async(e,i=!1,n=50)=>{const a=e.trim().split(/\s+/).filter(e=>e.length>0);let o=t.from("pazienti").select("id, nome, cognome, codice_rad, data_ricovero, diagnosi, reparto_appartenenza").not("user_id","is",null);if(1===a.length)o=o.or(`nome.ilike.%${a[0]}%,cognome.ilike.%${a[0]}%,codice_rad.ilike.%${a[0]}%`);else if(2===a.length){const[e,t]=a;o=o.or([`and(nome.ilike.%${e}%,nome.ilike.%${t}%)`,`and(cognome.ilike.%${e}%,cognome.ilike.%${t}%)`,`and(nome.ilike.%${e}%,cognome.ilike.%${t}%)`,`and(cognome.ilike.%${e}%,nome.ilike.%${t}%)`,`codice_rad.ilike.%${e}%${t}%`,`codice_rad.ilike.%${t}%${e}%`].join(","))}else{const e=[];a.forEach(t=>{e.push(`nome.ilike.%${t}%`,`cognome.ilike.%${t}%`,`codice_rad.ilike.%${t}%`)}),o=o.or(e.join(","))}o=o.order("cognome"),i&&(o=o.is("data_dimissione",null));const{data:r,error:s}=await o.limit(Math.max(1,Number(n)||50));if(s)throw s;return r||[]},getStatsData:async()=>{const{data:e,error:i}=await t.from("pazienti").select("data_dimissione, diagnosi, reparto_appartenenza").not("user_id","is",null);if(i)throw i;return e||[]}},d=["Nome","Cognome","Data Nascita","Data Ricovero","Data Dimissione","Diagnosi","Reparto Appartenenza","Reparto Provenienza","Livello Assistenza","Codice RAD","Infetto"];function u(e,t){if(!e)return t.nullValue||"";try{const i=new Date(e);switch(t.dateFormat){case"iso":return i.toISOString().split("T")[0];case"locale":default:return i.toLocaleDateString();case"custom":return t.customDateFormat?i.toLocaleDateString("it-IT",t.customDateFormat):i.toLocaleDateString()}}catch(i){return t.nullValue||""}}function p(e,t){if(null==e)return t.nullValue||"";switch(t.booleanFormat){case"true/false":return e?"true":"false";case"yes/no":default:return e?"Sì":"No";case"1/0":return e?"1":"0"}}const h=(e,t,i="text/plain;charset=utf-8;")=>{const n=new Blob([e],{type:i}),a=document.createElement("a");if(void 0!==a.download){const e=URL.createObjectURL(n);a.setAttribute("href",e),a.setAttribute("download",t),a.style.visibility="hidden",document.body.appendChild(a),a.click(),document.body.removeChild(a),setTimeout(()=>{URL.revokeObjectURL(e)},100)}else{const n=window.open("","_blank");n&&(n.document.write(`\n        <html>\n          <body>\n            <pre>${e}</pre>\n            <p><a href="data:${i},${encodeURIComponent(e)}" download="${t}">Download ${t}</a></p>\n          </body>\n        </html>\n      `),n.document.close())}};const g=new class{async exportPatients(t={}){try{i.getState().setLoading(!0);const e=await l.getAllPatients(t);if(this._logExportSample(e,"CSV"),!e||0===e.length)return a("Nessun dato da esportare per i filtri selezionati."),void 0;const n=((e,t={})=>{const{delimiter:i=",",headers:n=d,includeHeaders:a=!0,dateFormat:o="locale",booleanFormat:r="yes/no",nullValue:s=""}=t;return[...a?n:[],...e.map(e=>{const t=e;return[t.nome||s,t.cognome||s,u(t.data_nascita,{dateFormat:o,nullValue:s}),u(t.data_ricovero,{dateFormat:o,nullValue:s}),u(t.data_dimissione,{dateFormat:o,nullValue:s}),t.diagnosi||s,t.reparto_appartenenza||s,t.reparto_provenienza||s,t.livello_assistenza||s,t.codice_rad||s,p(t.infetto,{booleanFormat:r,nullValue:s})]})].map(e=>(Array.isArray(e)?e:[e]).map(e=>{return`"${t=String(e),t.toString().replace(/"/g,'""')}"`;var t}).join(i)).join("\n")})(e);void h(n,"esportazione_pazienti.csv","text/csv;charset=utf-8;"),o(`Esportati ${e.length} pazienti con successo!`)}catch(n){e.error("Errore nell'esportazione:",n);const t=n instanceof Error?n.message:String(n);throw t.includes("network")||t.includes("fetch")?r("Impossibile connettersi al server. Verifica la tua connessione."):t.includes("permission")||t.includes("autorizzato")?r("Non hai i permessi per esportare questi dati."):r(`Impossibile esportare i dati: ${t}`),n}finally{i.getState().setLoading(!1)}}async exportPatientsJSON(t={}){try{i.getState().setLoading(!0);const e=await l.getAllPatients(t);if(!e||0===e.length)return a("Nessun dato da esportare per i filtri selezionati."),void 0;const n=((e,t={})=>{const{pretty:i=!0,indent:n=2}=t;return JSON.stringify(e,null,i?n:0)})(e);void h(n,"esportazione_pazienti.json","application/json;charset=utf-8;"),o(`Esportati ${e.length} pazienti in JSON con successo!`)}catch(n){e.error("Errore nell'esportazione JSON:",n);const t=n instanceof Error?n.message:String(n);throw t.includes("network")||t.includes("fetch")?r("Impossibile connettersi al server. Verifica la tua connessione."):t.includes("permission")||t.includes("autorizzato")?r("Non hai i permessi per esportare questi dati."):r(`Impossibile esportare i dati in JSON: ${t}`),n}finally{i.getState().setLoading(!1)}}_logExportSample(t,i){try{const n=(t||[]).filter(e=>e&&"trasferimento_esterno"===e.tipo_dimissione).slice(0,5).map(e=>({id:e.id,codice_clinica:e.codice_clinica}));e.group(`[PatientExportService.export${i}] Export dataset sample`),e.log({total:t?.length||0,sampleExternalTransfers:n}),e.groupEnd()}catch(n){}}};let f=null,v=null;async function m(){if(!f){const e=await n(()=>import("./infectionDataManager-DK5Uhw4D.js"),[]);f=e.default}return f}async function _(){if(!v){const e=await n(()=>import("./surgeryDataManager-D7d3_gaM.js"),[]);v=e.default}return v}async function y(){const[e,t]=await Promise.all([m(),_()]);return{infection:e,surgery:t}}const z=new class{transactionLogs;maxLogRetention;cleanupInterval;constructor(){this.transactionLogs=new Map,this.maxLogRetention=864e5,this.cleanupInterval=36e5,this.startLogCleanup()}generateTransactionId(){return`tx_${Date.now()}_${Math.random().toString(36).substr(2,9)}`}initializeTransactionLog(t,i,n={}){const a={id:t,type:i,status:"started",steps:[],initialData:this.sanitizeLogData(n),createdAt:Date.now(),completedAt:null};return this.transactionLogs.set(t,a),e.log(`Transazione ${t} inizializzata: ${i}`),a}logTransactionStep(t,i,n,a={}){const o=this.transactionLogs.get(t);if(!o)return e.error(`Tentativo di loggare step per transazione inesistente: ${t}`),void 0;const r={step:i,status:n,data:this.sanitizeLogData(a),timestamp:Date.now()};o.steps.push(r),e.log(`Transazione ${t} - Step ${i}: ${n}`)}completeTransactionLog(t,i){const n=this.transactionLogs.get(t);if(!n)return e.error(`Tentativo di completare transazione inesistente: ${t}`),void 0;n.status=i,n.completedAt=Date.now(),e.log(`Transazione ${t} completata con stato: ${i}`)}getTransactionLog(e){return this.transactionLogs.get(e)||null}getAllTransactionLogs(){return Array.from(this.transactionLogs.values())}getTransactionStats(){const e=Array.from(this.transactionLogs.values());return{total:e.length,byStatus:e.reduce((e,t)=>(e[t.status]=(e[t.status]||0)+1,e),{}),byType:e.reduce((e,t)=>(e[t.type]=(e[t.type]||0)+1,e),{}),oldestLog:e.length>0?Math.min(...e.map(e=>e.createdAt)):null,newestLog:e.length>0?Math.max(...e.map(e=>e.createdAt)):null}}sanitizeLogData(e){if(!e||"object"!=typeof e)return e;const t={...e};return["password","token","auth","secret","nome","cognome","codice_fiscale","codice_rad","telefono","email","indirizzo","indirizzo_residenza","citta","cap","note","descrizione"].forEach(e=>{t[e]&&(t[e]="[REDACTED]")}),t}startLogCleanup(){setInterval(()=>{this.cleanupOldLogs()},this.cleanupInterval)}cleanupOldLogs(){const t=Date.now();let i=0;for(const[e,n]of this.transactionLogs.entries())t-n.createdAt>this.maxLogRetention&&(this.transactionLogs.delete(e),i++);i>0&&e.log(`Cleanup log transazioni: ${i} log rimossi`)}};const w=new class{cache=new Map;cacheTimeout=3e5;stats={hits:0,misses:0,entries:0,lastCleanup:Date.now()};cleanupInterval=null;constructor(e=3e5){this.cacheTimeout=e,this.startAutoCleanup()}generateCacheKey(e={},t={}){const i={filters:{paziente_search:e.paziente_search?.trim()||"",paziente_id:e.paziente_id||"",tipo_evento:e.tipo_evento||"",data_inizio:e.data_inizio||"",data_fine:e.data_fine||""},pagination:{page:t.page??0,limit:t.limit??10,sortColumn:t.sortColumn||"data_evento",sortDirection:t.sortDirection||"desc"}};return`search_${JSON.stringify(i)}`}get(t={},i={}){const n=this.generateCacheKey(t,i),a=this.cache.get(n);if(a){if(!(Date.now()-a.timestamp>this.cacheTimeout))return this.stats.hits++,e.debug(`Cache HIT: ${n.substring(0,50)}... (TTL: ${(this.cacheTimeout-(Date.now()-a.timestamp))/1e3}s remaining)`),a.result;this.cache.delete(n),e.debug(`Cache EXPIRED: ${n.substring(0,50)}...`)}return this.stats.misses++,null}set(t={},i={},n){const a=this.generateCacheKey(t,i);this.cache.set(a,{result:n,timestamp:Date.now()}),this.stats.entries=this.cache.size,e.debug(`Cache SET: ${a.substring(0,50)}... (${n.totalCount} events)`)}has(e={},t={}){return null!==this.get(e,t)}invalidatePatient(t){let i=0;for(const[e]of this.cache.entries())e.includes(`"paziente_id":"${t}"`)&&(this.cache.delete(e),i++);i>0&&(this.stats.entries=this.cache.size,e.debug(`Cache INVALIDATED: ${i} entries for patient ${t}`))}invalidateEventType(t){let i=0;for(const[e]of this.cache.entries())e.includes(`"tipo_evento":"${t}"`)&&(this.cache.delete(e),i++);i>0&&(this.stats.entries=this.cache.size,e.debug(`Cache INVALIDATED: ${i} entries for event type ${t}`))}invalidateDateRange(t,i){let n=0;for(const[e]of this.cache.entries())e.includes('"data_')&&(this.cache.delete(e),n++);n>0&&(this.stats.entries=this.cache.size,e.debug(`Cache INVALIDATED: ${n} entries for date range ${t} to ${i}`))}clear(){const t=this.cache.size;this.cache.clear(),this.stats={hits:0,misses:0,entries:0,lastCleanup:Date.now()},e.debug(`Cache CLEARED: ${t} entries removed`)}cleanup(){const t=Date.now();let i=0;for(const[e,n]of this.cache.entries())t-n.timestamp>this.cacheTimeout&&(this.cache.delete(e),i++);this.stats.entries=this.cache.size,this.stats.lastCleanup=t,i>0&&e.debug(`Cache CLEANUP: ${i} expired entries removed`)}startAutoCleanup(){this.cleanupInterval&&clearInterval(this.cleanupInterval),this.cleanupInterval=setInterval(()=>this.cleanup(),6e4)}stopAutoCleanup(){this.cleanupInterval&&(clearInterval(this.cleanupInterval),this.cleanupInterval=null)}getStats(){const e=this.stats.hits+this.stats.misses;return{...this.stats,hitRate:Number((e>0?this.stats.hits/e*100:0).toFixed(2))}}setCacheTimeout(t){this.cacheTimeout=Math.max(0,t),e.debug(`Cache timeout set to ${t}ms`)}getCacheTimeout(){return this.cacheTimeout}getCacheKeys(){return Array.from(this.cache.keys()).map(e=>e.substring(0,80)+"...")}getDebugInfo(){return{totalEntries:this.cache.size,cacheTimeout:this.cacheTimeout,stats:this.getStats(),keys:this.getCacheKeys().slice(0,10),memoryUsage:`~${(JSON.stringify(Array.from(this.cache.entries())).length/1024).toFixed(2)}KB`}}};const E=new class{rules=new Map;stats={totalInvalidations:0,selectiveInvalidations:0,fullInvalidations:0,rulesApplied:0,cacheEntriesCleared:0,lastInvalidation:0};constructor(){this.initializeDefaultRules()}initializeDefaultRules(){this.addRule({id:"intervention-events",name:"Intervention Events",description:"Invalidates cache entries related to surgical interventions",eventType:"intervento",affects:["search:*tipo_evento:intervento*","search:*:*","events-paziente_*"],dependencies:[],priority:10}),this.addRule({id:"infection-events",name:"Infection Events",description:"Invalidates cache entries related to infections",eventType:"infezione",affects:["search:*tipo_evento:infezione*","search:*:*","events-paziente_*","patient-infection-status_*"],dependencies:[],priority:10}),this.addRule({id:"patient-data-changes",name:"Patient Data Changes",description:"Invalidates all cache entries when patient data changes",eventType:"patient-update",affects:["search:*:*","events-paziente_*","patient-search_*"],dependencies:[],priority:20}),this.addRule({id:"new-event-statistics",name:"New Event Statistics",description:"Invalidates statistics cache when new events are added",eventType:"create",affects:["event-stats_*","suggested-filters_*"],dependencies:[],priority:5}),e.debug("Initialized default cache invalidation rules")}addRule(t){this.rules.set(t.id,t),e.debug(`Added cache invalidation rule: ${t.name}`)}removeRule(t){const i=this.rules.delete(t);return i&&e.debug(`Removed cache invalidation rule: ${t}`),i}getRules(){return Array.from(this.rules.values())}invalidateCache(t,i,n={}){const a=Date.now();if(this.stats.totalInvalidations++,n.forceFullInvalidation){const t=this.performFullInvalidation();return this.stats.fullInvalidations++,this.stats.lastInvalidation=Date.now(),e.debug(`Performed full cache invalidation in ${Date.now()-a}ms`),{invalidated:!0,entriesCleared:t,rulesApplied:0,strategy:"full"}}const o=this.findApplicableRules(t,i);if(0===o.length)return e.debug(`No applicable invalidation rules for event type: ${t}`),{invalidated:!1,entriesCleared:0,rulesApplied:0,strategy:"none"};o.sort((e,t)=>t.priority-e.priority);const r=new Set;let s=0;for(const e of o)e.condition&&!e.condition(i)||(e.affects.forEach(e=>{this.getCacheKeysByPattern(e,n.patientId).forEach(e=>r.add(e))}),s++,this.stats.rulesApplied++);if(0===r.size)return e.debug("No cache entries would be affected by invalidation rules"),{invalidated:!1,entriesCleared:0,rulesApplied:s,strategy:"none"};const c=this.performSelectiveInvalidation(Array.from(r));return this.stats.selectiveInvalidations++,this.stats.cacheEntriesCleared+=c,this.stats.lastInvalidation=Date.now(),e.debug(`Performed selective cache invalidation in ${Date.now()-a}ms: ${c} entries cleared, ${s} rules applied`),{invalidated:!0,entriesCleared:c,rulesApplied:s,strategy:"selective"}}findApplicableRules(e,t){const i=[];for(const n of this.rules.values())n.eventType!==e?n.dependencies.includes(e)&&i.push(n):i.push(n);return i}getCacheKeysByPattern(e,t){const i=[];if("search:*:*"===e)i.push(...w.getCacheKeys());else if(e.startsWith("search:")){const t=e.replace("search:","");i.push(...w.getCacheKeys().filter(e=>e.includes(t)))}else e.startsWith("events-paziente_")?t&&i.push(`events-paziente_${t}`):e.startsWith("patient-infection-status_")&&t&&i.push(`patient-infection-status_${t}`);return i}performSelectiveInvalidation(e){let t=0;for(const i of e)i.startsWith("search_")?(w.clear(),t++):(i.startsWith("events-paziente_")||i.startsWith("patient-infection-status_"))&&t++;return t}performFullInvalidation(){return w.clear(),1}getStats(){const e=this.stats.totalInvalidations,t=this.stats.totalInvalidations>0?this.stats.rulesApplied/this.stats.totalInvalidations:0;return{...this.stats,selectiveRate:Number((e>0?this.stats.selectiveInvalidations/e*100:0).toFixed(2)),averageRulesPerInvalidation:Number(t.toFixed(2))}}resetStats(){this.stats={totalInvalidations:0,selectiveInvalidations:0,fullInvalidations:0,rulesApplied:0,cacheEntriesCleared:0,lastInvalidation:0},e.debug("Cache invalidation statistics reset")}getDebugInfo(){return{totalRules:this.rules.size,rules:Array.from(this.rules.values()).map(e=>({id:e.id,name:e.name,eventType:e.eventType,affectsCount:e.affects.length,priority:e.priority})),stats:this.getStats()}}};class I{fieldValidators=new Map;field(e,t,i=!1){return this.fieldValidators.set(e,{field:e,rules:t,optional:i}),this}async validateField(t,i,n){const a=this.fieldValidators.get(t);if(!a)return{valid:!0};if(a.optional&&this.isEmpty(i))return{valid:!0};for(const r of a.rules)try{const e=await r(i,n);if(!e.valid)return e}catch(o){return e.error("[Validator] Rule execution error",{field:t,error:o}),{valid:!1,error:"Errore durante la validazione"}}return{valid:!0}}async validate(e,t){const i={},n=[];for(const[a,o]of this.fieldValidators){const o=(async()=>{const n=e[a],o=await this.validateField(a,n,t);!o.valid&&o.error&&(i[a]=o.error)})();n.push(o)}return await Promise.all(n),i}validateSync(t,i){const n={};for(const[o,r]of this.fieldValidators){const s=t[o];if(!r.optional||!this.isEmpty(s))for(const t of r.rules)try{const a=t(s,i);if(a instanceof Promise){e.warn("[Validator] Async rule used in validateSync",{field:o});continue}if(!a.valid&&a.error){n[o]=a.error;break}}catch(a){e.error("[Validator] Rule execution error",{field:o,error:a}),n[o]="Errore durante la validazione";break}}return n}isEmpty(e){return null==e||("string"==typeof e?0===e.trim().length:Array.isArray(e)?0===e.length:"object"==typeof e&&0===Object.keys(e).length)}async isValid(e,t){const i=await this.validate(e,t);return 0===Object.keys(i).length}clear(){this.fieldValidators.clear()}getFields(){return Array.from(this.fieldValidators.keys())}}const D=e=>{if(e instanceof Date)return!isNaN(e.getTime());if("string"==typeof e){const t=new Date(e);return!isNaN(t.getTime())}return!1},b=e=>{if(!e)return!1;return("string"==typeof e?new Date(e):e)>(()=>{const e=new Date;return e.setHours(0,0,0,0),e})()},S="La data dell'intervento non può essere futura",$="La data di inizio infezione non può essere futura",P="La data di fine infezione non può essere futura",C="La data di fine non può essere precedente alla data di inizio",T=(e,t,i="intervento")=>{if(!e)return null;if(b(e))return"intervento"===i?S:$;if(t){const i=new Date(e);if(new Date(t)<i)return C;if(b(t))return P}return null};function L(e="Campo obbligatorio"){return t=>null==t||"string"==typeof t&&0===t.trim().length||Array.isArray(t)&&0===t.length?{valid:!1,error:e}:{valid:!0}}function A(e,t){return i=>!i||i.length<e?{valid:!1,error:t||`Lunghezza minima: ${e} caratteri`}:{valid:!0}}function R(e,t){return i=>i&&i.length>e?{valid:!1,error:t||`Lunghezza massima: ${e} caratteri`}:{valid:!0}}function k(e="La data non può essere futura"){return t=>t?D(t)?b(t)?{valid:!1,error:e}:{valid:!0}:{valid:!1,error:"Data non valida"}:{valid:!0}}function N(e="Data non valida"){return t=>t?D(t)?{valid:!0}:{valid:!1,error:e}:{valid:!0}}function q(e,t="La data di fine deve essere successiva alla data di inizio"){return(i,n)=>{if(!i||!n)return{valid:!0};const a=e(n);return a&&((e,t)=>{const i="string"==typeof e?new Date(e):e;return("string"==typeof t?new Date(t):t)<i})(a,i)?{valid:!1,error:t}:{valid:!0}}}function x(e,t){return i=>e.includes(i)?{valid:!0}:{valid:!1,error:t||"Valore non valido"}}function M(e,t){return(i,n)=>e(i,n)?{valid:!0}:{valid:!1,error:t}}function V(e,t){return(i,n)=>e(n)?t(i,n):{valid:!0}}const O=["intervento","infezione"],F=["batterico","virale","fungino","parassitario"];async function j(e){return(new I).field("paziente_id",[L("Il paziente è obbligatorio")]).field("tipo_evento",[L("Il tipo evento è obbligatorio"),x(O,"Tipo evento non valido")]).field("data_evento",[L("La data evento è obbligatoria"),N("Data evento non valida"),k("La data evento non può essere nel futuro")]).field("note",[R(1e3,"Le note non possono superare 1000 caratteri")],!0).field("tipo_intervento_id",[M((e,t)=>"intervento"!==t?.tipo_evento||null!=e&&!isNaN(e),"La specialistica è obbligatoria per gli interventi")]).field("descrizione_intervento",[M(e=>{if(!e)return!0;const t=e.trim();return!(0!==t.length&&(t.length<3||t.length>500))},"La descrizione deve essere tra 3 e 500 caratteri")],!0).field("agente_patogeno_id",[M((e,t)=>"infezione"!==t?.tipo_evento||null!=e&&!isNaN(e)||null!=t?.tipo_patogeno,"Specificare agente patogeno o tipo patogeno per le infezioni")]).field("tipo_patogeno",[x(F,"Tipo patogeno non valido")],!0).field("data_fine_evento",[N("Data fine evento non valida"),k("La data fine evento non può essere nel futuro"),V(e=>!!e?.data_evento&&!!e?.data_fine_evento&&"infezione"===e?.tipo_evento,q(e=>e.data_evento,"La data di fine evento non può essere precedente alla data di inizio"))],!0).validate(e,e)}const W={nome:"Nome",cognome:"Cognome",codice_rad:"Codice RAD",data_ricovero:"Data Ricovero",reparto_appartenenza:"Reparto Appartenenza",reparto_provenienza:"Reparto Provenienza",diagnosi:"Diagnosi",user_id:"Utente"};function K(e,t={}){const i="string"==typeof e?e:e?.message||"",n="object"==typeof e&&e&&"details"in e?e.details:"",a="object"==typeof e&&e&&"code"in e?e.code:void 0,{entity:o="record",operation:r}=t,s=()=>{const e=[/column\s+'([^']+)'/i,/"([^"]+)"\s+column/i,/Key\s*\(([^)]+)\)/i,/column\s+"([^"]+)"/i];for(const t of e){const e=t.exec(i)||(n?t.exec(n):null);if(e&&e[1])return e[1]}};if("23502"===a||/violates not-null constraint/i.test(i)||/null value in column/i.test(i)){const e=s();if("user_id"===e)return"Utente non autenticato. Effettua nuovamente l'accesso e riprova.";if(!e)return"Compila tutti i campi obbligatori.";const t=W[e]||function(e){return e?e.split("_").filter(Boolean).map(e=>e.charAt(0).toUpperCase()+e.slice(1)).join(" "):""}(e);return`Il campo "${c=t,c?c.charAt(0).toUpperCase()+c.slice(1):c}" è obbligatorio.`}var c;if("23505"===a||/duplicate key value violates unique constraint/i.test(i))return/codice_rad/i.test(i)?`Esiste già un ${o} con lo stesso Codice RAD.`:"Alcuni valori devono essere unici: verifica i dati inseriti.";if("23503"===a||/violates foreign key constraint/i.test(i)){const e=s();return`Valore non valido per ${e&&W[e]?W[e]:"alcuni campi"}. Seleziona un'opzione corretta e riprova.`}if("23514"===a||/violates check constraint/i.test(i))return"Alcuni dati non rispettano i vincoli richiesti. Verifica i campi e riprova.";if("PGRST301"===a||/JWT|auth|unauth/i.test(i))return"Sessione scaduta o non valida. Effettua l'accesso e riprova.";return`Si è verificato un errore durante il ${r||"salvataggio"} del ${o}. Verifica i campi e riprova.`}class U extends Error{field;constructor(e,t){super(t),this.field=e,this.name="ValidationError"}}const J=new class{defaultOptions={showNotification:!0,logError:!0,severity:"medium"};handle(e,t={}){const i={...this.defaultOptions,...t},n=this.processError(e,i);return i.logError&&this.logError(n,i),i.showNotification&&this.showErrorNotification(n),n}async handleAsync(e,t={}){try{return await e()}catch(i){throw this.handle(i,t),i}}handleValidationErrors(e,t={}){const i=Object.keys(e);if(0===i.length)return null;const n=i[0],a=new U(n,e[n]);return this.handle(a,{...t,severity:"low"})}processError(e,t){const i=this.categorizeError(e);return{category:i,severity:t.severity||this.defaultOptions.severity,userMessage:this.getUserMessage(e,i,t),technicalMessage:this.getTechnicalMessage(e),originalError:e,context:t.context}}categorizeError(e){if(e instanceof U)return"validation";const t=this.getErrorMessage(e).toLowerCase();return this.isDatabaseError(e,t)?"database":this.isNetworkError(t)?"network":this.isAuthError(t)?"authentication":this.isAuthorizationError(t)?"authorization":this.isNotFoundError(t)?"not_found":e instanceof Error?"application":"unknown"}isDatabaseError(e,t){if("object"==typeof e&&null!==e&&"code"in e){const t=e.code;if("string"==typeof t&&(t.startsWith("23")||t.startsWith("PGRST")))return!0}return t.includes("database")||t.includes("postgres")||t.includes("supabase")||t.includes("duplicate key")||t.includes("foreign key")||t.includes("unique constraint")||t.includes("not-null constraint")}isNetworkError(e){return e.includes("network")||e.includes("fetch")||e.includes("connection")||e.includes("timeout")||e.includes("offline")}isAuthError(e){return e.includes("auth")||e.includes("login")||e.includes("session")||e.includes("jwt")||e.includes("token")||e.includes("unauthorized")}isAuthorizationError(e){return e.includes("forbidden")||e.includes("permission")||e.includes("access denied")||e.includes("not allowed")}isNotFoundError(e){return e.includes("not found")||e.includes("404")}getUserMessage(e,t,i){if(i.userMessage)return i.userMessage;switch(t){case"validation":return this.getErrorMessage(e);case"database":return K(e,{entity:i.entity,operation:i.operation});case"network":return"Errore di connessione. Verifica la tua connessione internet e riprova.";case"authentication":return"Sessione scaduta. Effettua nuovamente l'accesso.";case"authorization":return"Non hai i permessi necessari per eseguire questa operazione.";case"not_found":return i.entity?`${i.entity} non trovato.`:"Risorsa non trovata.";case"application":const t=this.getErrorMessage(e);return i.operation?`Errore durante ${i.operation}: ${t}`:t;default:return i.operation?`Si è verificato un errore durante ${i.operation}. Riprova.`:"Si è verificato un errore. Riprova."}}getTechnicalMessage(e){return e instanceof Error?`${e.name}: ${e.message}`:String(e)}getErrorMessage(e){return e instanceof Error?e.message:"string"==typeof e?e:"object"==typeof e&&null!==e&&"message"in e?String(e.message):"Errore sconosciuto"}logError(t,i){const n=i.operation?`[${i.operation}] ${t.technicalMessage}`:t.technicalMessage,a={category:t.category,severity:t.severity,userMessage:t.userMessage,context:t.context,error:t.originalError};switch(t.severity){case"critical":case"high":e.error(n,a);break;case"medium":e.warn(n,a);break;case"low":e.info(n,a)}}showErrorNotification(e){r(e.userMessage)}};async function B(e){const t=await j(e),i=Object.keys(t);if(i.length>0){const e=i.map(e=>t[e]).filter(Boolean);throw new Error(e.join(", "))}}const G=new class{async createEvento(e){try{i.getState().setLoading(!0),await B(e);const n={paziente_id:e.paziente_id,tipo_evento:e.tipo_evento,data_evento:e.data_evento};"intervento"===e.tipo_evento&&(e.tipo_intervento_id&&(n.tipo_intervento_id=e.tipo_intervento_id),n.descrizione=e.descrizione_intervento||e.note||null),"infezione"===e.tipo_evento&&(e.agente_patogeno_id&&(n.agente_patogeno_id=e.agente_patogeno_id),n.descrizione=e.note||null,e.tipo_patogeno&&(n.tipo_patogeno=e.tipo_patogeno),e.data_fine_evento&&(n.data_fine_evento=e.data_fine_evento));const{data:a,error:r}=await t.from("eventi_clinici").insert([n]).select().single();if(r)throw r;return"infezione"===e.tipo_evento&&await this._updatePazienteInfezioneStatus(e.paziente_id),this.invalidateCache(),o("Evento creato con successo!"),a}catch(n){throw J.handle(n,{operation:"creazione evento",entity:"Evento"}),n}finally{i.getState().setLoading(!1)}}async updateEvento(n,a){try{i.getState().setLoading(!0),await B(a);const r={data_evento:a.data_evento};"intervento"===a.tipo_evento&&(r.descrizione=a.descrizione_intervento||a.note||null,null!=a.tipo_intervento_id&&(r.tipo_intervento_id=a.tipo_intervento_id)),"infezione"===a.tipo_evento&&(r.descrizione=a.note||null,null!=a.agente_patogeno_id&&(r.agente_patogeno_id=a.agente_patogeno_id),a.tipo_patogeno&&(r.tipo_patogeno=a.tipo_patogeno),a.data_fine_evento&&(r.data_fine_evento=a.data_fine_evento)),e.info("Updating event:",{id:n,dataToUpdate:r});const{data:s,error:c}=await t.from("eventi_clinici").update(r).eq("id",n).select().single();if(c)throw e.error("Supabase update error:",{error:c,dataToUpdate:r}),c;return"infezione"===a.tipo_evento&&await this._updatePazienteInfezioneStatus(a.paziente_id),this.invalidateCache(),o("Evento aggiornato con successo!"),s}catch(r){throw J.handle(r,{operation:"aggiornamento evento",entity:"Evento"}),r}finally{i.getState().setLoading(!1)}}async deleteEvento(e){try{i.getState().setLoading(!0);const{data:n,error:a}=await t.from("eventi_clinici").select("paziente_id, tipo_evento").eq("id",e).single();if(a&&"PGRST116"!==a.code)throw a;const{error:r}=await t.from("eventi_clinici").delete().eq("id",e);if(r)throw r;n&&"infezione"===n.tipo_evento&&await this._updatePazienteInfezioneStatus(n.paziente_id),this.invalidateCache(),o("Evento eliminato con successo!")}catch(n){throw J.handle(n,{operation:"eliminazione evento",entity:"Evento"}),n}finally{i.getState().setLoading(!1)}}async resolveInfezione(e,n){try{i.getState().setLoading(!0);const{data:a,error:r}=await t.from("eventi_clinici").select("data_evento, paziente_id").eq("id",e).eq("tipo_evento","infezione").single();if(r)throw r;const s=new Date(a.data_evento);if(new Date(n)<s)throw new Error("La data di risoluzione non può essere precedente alla data dell'infezione");const{data:c,error:l}=await t.from("eventi_clinici").update({data_fine_evento:n}).eq("id",e).select().single();if(l)throw l;return await this._updatePazienteInfezioneStatus(a.paziente_id),this.invalidateCache(),o("Infezione risolta con successo!"),c}catch(a){throw J.handle(a,{operation:"risoluzione infezione",entity:"Infezione"}),a}finally{i.getState().setLoading(!1)}}invalidateCache(){w.clear()}invalidateSelectiveCache(e,t){e?E.invalidateCache(e,{},{patientId:t}):this.invalidateCache()}async _updatePazienteInfezioneStatus(i){try{const{data:n,error:a}=await t.from("eventi_clinici").select("id, data_evento").eq("paziente_id",i).eq("tipo_evento","infezione").is("data_fine_evento",null).order("data_evento",{ascending:!1}).limit(1);if(a)throw a;const o=n&&n.length>0,{error:r}=await t.from("pazienti").update({infetto:o,data_infezione:o?n[0].data_evento:null}).eq("id",i);r&&e.error("Supabase patient update error:",r)}catch(n){e.error("Error updating patient infection status:",n)}}};const H=new class{async getListaTipiIntervento(){try{const{data:e,error:i}=await t.from("tipi_intervento").select("id, nome, descrizione").eq("attivo",!0).order("nome",{ascending:!0});if(i)throw i;return e||[]}catch(i){return e.error("Error loading surgery types:",i),[]}}async getListaAgentiPatogeno(){try{const{data:e,error:i}=await t.from("agenti_patogeno").select("id, nome, descrizione").eq("attivo",!0).order("nome",{ascending:!0});if(i)throw i;return e||[]}catch(i){return e.error("Error loading pathogenic agents:",i),[]}}};const Q=new class{requests=new Map;defaultTimeout=3e4;stats={total:0,duplicates:0,cancelled:0,completed:0,timedOut:0,active:0};cleanupInterval=null;constructor(e=3e4){this.defaultTimeout=e,this.startAutoCleanup()}generateRequestSignature(e,t={}){const i={method:t.method||"GET",...t.body&&{body:t.body},...t.params&&{params:t.params},...t.headers&&{headers:Object.fromEntries(Object.entries(t.headers).filter(([e])=>!e.toLowerCase().includes("auth")).sort(([e],[t])=>e.localeCompare(t)))}};return`${e}:${JSON.stringify(i)}`}async executeRequest(t,i,n={},a=this.defaultTimeout){const o=this.generateRequestSignature(t,n),r=this.requests.get(o);if(r)return this.stats.duplicates++,e.debug(`Request DUPLICATE: ${o.substring(0,50)}... (returning existing promise)`),r.promise;const s=new AbortController,c=setTimeout(()=>{s.signal.aborted||(s.abort(),this.stats.timedOut++,e.debug(`Request TIMEOUT: ${o.substring(0,50)}...`))},a),l=i(s.signal).then(e=>(this.cleanupRequest(o),this.stats.completed++,e)).catch(t=>{throw this.cleanupRequest(o),"AbortError"!==t.name&&e.error(`Request FAILED: ${o.substring(0,50)}...`,t),t});return this.requests.set(o,{controller:s,promise:l,timestamp:Date.now(),timeout:c}),this.stats.total++,this.stats.active++,e.debug(`Request STARTED: ${o.substring(0,50)}... (active: ${this.stats.active})`),l}cancelRequest(t){const i=this.requests.get(t);return!(!i||i.controller.signal.aborted)&&(i.controller.abort(),this.cleanupRequest(t),this.stats.cancelled++,e.debug(`Request CANCELLED: ${t.substring(0,50)}...`),!0)}cancelAllRequests(){let t=0;for(const[e]of this.requests.entries())this.cancelRequest(e)&&t++;return e.debug(`Cancelled ${t} active requests`),t}cancelRequestsMatching(t){let i=0;const n="string"==typeof t?new RegExp(t):t;for(const[e]of this.requests.entries())n.test(e)&&this.cancelRequest(e)&&i++;return i>0&&e.debug(`Cancelled ${i} requests matching pattern`),i}getStats(){const e=this.stats.total,t=e>0?this.stats.cancelled/e*100:0;return{...this.stats,duplicateRate:Number((e>0?this.stats.duplicates/e*100:0).toFixed(2)),cancellationRate:Number(t.toFixed(2))}}getActiveRequests(){const e=Date.now();return Array.from(this.requests.entries()).map(([t,i])=>({signature:t.substring(0,80)+"...",timestamp:i.timestamp,age:e-i.timestamp}))}cleanupRequest(e){const t=this.requests.get(e);t&&(t.timeout&&clearTimeout(t.timeout),this.requests.delete(e),this.stats.active=Math.max(0,this.stats.active-1))}cleanup(){const t=Date.now();let i=0;for(const[e,n]of this.requests.entries()){(t-n.timestamp>3e5||n.controller.signal.aborted)&&(this.cleanupRequest(e),i++)}i>0&&e.debug(`Request cleanup: ${i} old requests removed`)}startAutoCleanup(){this.cleanupInterval&&clearInterval(this.cleanupInterval),this.cleanupInterval=setInterval(()=>this.cleanup(),6e4)}stopAutoCleanup(){this.cleanupInterval&&(clearInterval(this.cleanupInterval),this.cleanupInterval=null)}resetStats(){this.stats={total:0,duplicates:0,cancelled:0,completed:0,timedOut:0,active:this.requests.size},e.debug("Request statistics reset")}getDebugInfo(){return{activeRequests:this.requests.size,stats:this.getStats(),activeRequestsList:this.getActiveRequests().slice(0,10),memoryUsage:`~${(JSON.stringify(Array.from(this.requests.entries())).length/1024).toFixed(2)}KB`}}};const X=new class{async handle(t,i){e.error(`Error ${i}:`,t);const n={JWT:"Sessione scaduta. Effettua nuovamente l'accesso.",network:"Impossibile connettersi al server.",fetch:"Impossibile connettersi al server.",duplicate:"Questo evento esiste già.","foreign key":"Paziente non trovato.",23503:"Paziente non trovato."};for(const[e,a]of Object.entries(n))if(t.message?.includes(e))return r(a),void 0;r(`Errore ${i}: ${t.message}`)}};const Y=new class{async getAllEventi(e={},n={}){const a=`getAllEventi:${JSON.stringify({filters:e,pagination:n})}`;return Q.executeRequest(a,async a=>{try{i.getState().setLoading(!0);const{tipo_evento:a=[],paziente_id:o,paziente_search:r,data_inizio:s,data_fine:c,reparto:l}=e,{page:d=1,limit:u=20,sortColumn:p="data_evento",sortDirection:h="desc"}=n,g="number"==typeof u&&Number.isFinite(u)&&u>0?u:20,f="number"==typeof d&&Number.isFinite(d)&&d>0?d:1;let v=f-1;const m=w.get(e,n);if(m)return m;let _=null;if(r?.trim()&&(_=await this._getPazientiIdsForSearch(r),0===_.length))return this._emptyResult(f);const y=e=>{const i={count:"exact",head:e?.head??!1};let n=t.from("eventi_clinici").select("\n              *,\n              pazienti!inner(\n                id,\n                nome,\n                cognome,\n                codice_rad,\n                reparto_appartenenza,\n                data_dimissione\n              )\n            ",i);return o?n=n.eq("paziente_id",o):_&&(n=n.in("paziente_id",_)),a&&a.length>0&&(n=n.in("tipo_evento",a)),s&&(n=n.gte("data_evento",s)),c&&(n=n.lte("data_evento",c)),l&&(n=n.eq("pazienti.reparto_appartenenza",l)),n};let z=null;if(v>0){const{count:e,error:t}=await y({head:!0});if(t)throw t;z=e??0;const i=z>0?Math.max(0,Math.ceil(z/g)-1):0;v>i&&(v=i)}let E=y();const I=v*g,D=I+g-1;E=E.order(p,{ascending:"asc"===h}).range(I,D);const{data:b,error:S,count:$}=await E;if(S&&"PGRST116"===S.code)return this._emptyResult(v+1);if(S)throw S;const P=z??$??0,C=P>0?Math.ceil(P/g):0,T={eventi:b||[],totalCount:P,currentPage:v+1,totalPages:C,hasNextPage:P>0&&v<C-1,hasPrevPage:v>0};return w.set(e,n,T),T}catch(o){throw await X.handle(o,"loading events"),o}finally{i.getState().setLoading(!1)}},{method:"GET"},3e4)}async getEventiByPaziente(e,i={}){try{let n=t.from("eventi_clinici").select("*").eq("paziente_id",e).order("data_evento",{ascending:!1});i.tipo_evento&&i.tipo_evento.length>0&&(n=n.in("tipo_evento",i.tipo_evento));const{data:a,error:o}=await n;if(o)throw o;return a||[]}catch(n){throw await X.handle(n,"loading patient events"),n}}async searchPazienti(i,n=!0){if(!i?.trim())return[];try{const e=`%${i.trim()}%`;let a=t.from("pazienti").select("id, nome, cognome, codice_rad, reparto_appartenenza, data_dimissione").or(`nome.ilike.${e},cognome.ilike.${e},codice_rad.ilike.${e}`).order("cognome").limit(10);n&&(a=a.is("data_dimissione",null));const{data:o,error:r}=await a;if(r)throw r;return o||[]}catch(a){return e.error("Error searching patients:",a),[]}}async getGiorniPostOperatori(i,n=null){try{const{data:e,error:a}=await t.from("eventi_clinici").select("data_evento, tipo_intervento, descrizione").eq("paziente_id",i).eq("tipo_evento","intervento").order("data_evento",{ascending:!1}).limit(1);if(a)throw a;if(!e||0===e.length)return{giorni:null,ultimoIntervento:null};const o=e[0],r=n?new Date(n):new Date,s=new Date(o.data_evento),c=Math.abs(r.getTime()-s.getTime());return{giorni:Math.ceil(c/864e5),ultimoIntervento:{data:o.data_evento,tipo:o.tipo_intervento||"",descrizione:o.descrizione||void 0}}}catch(a){return e.error("Error calculating post-operative days:",a),{giorni:null,ultimoIntervento:null}}}async _getPazientiIdsForSearch(i){try{const e=`%${i.trim()}%`,{data:n,error:a}=await t.from("pazienti").select("id").or(`nome.ilike.${e},cognome.ilike.${e},codice_rad.ilike.${e}`);if(a)throw a;return n?.map(e=>e.id)||[]}catch(n){return e.error("Error searching patient IDs:",n),[]}}_emptyResult(e){return{eventi:[],totalCount:0,currentPage:e,totalPages:0,hasNextPage:!1,hasPrevPage:!1}}};const Z=new class{async getEventiStats(){try{const{data:e,error:i}=await t.from("eventi_clinici").select("tipo_evento, data_evento, pazienti!inner(id)");if(i)throw i;const n=e||[],a={total:n.length,interventi:n.filter(e=>"intervento"===e.tipo_evento).length,infezioni:n.filter(e=>"infezione"===e.tipo_evento).length,ultimoMese:0},o=new Date;return o.setMonth(o.getMonth()-1),a.ultimoMese=n.filter(e=>new Date(e.data_evento)>=o).length,a}catch(i){throw e.error("Error loading event statistics:",i),i}}};const ee=new class{async getAllEventi(e={},t={}){return Y.getAllEventi(e,t)}async getEventiByPaziente(e,t){return Y.getEventiByPaziente(e,t)}async searchPazienti(e,t){return Y.searchPazienti(e,t)}async getGiorniPostOperatori(e,t){return Y.getGiorniPostOperatori(e,t)}async createEvento(e){return G.createEvento(e)}async updateEvento(e,t){return G.updateEvento(e,t)}async deleteEvento(e){return G.deleteEvento(e)}async resolveInfezione(e,t){return G.resolveInfezione(e,t)}async getListaTipiIntervento(){return H.getListaTipiIntervento()}async getListaAgentiPatogeno(){return H.getListaAgentiPatogeno()}async getEventiStats(){return Z.getEventiStats()}invalidateCache(){G.invalidateCache()}invalidateSelectiveCache(e,t){G.invalidateSelectiveCache(e,t)}};const te=new class{async createPatientStep(t,i=!1){try{const n={...t,infetto:i,data_infezione:null},a=await l.createPatient(n);if(!a||!a.id)throw new Error("Creazione paziente fallita: nessun ID restituito");return e.log(`Paziente creato con successo: ID ${a.id}`),a}catch(n){throw e.error("Errore nella creazione paziente:",n),new Error(`Fallimento creazione paziente: ${n?.message??String(n)}`)}}async createInfectionEventStep(t,i){try{const n={paziente_id:t,tipo_evento:"infezione",data_evento:i.data_evento,agente_patogeno_id:i.agente_patogeno_id||null,tipo_patogeno:i.tipo_patogeno||null,descrizione:i.descrizione||null,data_fine_evento:i.data_fine_evento||null},a=await ee.createEvento(n);if(!a||!a.id)throw new Error("Creazione evento infezione fallita: nessun ID restituito");return e.log(`Evento infezione creato con successo: ID ${a.id}`),a}catch(n){throw e.error("Errore nella creazione evento infezione:",n),new Error(`Fallimento creazione evento infezione: ${n?.message??String(n)}`)}}async createSurgeryEventStep(t,i){try{const n={paziente_id:t,tipo_evento:"intervento",data_evento:i.data_evento,tipo_intervento_id:i.tipo_intervento_id,descrizione:i.descrizione||null,data_fine_evento:null},a=await ee.createEvento(n);if(!a||!a.id)throw new Error("Creazione evento intervento fallita: nessun ID restituito");return e.log(`Evento intervento creato con successo: ID ${a.id}`),a}catch(n){throw e.error("Errore nella creazione evento intervento:",n),new Error(`Fallimento creazione evento intervento: ${n?.message??String(n)}`)}}async verifySynchronizationStep(t){try{await new Promise(e=>setTimeout(e,500));const i=await l.getPatientById(t);if(!i)throw new Error("Paziente non trovato durante verifica sincronizzazione");i.infetto||e.warn(`Paziente ${t}: flag infetto non sincronizzato correttamente`),i.data_infezione||e.warn(`Paziente ${t}: data_infezione non sincronizzata correttamente`),e.log(`Sincronizzazione verificata per paziente ${t}`)}catch(i){e.error("Errore nella verifica sincronizzazione:",i),e.warn("Continuando nonostante errore di verifica sincronizzazione")}}async rollbackPatientCreation(t){try{await l.deletePatient(t),e.log(`Rollback completato: paziente ${t} eliminato`)}catch(i){throw e.error(`Errore nel rollback paziente ${t}:`,i),new Error(`Rollback fallito: ${i?.message??String(i)}`)}}};const ie=new class{async handleTransactionFailure(t,i){const n=z.getTransactionLog(t);if(!n)return e.error(`Log transazione ${t} non trovato`),void 0;z.logTransactionStep(t,"handle_failure","started",{error:i.message});const a=n.steps.filter(e=>"completed"===e.status),o=a.some(e=>"create_patient"===e.step),r=a.some(e=>"create_infection_event"===e.step);try{r&&!o?await this.handleInconsistentState(t,i):o&&!r?await this.handlePatientCreatedInfectionFailed(t,i):o?await this.handleLateFailure(t,i):await this.handleEarlyFailure(t,i),z.completeTransactionLog(t,"failed")}catch(s){e.error(`Errore durante gestione fallimento transazione ${t}:`,s),z.completeTransactionLog(t,"rollback_failed")}}async handlePatientCreatedInfectionFailed(e,t){const i=z.getTransactionLog(e).steps.find(e=>"create_patient"===e.step&&"completed"===e.status);if(!i||!i.data||!i.data.patientId)throw new Error("ID paziente non trovato nel log della transazione");const n=i.data.patientId;throw z.logTransactionStep(e,"recovery_options_presented","completed",{type:"error",title:"Creazione Incompleta",message:`Paziente creato con successo, ma creazione evento infezione fallita. \n                Paziente ID: ${n}\n                Errore: ${t.message}`,actions:[{label:"Riprova Evento Infezione",action:"retry_infection",data:{transactionId:e,patientId:n}},{label:"Completa Manualmente",action:"complete_manually",data:{patientId:n}},{label:"Elimina Paziente",action:"rollback_patient",data:{patientId:n},variant:"danger"}]}),r("Paziente creato ma evento infezione fallito. Controlla la sezione notifiche per le opzioni di recovery.",{persistent:!0}),new Error(`Transazione parzialmente completata. Paziente ID: ${n}. ${t.message}`)}async handleEarlyFailure(e,t){z.logTransactionStep(e,"early_failure_handled","completed",{message:"Nessun rollback necessario - nessuna risorsa creata"}),r(`Errore nella creazione: ${t.message}`)}async handleLateFailure(e,t){z.logTransactionStep(e,"late_failure_handled","completed",{message:"Transazione sostanzialmente completata nonostante errore finale",originalError:t.message}),a(`Paziente e evento infezione creati, ma si è verificato un errore nella verifica finale: ${t.message}`)}async handleInconsistentState(e,t){z.logTransactionStep(e,"inconsistent_state_detected","completed",{message:"Stato inconsistente rilevato - richiede intervento manuale",originalError:t.message}),r(`Stato inconsistente rilevato. Contattare l'amministratore. Transazione ID: ${e}`,{persistent:!0})}async retryInfectionCreation(t,i,n){const a=`${t}_retry_${Date.now()}`;try{z.initializeTransactionLog(a,"retry_infection_creation",{originalTransactionId:t,patientId:i,infectionData:n});const e=await te.createInfectionEventStep(i,n);return await te.verifySynchronizationStep(i),z.completeTransactionLog(a,"completed"),o("Evento infezione creato con successo!"),e}catch(r){throw z.completeTransactionLog(a,"failed"),e.error("Errore nel retry creazione infezione:",r),r}}};const ne=new class{async validatePatientData(e){if(!e||"object"!=typeof e)throw new Error("Dati paziente non validi");const t=["nome","cognome","data_ricovero"];for(const i of t)if(!e[i]||""===e[i].toString().trim())throw new Error(`Campo paziente obbligatorio mancante: ${i}`)}async validateInfectionData(e){if(!e||"object"!=typeof e)throw new Error("Dati infezione non validi");const t=["data_evento"];for(const i of t)if(!e[i]||""===e[i].toString().trim())throw new Error(`Campo infezione obbligatorio mancante: ${i}`);await this.validateEventDate(e.data_evento,"evento infezione")}async validateSurgeryData(e){if(!e||"object"!=typeof e)throw new Error("Dati intervento non validi");const t=["data_evento","tipo_intervento"];for(const i of t)if(!e[i]||""===e[i].toString().trim())throw new Error(`Campo intervento obbligatorio mancante: ${i}`);if(await this.validateEventDate(e.data_evento,"evento intervento"),e.has_infection&&e.data_infezione){const t=new Date(e.data_infezione),i=new Date(e.data_evento);if(isNaN(t.getTime()))throw new Error("Data infezione associata non valida");if(t<i)throw new Error("La data dell'infezione non può essere precedente all'intervento")}}async validateEventDate(e,t){const i=new Date(e),n=new Date;if(n.setHours(23,59,59,999),isNaN(i.getTime()))throw new Error(`Data ${t} non valida`);if(i>n)throw new Error(`La data dell'${t} non può essere nel futuro`)}async validateTransactionData(t,i,n){switch(await this.validatePatientData(t),n){case"infection":await this.validateInfectionData(i);break;case"surgery":await this.validateSurgeryData(i);break;default:throw new Error(`Tipo evento non supportato: ${n}`)}e.log(`Validazione dati transazione ${n} completata con successo`)}};const ae=new class{async executeTransaction(t){const n=z.generateTransactionId();try{z.initializeTransactionLog(n,t.type,t.data),i.getState().setLoading(!0),await this.validateTransaction(n,t);const e=await this.createPatient(n,t),a=await this.createEvents(n,t,e.id);return await this.verifyTransaction(n,e.id),z.completeTransactionLog(n,"completed"),o(t.successMessage),this.formatResult(n,e,a)}catch(a){throw e.error(`Errore nella transazione ${n}:`,a),await ie.handleTransactionFailure(n,a),a}finally{i.getState().setLoading(!1)}}async validateTransaction(e,t){z.logTransactionStep(e,"validation","started"),await ne.validatePatientData(t.data.patientData);for(const i of t.events)await ne.validateTransactionData(t.data.patientData,t.data[i.dataKey],i.type);z.logTransactionStep(e,"validation","completed",{message:"Dati validati con successo"})}async createPatient(e,t){z.logTransactionStep(e,"create_patient","started");const i=t.events.some(e=>"infection"===e.type),n=await te.createPatientStep(t.data.patientData,i);return z.logTransactionStep(e,"create_patient","completed",{patientId:n.id}),n}async createEvents(e,t,i){const n={};for(const a of t.events){const o=`create_${a.type}_event`;let r;switch(z.logTransactionStep(e,o,"started"),a.type){case"infection":r=await te.createInfectionEventStep(i,t.data[a.dataKey]);break;case"surgery":r=await te.createSurgeryEventStep(i,t.data[a.dataKey]);break;default:throw new Error(`Tipo evento non supportato: ${a.type}`)}n[a.resultKey]=r,z.logTransactionStep(e,o,"completed",{eventId:r.id})}if(t.data.surgeryData?.has_infection&&t.data.surgeryData?.data_infezione){const a="create_infection_event";z.logTransactionStep(e,a,"started");const o={data_evento:t.data.surgeryData.data_infezione,agente_patogeno:t.data.surgeryData.agente_patogeno,descrizione:t.data.surgeryData.descrizione_infezione},r=await te.createInfectionEventStep(i,o);n.infectionEvent=r,z.logTransactionStep(e,a,"completed",{eventId:r.id})}return n}async verifyTransaction(e,t){z.logTransactionStep(e,"verify_synchronization","started"),await te.verifySynchronizationStep(t),z.logTransactionStep(e,"verify_synchronization","completed")}formatResult(e,t,i){return{success:!0,transactionId:e,patient:t,...i,message:"Transazione completata con successo"}}};const oe=new class{async executePatientWithSurgeryTransaction(e,t){return ae.executeTransaction({type:"patient_with_surgery",loadingMessage:"Creazione paziente e evento intervento...",successMessage:"Paziente e evento intervento creati con successo!",data:{patientData:e,surgeryData:t},events:[{type:"surgery",dataKey:"surgeryData",resultKey:"surgeryEvent"}]})}async executePatientWithSurgeryAndInfectionTransaction(e,t,i){return ae.executeTransaction({type:"patient_with_surgery_and_infection",loadingMessage:"Creazione paziente, intervento e infezione...",successMessage:"Paziente, intervento e infezione creati con successo!",data:{patientData:e,surgeryData:t,infectionData:i},events:[{type:"surgery",dataKey:"surgeryData",resultKey:"surgeryEvent"},{type:"infection",dataKey:"infectionData",resultKey:"infectionEvent"}]})}async executePatientWithInfectionTransaction(e,t){return ae.executeTransaction({type:"patient_with_infection",loadingMessage:"Creazione paziente e evento infezione...",successMessage:"Paziente e evento infezione creati con successo!",data:{patientData:e,infectionData:t},events:[{type:"infection",dataKey:"infectionData",resultKey:"infectionEvent"}]})}async rollbackPatientCreation(e){await te.rollbackPatientCreation(e)}async retryInfectionCreation(e,t,i){return ie.retryInfectionCreation(e,t,i)}getTransactionLog(e){return z.getTransactionLog(e)}getAllTransactionLogs(){return z.getAllTransactionLogs()}getTransactionStats(){return z.getTransactionStats()}};const re=new class{async createPatientWithInfection(t,i){try{e.log("Avvio creazione paziente con infezione:",{patientName:`${t.nome} ${t.cognome}`,infectionDate:i.data_evento}),await this._validateInfectionData(i);const n=await oe.executePatientWithInfectionTransaction(t,i);return(await m()).clearInfectionData(),e.log("Creazione paziente con infezione completata con successo:",{transactionId:n.transactionId,patientId:n.patient?.id,infectionEventId:n.infectionEvent?.id}),n}catch(n){throw this._handleInfectionError(n,"creazione"),n}}async handleInfectionEventCreation(t,i){try{e.log(`Creazione evento infezione per paziente ${t}`),await this._validateInfectionData(i);const n=(await ee.getEventiByPaziente(t,{tipo_evento:["infezione"]})).filter(e=>!e.data_fine_evento);if(n.length>0)throw this._handleActiveInfectionConflict(n[0]),new Error("Paziente ha già un'infezione attiva");const a=await this._createInfectionEvent(t,i);return(await m()).clearInfectionData(),a}catch(n){throw this._handleInfectionError(n,"creazione evento"),n}}async forceCreateInfectionEvent(t,i){try{e.log(`Creazione forzata evento infezione per paziente ${t}`),await this._validateInfectionData(i);const n=await this._createInfectionEvent(t,i);return(await m()).clearInfectionData(),o("Nuovo evento infezione creato con successo!"),n}catch(n){e.error("Errore nella creazione forzata evento infezione:",n);const t=n instanceof Error?n.message:String(n);throw t.includes("JWT")?r("Sessione scaduta. Effettua nuovamente l'accesso."):t.includes("validation")||t.includes("valido")?r(`Dati infezione non validi: ${t}`):r(`Impossibile creare l'infezione: ${t}`),n}}async retryInfectionEventCreation(t,i,n){try{return e.log(`Retry creazione evento infezione - Transazione: ${t}, Paziente: ${i}`),await oe.retryInfectionCreation(t,i,n)}catch(a){e.error("Errore nel retry creazione evento infezione:",a);const t=a instanceof Error?a.message:String(a);throw t.includes("JWT")?r("Sessione scaduta. Effettua nuovamente l'accesso."):t.includes("timeout")||t.includes("tempo")?r("Tempo scaduto. Riprova più tardi."):r(`Impossibile completare l'operazione: ${t}`),a}}async _validateInfectionData(e){const t=await m();if(t.setInfectionData(e),!t.hasValidInfectionData()){const e=t.getValidationErrors().map(e=>e.message).join(", ");throw new Error(`Dati infezione non validi: ${e}`)}}async _createInfectionEvent(t,i){const n={paziente_id:t,tipo_evento:"infezione",data_evento:i.data_evento,agente_patogeno:i.agente_patogeno||void 0,descrizione:i.descrizione||void 0,data_fine_evento:void 0},a=await ee.createEvento(n);return e.log(`Evento infezione creato con successo: ID ${a.id}`),a}_handleActiveInfectionConflict(t){e.warn(`Paziente ha già un'infezione attiva dal ${t.data_evento}`),a(`Il paziente ha già un'infezione attiva dal ${t.data_evento}. Vuoi comunque creare un nuovo evento di infezione?`,{persistent:!0,actions:[{label:"Crea Comunque",action:"force_create_infection"},{label:"Annulla",action:"cancel_infection"}]})}_handleInfectionError(t,i){const n=t?.message||JSON.stringify(t);e.error(`Errore nella ${i} paziente con infezione:`,n),n.includes("Dati infezione non validi")?r(`Dati infezione non validi: ${n}`):n.includes("Transazione parzialmente completata")?e.warn("Transazione parzialmente completata - recovery options presentate"):n.includes("già un'infezione attiva")||(n.includes("non trovato")?r("Paziente non trovato. Verifica i dati e riprova."):n.includes("JWT")?r("Sessione scaduta. Effettua nuovamente l'accesso."):r(`Impossibile ${i}: ${n}`))}};const se=new class{async createPatientWithSurgery(t,i){try{e.log("Avvio creazione paziente con intervento chirurgico:",{patientName:`${t.nome} ${t.cognome}`,surgeryDate:i.data_evento,surgeryType:i.tipo_intervento}),await this._validateSurgeryData(i);const n=await oe.executePatientWithSurgeryTransaction(t,i),{surgery:a}=await y();return a.clearSurgeryData(),e.log("Creazione paziente con intervento completata con successo:",{transactionId:n.transactionId,patientId:n.patient?.id,surgeryEventId:n.surgeryEvent?.id}),n}catch(n){throw this._handleSurgeryError(n,"creazione paziente con intervento"),n}}async createPatientWithSurgeryAndInfection(t,i,n){try{e.log("Avvio creazione paziente con intervento e infezione:",{patientName:`${t.nome} ${t.cognome}`,surgeryDate:i.data_evento,infectionDate:n?.data_evento||i.data_infezione});const{surgery:a,infection:o}=await y();await this._validateSurgeryData(i);let r=n;!r&&a.hasAssociatedInfection()&&(r=a.prepareInfectionEventData()),r&&this._validateInfectionData(r);const s=await oe.executePatientWithSurgeryAndInfectionTransaction(t,i,r);return a.clearSurgeryData(),r&&o.clearInfectionData(),e.log("Creazione paziente con intervento e infezione completata con successo:",{transactionId:s.transactionId,patientId:s.patient?.id,surgeryEventId:s.surgeryEvent?.id,infectionEventId:s.infectionEvent?.id}),s}catch(a){throw this._handleSurgeryError(a,"creazione paziente con intervento e infezione"),a}}async _validateSurgeryData(e){const{surgery:t}=await y();if(t.setSurgeryData(e),!t.hasValidSurgeryData()){const e=t.getValidationErrors().map(e=>e.message).join(", ");throw new Error(`Dati intervento non validi: ${e}`)}}async _validateInfectionData(e){const{infection:t}=await y();if(t.setInfectionData(e),!t.hasValidInfectionData()){const e=t.getValidationErrors().map(e=>e.message).join(", ");throw new Error(`Dati infezione non validi: ${e}`)}}_handleSurgeryError(t,i){const n=t?.message||JSON.stringify(t);e.error(`Errore nella ${i}:`,n),n.includes("non validi")?r(`Dati intervento non validi: ${n}`):n.includes("Transazione parzialmente completata")?e.warn("Transazione parzialmente completata - recovery options presentate"):n.includes("JWT")?r("Sessione scaduta. Effettua nuovamente l'accesso."):r(`Impossibile ${i}: ${n}`)}},ce=["dimissione","trasferimento_interno","trasferimento_esterno","decesso"],le=["56","60"],de=["0","3","6"],ue=(e="Il codice RAD non può superare i 11 caratteri")=>R(11,e),pe=()=>M((e,t)=>"trasferimento_interno"!==t?.tipo_dimissione||!!e&&e.trim().length>0,"Il reparto di destinazione è obbligatorio per i trasferimenti interni"),he=()=>M((e,t)=>"trasferimento_esterno"!==t?.tipo_dimissione||!!e&&e.trim().length>0,"La clinica di destinazione è obbligatoria per i trasferimenti esterni"),ge=()=>M((e,t)=>"trasferimento_esterno"!==t?.tipo_dimissione||!(!e||0===e.trim().length)&&!!le.includes(e),`Il codice clinica è obbligatorio per i trasferimenti esterni. Valori ammessi: ${le.join(", ")}`),fe=()=>M((e,t)=>!["dimissione","trasferimento_esterno"].includes(t?.tipo_dimissione)||!!e&&e.trim().length>0,"Il codice dimissione è obbligatorio per il tipo selezionato"),ve=()=>M((e,t)=>!["trasferimento_interno","decesso"].includes(t?.tipo_dimissione)||!e,"Per 'trasferimento_interno' e 'decesso' il codice dimissione non deve essere valorizzato"),me=()=>M((e,t)=>{if(!e)return!0;if(!de.includes(e))return!1;const i=t?.tipo_dimissione;switch(i){case"dimissione":return["0","6"].includes(e);case"trasferimento_esterno":return"3"===e;default:return!0}},"Codice dimissione non valido per il tipo selezionato");async function _e(e){return(new I).field("nome",[L('Il campo "Nome" è obbligatorio'),A(2,"Nome troppo corto")]).field("cognome",[L('Il campo "Cognome" è obbligatorio'),A(2,"Cognome troppo corto")]).field("data_nascita",[L('Il campo "Data Nascita" è obbligatorio'),N("Data di nascita non valida"),k("La data di nascita non può essere nel futuro")]).field("data_ricovero",[L('Il campo "Data Ricovero" è obbligatorio'),N("Data di ricovero non valida"),k("La data di ricovero non può essere nel futuro")]).field("diagnosi",[L('Il campo "Diagnosi" è obbligatorio')]).field("reparto_appartenenza",[L('Il campo "Reparto Appartenenza" è obbligatorio')]).field("reparto_provenienza",[L('Il campo "Reparto Provenienza" è obbligatorio')]).field("codice_rad",[ue()],!0).field("tipo_dimissione",[x([...ce],"Tipo dimissione non valido")],!0).field("data_dimissione",[N("Data di dimissione non valida"),k("La data di dimissione non può essere nel futuro"),q(e=>e.data_ricovero,"La data di dimissione non può essere precedente alla data di ricovero")],!0).field("reparto_destinazione",[pe()]).field("clinica_destinazione",[he()]).field("codice_clinica",[ge()]).field("codice_dimissione",[fe(),ve(),me()]).field("data_infezione",[N("Data di infezione non valida"),k("La data di infezione non può essere nel futuro"),V(e=>!!e?.data_ricovero&&!!e?.data_infezione,M((e,t)=>!e||!t?.data_ricovero||new Date(e)>=new Date(t.data_ricovero),"La data di infezione non può essere precedente alla data di ricovero")),V(e=>!!e?.data_dimissione&&!!e?.data_infezione,M((e,t)=>!e||!t?.data_dimissione||new Date(e)<=new Date(t.data_dimissione),"La data di infezione non può essere successiva alla data di dimissione"))],!0).validate(e,e)}async function ye(e){return(new I).field("data_dimissione",[L('Il campo "Data Dimissione" è obbligatorio'),N("Data di dimissione non valida"),k("La data di dimissione non può essere nel futuro")]).field("tipo_dimissione",[L('Il campo "Tipo dimissione" è obbligatorio'),x([...ce],"Tipo dimissione non valido")]).field("reparto_destinazione",[pe()]).field("clinica_destinazione",[he()]).field("codice_clinica",[ge()]).field("codice_dimissione",[fe(),ve(),me()]).validate(e,e)}const ze=t;async function we(e){const t=await _e(e),i=Object.keys(t);if(i.length>0){const e=i[0];throw new U(e,t[e])}}const Ee=["data_nascita","data_ricovero","data_dimissione","data_infezione"],Ie=["tipo_dimissione","codice_dimissione"],De=e=>Object.entries(e).filter(([e,t])=>!e.startsWith("_")&&void 0!==t).reduce((e,[t,i])=>(e[t]=Ee.includes(t)?(e=>""===e||null==e?null:e instanceof Date?e.toISOString().split("T")[0]:"string"==typeof e?e:null)(i):Ie.includes(t)?(e=>{if(""===e||null==e)return null;if("string"==typeof e){const t=e.trim();return""===t?null:t}return e??null})(i):i,e),{}),be=l;const Se=new class{cache=new Map;cacheTimeout=3e5;constructor(){this.initCache()}initCache(e=this.cacheTimeout){this.cache=new Map,this.cacheTimeout=e}getCached(e){const t=this.cache.get(e);return t&&Date.now()-t.timestamp<this.cacheTimeout?t.data:null}setCache(e,t){const i={data:t,timestamp:Date.now()};this.cache.set(e,i)}deleteCache(e){this.cache.delete(e)}invalidateCache(){this.cache.clear()}async withLoading(t,n){e.log(`[PatientService] ${t}`),i.getState().setLoading(!0);try{return await n()}finally{i.getState().setLoading(!1)}}handleError(e,t={}){J.handle(e,{operation:t.operation,entity:t.entity,showNotification:!0,logError:!0})}showSuccess(e){o(e)}async getPatients(e={},t={}){try{const{page:i=0,limit:n=s,sortColumn:a,sortDirection:o}=t,r={page:i,limit:n,sortColumn:a??"data_ricovero",sortDirection:o??"desc"},{patients:c,totalCount:l}=await be.getPaginatedPatients(e,r);this.logPatientsSample(c,{page:i,limit:n,totalCount:l});const d=i;return{patients:c,totalCount:l,currentPage:d,totalPages:n>0?Math.ceil(l/n):0,hasNextPage:n>0&&(d+1)*n<l,hasPrevPage:d>0}}catch(i){throw this.handleError(i,{operation:"caricamento pazienti"}),i}}async getPatientsWithClinicalEvents(t={},i={}){try{const{page:n=0,limit:a=s,sortColumn:o,sortDirection:r}=i,c={page:n,limit:a,sortColumn:o??"data_ricovero",sortDirection:r??"desc"},{patients:l,totalCount:d}=await be.getPaginatedPatients(t,c);if(l.length>0){const t=l.map(e=>e.id),{data:i,error:n}=await ze.from("eventi_clinici").select("*").in("paziente_id",t).order("data_evento",{ascending:!1});if(n)e.warn("⚠️ Errore nel caricamento eventi clinici:",n);else{const e=i.reduce((e,t)=>(e[t.paziente_id]||(e[t.paziente_id]=[]),e[t.paziente_id].push(t),e),{});l.forEach(t=>{t.eventi_clinici=e[t.id]||[]})}}this.logPatientsSample(l,{page:n,limit:a,totalCount:d});const u=n;return{patients:l,totalCount:d,currentPage:u,totalPages:a>0?Math.ceil(d/a):0,hasNextPage:a>0&&(u+1)*a<d,hasPrevPage:u>0}}catch(n){throw this.handleError(n,{operation:"caricamento pazienti con eventi clinici"}),n}}async getPatientById(t){const i=`patient_${t}`,n=this.getCached(i);if(n)return n;try{const n=await be.getPatientById(t);return n&&(this.setCache(i,n),e.log("[PatientService.getPatientById] Received record",{id:n.id,tipo_dimissione:n.tipo_dimissione,codice_clinica:n.codice_clinica??null})),n}catch(a){throw this.handleError(a,{operation:"caricamento paziente"}),a}}async createPatient(e){return this.withLoading("Creazione paziente...",async()=>{await we(e);const{data:{user:t}}=await ze.auth.getUser();if(!t)throw new Error("Utente non autenticato");const i={...De(e),user_id:t.id,data_dimissione:null,tipo_dimissione:null,codice_dimissione:null,infetto:Boolean(e.infetto)};try{const e=await be.createPatient(i);return this.invalidateCache(),this.showSuccess("Paziente creato con successo!"),e}catch(n){throw this.handleError(n,{entity:"paziente",operation:"creazione",useDbErrorMapping:!0}),n}})}async updatePatient(e,t,i={showNotification:!0}){return this.withLoading("Aggiornamento paziente...",async()=>{try{const n=De(t),a=await be.updatePatient(e,n);return this.deleteCache(`patient_${e}`),!1!==i.showNotification&&this.showSuccess("Paziente aggiornato con successo!"),a}catch(n){throw this.handleError(n,{entity:"paziente",operation:"aggiornamento",useDbErrorMapping:!0}),n}})}async deletePatient(e){return this.withLoading("Eliminazione paziente...",async()=>{try{await be.deletePatient(e),this.deleteCache(`patient_${e}`),this.invalidateCache(),this.showSuccess("Paziente eliminato con successo!")}catch(t){throw this.handleError(t,{operation:"eliminazione"}),t}})}async dischargePatient(e,t=null){try{const i=t??(new Date).toISOString().split("T")[0];await this.updatePatient(e,{data_dimissione:i},{showNotification:!1}),this.showSuccess("Paziente dimesso con successo!")}catch(i){throw this.handleError(i,{operation:"dimissione"}),i}}async dischargePatientWithTransfer(e,t){return this.withLoading("Dimissione paziente...",async()=>{try{await async function(e){const t=await ye(e),i=Object.keys(t);if(i.length>0){const e=i[0];throw new U(e,t[e])}}(t);const i=await be.updatePatient(e,t);this.deleteCache(`patient_${e}`);return this.showSuccess(`Paziente ${"dimissione"===t.tipo_dimissione?"dimesso":"trasferito"} con successo!`),i}catch(i){throw this.handleError(i,{operation:"dimissione"}),i}})}async reactivatePatient(e){try{const t={data_dimissione:null,tipo_dimissione:null,reparto_destinazione:null,clinica_destinazione:null,codice_clinica:null,codice_dimissione:null};await this.updatePatient(e,t,{showNotification:!1}),this.showSuccess("Paziente riattivato con successo!")}catch(t){throw this.handleError(t,{operation:"riattivazione"}),t}}async searchPatients(e,t=!1,i=50){try{return await be.searchPatients(e,t,i)}catch(n){throw this.handleError(n,{operation:"ricerca pazienti"}),n}}async exportPatients(e={}){await g.exportPatients(e)}async exportPatientsJSON(e={}){await g.exportPatientsJSON(e)}async getPatientStats(){try{const e=await be.getStatsData(),t={total:e.length,active:e.filter(e=>!e.data_dimissione).length,discharged:e.filter(e=>e.data_dimissione).length,byDiagnosis:{},byDepartment:{}};return e.forEach(e=>{e.diagnosi&&(t.byDiagnosis[e.diagnosi]=(t.byDiagnosis[e.diagnosi]||0)+1),e.reparto_appartenenza&&(t.byDepartment[e.reparto_appartenenza]=(t.byDepartment[e.reparto_appartenenza]||0)+1)}),t}catch(t){throw e.error("Errore nel caricamento statistiche:",t),t}}async getTransferHistory(e){try{const t=await this.getPatientById(e);if(!t)throw new Error("Paziente non trovato");const i=[];return t.data_dimissione&&t.tipo_dimissione&&i.push({data:t.data_dimissione,tipo:t.tipo_dimissione,reparto_destinazione:t.reparto_destinazione,clinica_destinazione:t.clinica_destinazione,codice_clinica:t.codice_clinica,codice_dimissione:t.codice_dimissione}),i}catch(t){throw this.handleError(t,{operation:"caricamento cronologia trasferimenti"}),t}}async createPatientWithInfection(e,t){await we(e);const i=await re.createPatientWithInfection(e,t);return this.invalidateCache(),i}async handleInfectionEventCreation(e,t){const i=await re.handleInfectionEventCreation(e,t);return this.deleteCache(`patient_${e}`),i}async retryInfectionEventCreation(e,t,i){return re.retryInfectionEventCreation(e,t,i)}async rollbackPatientCreation(e){await oe.rollbackPatientCreation(e),this.deleteCache(`patient_${e}`),this.invalidateCache()}async forceCreateInfectionEvent(e,t){const i=await re.forceCreateInfectionEvent(e,t);return this.deleteCache(`patient_${e}`),i}async createPatientWithSurgery(e,t){await we(e);const i=await se.createPatientWithSurgery(e,t);return this.invalidateCache(),i}async createPatientWithSurgeryAndInfection(e,t,i){await we(e);const n=await se.createPatientWithSurgeryAndInfection(e,t,i);return this.invalidateCache(),n}getTransactionStats(){return oe.getTransactionStats()}getTransactionLog(e){return oe.getTransactionLog(e)}async handleTemporaryEventsCreation(e,t){return this.withLoading("Salvataggio eventi clinici...",async()=>{try{for(const i of t){const t={...i};delete t.id,delete t.isTemporary,t.paziente_id=e,await ee.createEvento(t)}this.showSuccess(`${t.length} eventi clinici salvati con successo`)}catch(i){throw this.handleError(i,{operation:"salvataggio eventi clinici"}),i}})}async createPatientWithTemporaryEvents(e,t){return this.withLoading("Creazione paziente ed eventi clinici...",async()=>{try{const i=await be.createPatient(e);for(const e of t){const t={...e};delete t.id,delete t.isTemporary,t.paziente_id=i.id,await ee.createEvento(t)}return this.showSuccess(`Paziente e ${t.length} eventi clinici creati con successo`),{patient:i,events:t,success:!0}}catch(i){throw this.handleError(i,{operation:"creazione paziente e eventi"}),i}})}logPatientsSample(t,i){try{const n=(t||[]).filter(e=>e&&"trasferimento_esterno"===e.tipo_dimissione).slice(0,5).map(e=>({id:e.id,codice_clinica:e.codice_clinica}));e.group("[patientService.getPatients] Result summary"),e.log({...i,sampleExternalTransfers:n}),e.groupEnd()}catch{}}};export{_ as a,y as b,ee as e,m as g,Se as p,T as v};
