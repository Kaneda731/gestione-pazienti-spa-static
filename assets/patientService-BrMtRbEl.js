import{j as e}from"./ui-vendor-S6RcKJ66.js";import{b as t}from"./react-vendor-Bp2pLdQf.js";import{l as i,d as n,b as a,_ as o}from"./index-CeQDf8ti.js";import{n as r,a as s,b as c}from"./notificationErrorHandler-C3L2OytF.js";const l={primary:"btn-primary",secondary:"btn-secondary",danger:"btn-danger",success:"btn-success",warning:"btn-warning",clinical:"btn-clinical","outline-primary":"btn-outline-primary","outline-secondary":"btn-outline-secondary","outline-warning":"btn-outline-warning","outline-info":"btn-outline-info",link:"btn-link"},d={sm:"btn-sm",md:"",lg:"btn-lg"},u=t.forwardRef(({children:t,className:i,type:n="button",variant:a="primary",size:o="md",loading:r=!1,icon:s,fullWidth:c=!1,disabled:u,...p},h)=>{const g=["btn",l[a],d[o],c?"w-100":"",i??""].filter(Boolean).join(" ").trim();return e.jsxs("button",{ref:h,type:n,className:g,disabled:u||r,"aria-busy":r?"true":void 0,...p,children:[r&&e.jsx("span",{className:"spinner-border spinner-border-sm me-2 align-middle",role:"status","aria-hidden":"true"}),s&&e.jsx("span",{className:"btn-icon align-middle me-2","aria-hidden":"true",children:s}),e.jsx("span",{className:"align-middle",children:t})]})});u.displayName="Button";const p=new class{cache=new Map;cacheTimeout=3e5;stats={hits:0,misses:0,entries:0,lastCleanup:Date.now()};cleanupInterval=null;constructor(e=3e5){this.cacheTimeout=e,this.startAutoCleanup()}generateCacheKey(e={},t={}){const i={filters:{paziente_search:e.paziente_search?.trim()||"",paziente_id:e.paziente_id||"",tipo_evento:e.tipo_evento||"",data_inizio:e.data_inizio||"",data_fine:e.data_fine||""},pagination:{page:t.page??0,limit:t.limit??10,sortColumn:t.sortColumn||"data_evento",sortDirection:t.sortDirection||"desc"}};return`search_${JSON.stringify(i)}`}get(e={},t={}){const n=this.generateCacheKey(e,t),a=this.cache.get(n);if(a){if(!(Date.now()-a.timestamp>this.cacheTimeout))return this.stats.hits++,i.debug(`Cache HIT: ${n.substring(0,50)}... (TTL: ${(this.cacheTimeout-(Date.now()-a.timestamp))/1e3}s remaining)`),a.result;this.cache.delete(n),i.debug(`Cache EXPIRED: ${n.substring(0,50)}...`)}return this.stats.misses++,null}set(e={},t={},n){const a=this.generateCacheKey(e,t);this.cache.set(a,{result:n,timestamp:Date.now()}),this.stats.entries=this.cache.size,i.debug(`Cache SET: ${a.substring(0,50)}... (${n.totalCount} events)`)}has(e={},t={}){return null!==this.get(e,t)}invalidatePatient(e){let t=0;for(const[i]of this.cache.entries())i.includes(`"paziente_id":"${e}"`)&&(this.cache.delete(i),t++);t>0&&(this.stats.entries=this.cache.size,i.debug(`Cache INVALIDATED: ${t} entries for patient ${e}`))}invalidateEventType(e){let t=0;for(const[i]of this.cache.entries())i.includes(`"tipo_evento":"${e}"`)&&(this.cache.delete(i),t++);t>0&&(this.stats.entries=this.cache.size,i.debug(`Cache INVALIDATED: ${t} entries for event type ${e}`))}invalidateDateRange(e,t){let n=0;for(const[i]of this.cache.entries())i.includes('"data_')&&(this.cache.delete(i),n++);n>0&&(this.stats.entries=this.cache.size,i.debug(`Cache INVALIDATED: ${n} entries for date range ${e} to ${t}`))}clear(){const e=this.cache.size;this.cache.clear(),this.stats={hits:0,misses:0,entries:0,lastCleanup:Date.now()},i.debug(`Cache CLEARED: ${e} entries removed`)}cleanup(){const e=Date.now();let t=0;for(const[i,n]of this.cache.entries())e-n.timestamp>this.cacheTimeout&&(this.cache.delete(i),t++);this.stats.entries=this.cache.size,this.stats.lastCleanup=e,t>0&&i.debug(`Cache CLEANUP: ${t} expired entries removed`)}startAutoCleanup(){this.cleanupInterval&&clearInterval(this.cleanupInterval),this.cleanupInterval=setInterval(()=>this.cleanup(),6e4)}stopAutoCleanup(){this.cleanupInterval&&(clearInterval(this.cleanupInterval),this.cleanupInterval=null)}getStats(){const e=this.stats.hits+this.stats.misses;return{...this.stats,hitRate:Number((e>0?this.stats.hits/e*100:0).toFixed(2))}}setCacheTimeout(e){this.cacheTimeout=Math.max(0,e),i.debug(`Cache timeout set to ${e}ms`)}getCacheTimeout(){return this.cacheTimeout}getCacheKeys(){return Array.from(this.cache.keys()).map(e=>e.substring(0,80)+"...")}getDebugInfo(){return{totalEntries:this.cache.size,cacheTimeout:this.cacheTimeout,stats:this.getStats(),keys:this.getCacheKeys().slice(0,10),memoryUsage:`~${(JSON.stringify(Array.from(this.cache.entries())).length/1024).toFixed(2)}KB`}}};const h=new class{rules=new Map;stats={totalInvalidations:0,selectiveInvalidations:0,fullInvalidations:0,rulesApplied:0,cacheEntriesCleared:0,lastInvalidation:0};constructor(){this.initializeDefaultRules()}initializeDefaultRules(){this.addRule({id:"intervention-events",name:"Intervention Events",description:"Invalidates cache entries related to surgical interventions",eventType:"intervento",affects:["search:*tipo_evento:intervento*","search:*:*","events-paziente_*"],dependencies:[],priority:10}),this.addRule({id:"infection-events",name:"Infection Events",description:"Invalidates cache entries related to infections",eventType:"infezione",affects:["search:*tipo_evento:infezione*","search:*:*","events-paziente_*","patient-infection-status_*"],dependencies:[],priority:10}),this.addRule({id:"patient-data-changes",name:"Patient Data Changes",description:"Invalidates all cache entries when patient data changes",eventType:"patient-update",affects:["search:*:*","events-paziente_*","patient-search_*"],dependencies:[],priority:20}),this.addRule({id:"new-event-statistics",name:"New Event Statistics",description:"Invalidates statistics cache when new events are added",eventType:"create",affects:["event-stats_*","suggested-filters_*"],dependencies:[],priority:5}),i.debug("Initialized default cache invalidation rules")}addRule(e){this.rules.set(e.id,e),i.debug(`Added cache invalidation rule: ${e.name}`)}removeRule(e){const t=this.rules.delete(e);return t&&i.debug(`Removed cache invalidation rule: ${e}`),t}getRules(){return Array.from(this.rules.values())}invalidateCache(e,t,n={}){const a=Date.now();if(this.stats.totalInvalidations++,n.forceFullInvalidation){const e=this.performFullInvalidation();return this.stats.fullInvalidations++,this.stats.lastInvalidation=Date.now(),i.debug(`Performed full cache invalidation in ${Date.now()-a}ms`),{invalidated:!0,entriesCleared:e,rulesApplied:0,strategy:"full"}}const o=this.findApplicableRules(e,t);if(0===o.length)return i.debug(`No applicable invalidation rules for event type: ${e}`),{invalidated:!1,entriesCleared:0,rulesApplied:0,strategy:"none"};o.sort((e,t)=>t.priority-e.priority);const r=new Set;let s=0;for(const i of o)i.condition&&!i.condition(t)||(i.affects.forEach(e=>{this.getCacheKeysByPattern(e,n.patientId).forEach(e=>r.add(e))}),s++,this.stats.rulesApplied++);if(0===r.size)return i.debug("No cache entries would be affected by invalidation rules"),{invalidated:!1,entriesCleared:0,rulesApplied:s,strategy:"none"};const c=this.performSelectiveInvalidation(Array.from(r));return this.stats.selectiveInvalidations++,this.stats.cacheEntriesCleared+=c,this.stats.lastInvalidation=Date.now(),i.debug(`Performed selective cache invalidation in ${Date.now()-a}ms: ${c} entries cleared, ${s} rules applied`),{invalidated:!0,entriesCleared:c,rulesApplied:s,strategy:"selective"}}findApplicableRules(e,t){const i=[];for(const n of this.rules.values())n.eventType!==e?n.dependencies.includes(e)&&i.push(n):i.push(n);return i}getCacheKeysByPattern(e,t){const i=[];if("search:*:*"===e)i.push(...p.getCacheKeys());else if(e.startsWith("search:")){const t=e.replace("search:","");i.push(...p.getCacheKeys().filter(e=>e.includes(t)))}else e.startsWith("events-paziente_")?t&&i.push(`events-paziente_${t}`):e.startsWith("patient-infection-status_")&&t&&i.push(`patient-infection-status_${t}`);return i}performSelectiveInvalidation(e){let t=0;for(const i of e)i.startsWith("search_")?(p.clear(),t++):(i.startsWith("events-paziente_")||i.startsWith("patient-infection-status_"))&&t++;return t}performFullInvalidation(){return p.clear(),1}getStats(){const e=this.stats.totalInvalidations,t=this.stats.totalInvalidations>0?this.stats.rulesApplied/this.stats.totalInvalidations:0;return{...this.stats,selectiveRate:Number((e>0?this.stats.selectiveInvalidations/e*100:0).toFixed(2)),averageRulesPerInvalidation:Number(t.toFixed(2))}}resetStats(){this.stats={totalInvalidations:0,selectiveInvalidations:0,fullInvalidations:0,rulesApplied:0,cacheEntriesCleared:0,lastInvalidation:0},i.debug("Cache invalidation statistics reset")}getDebugInfo(){return{totalRules:this.rules.size,rules:Array.from(this.rules.values()).map(e=>({id:e.id,name:e.name,eventType:e.eventType,affectsCount:e.affects.length,priority:e.priority})),stats:this.getStats()}}};const g=new class{async handle(e,t){i.error(`Error ${t}:`,e);const n={JWT:"Sessione scaduta. Effettua nuovamente l'accesso.",network:"Impossibile connettersi al server.",fetch:"Impossibile connettersi al server.",duplicate:"Questo evento esiste già.","foreign key":"Paziente non trovato.",23503:"Paziente non trovato."};for(const[i,a]of Object.entries(n))if(e.message?.includes(i))return r(a),void 0;r(`Errore ${t}: ${e.message}`)}};const f=new class{validateEvento(e){const t={};if(e.paziente_id||(t.paziente_id="Paziente obbligatorio"),e.tipo_evento||(t.tipo_evento="Tipo evento obbligatorio"),e.data_evento||(t.data_evento="Data evento obbligatoria"),e.data_evento){const i=new Date(e.data_evento),n=new Date;n.setHours(23,59,59,999),isNaN(i.getTime())?t.data_evento="Data non valida":i>n&&(t.data_evento="La data non può essere nel futuro")}return"intervento"===e.tipo_evento&&(e.tipo_intervento_id||(t.tipo_intervento="Specialistica obbligatoria per interventi")),"infezione"===e.tipo_evento&&(e.agente_patogeno_id||e.tipo_patogeno||(t.tipo_batterio="Specificare agente patogeno")),{isValid:0===Object.keys(t).length,errors:t}}};const v=new class{async createEvento(e){try{n.getState().setLoading(!0);const t=f.validateEvento(e);if(!t.isValid){const e=Object.values(t.errors).join(", ");throw new Error(e)}const i={paziente_id:e.paziente_id,tipo_evento:e.tipo_evento,data_evento:e.data_evento};"intervento"===e.tipo_evento&&(e.tipo_intervento_id&&(i.tipo_intervento_id=e.tipo_intervento_id),i.descrizione=e.descrizione_intervento||e.note||null),"infezione"===e.tipo_evento&&(e.agente_patogeno_id&&(i.agente_patogeno_id=e.agente_patogeno_id),i.descrizione=e.note||null,e.tipo_patogeno&&(i.tipo_patogeno=e.tipo_patogeno),e.data_fine_evento&&(i.data_fine_evento=e.data_fine_evento));const{data:o,error:r}=await a.from("eventi_clinici").insert([i]).select().single();if(r)throw r;return"infezione"===e.tipo_evento&&await this._updatePazienteInfezioneStatus(e.paziente_id),this.invalidateCache(),s("Evento creato con successo!"),o}catch(t){throw await g.handle(t,"creazione evento"),t}finally{n.getState().setLoading(!1)}}async updateEvento(e,t){try{n.getState().setLoading(!0);const o=f.validateEvento(t);if(!o.isValid){const e=Object.values(o.errors).join(", ");throw new Error(e)}const r={data_evento:t.data_evento};"intervento"===t.tipo_evento&&(r.descrizione=t.descrizione_intervento||t.note||null,null!=t.tipo_intervento_id&&(r.tipo_intervento_id=t.tipo_intervento_id)),"infezione"===t.tipo_evento&&(r.descrizione=t.note||null,null!=t.agente_patogeno_id&&(r.agente_patogeno_id=t.agente_patogeno_id),t.tipo_patogeno&&(r.tipo_patogeno=t.tipo_patogeno),t.data_fine_evento&&(r.data_fine_evento=t.data_fine_evento)),i.info("Updating event:",{id:e,dataToUpdate:r});const{data:c,error:l}=await a.from("eventi_clinici").update(r).eq("id",e).select().single();if(l)throw i.error("Supabase update error:",{error:l,dataToUpdate:r}),l;return"infezione"===t.tipo_evento&&await this._updatePazienteInfezioneStatus(t.paziente_id),this.invalidateCache(),s("Evento aggiornato con successo!"),c}catch(o){throw await g.handle(o,"aggiornamento evento"),o}finally{n.getState().setLoading(!1)}}async deleteEvento(e){try{n.getState().setLoading(!0);const{data:t,error:i}=await a.from("eventi_clinici").select("paziente_id, tipo_evento").eq("id",e).single();if(i&&"PGRST116"!==i.code)throw i;const{error:o}=await a.from("eventi_clinici").delete().eq("id",e);if(o)throw o;t&&"infezione"===t.tipo_evento&&await this._updatePazienteInfezioneStatus(t.paziente_id),this.invalidateCache(),s("Evento eliminato con successo!")}catch(t){throw await g.handle(t,"eliminazione evento"),t}finally{n.getState().setLoading(!1)}}async resolveInfezione(e,t){try{n.getState().setLoading(!0);const{data:i,error:o}=await a.from("eventi_clinici").select("data_evento, paziente_id").eq("id",e).eq("tipo_evento","infezione").single();if(o)throw o;const r=new Date(i.data_evento);if(new Date(t)<r)throw new Error("La data di risoluzione non può essere precedente alla data dell'infezione");const{data:c,error:l}=await a.from("eventi_clinici").update({data_fine_evento:t}).eq("id",e).select().single();if(l)throw l;return await this._updatePazienteInfezioneStatus(i.paziente_id),this.invalidateCache(),s("Infezione risolta con successo!"),c}catch(i){throw await g.handle(i,"risoluzione infezione"),i}finally{n.getState().setLoading(!1)}}invalidateCache(){p.clear()}invalidateSelectiveCache(e,t){e?h.invalidateCache(e,{},{patientId:t}):this.invalidateCache()}async _updatePazienteInfezioneStatus(e){try{const{data:t,error:n}=await a.from("eventi_clinici").select("id, data_evento").eq("paziente_id",e).eq("tipo_evento","infezione").is("data_fine_evento",null).order("data_evento",{ascending:!1}).limit(1);if(n)throw n;const o=t&&t.length>0,{error:r}=await a.from("pazienti").update({infetto:o,data_infezione:o?t[0].data_evento:null}).eq("id",e);r&&i.error("Supabase patient update error:",r)}catch(t){i.error("Error updating patient infection status:",t)}}};const m=new class{async getListaTipiIntervento(){try{const{data:e,error:t}=await a.from("tipi_intervento").select("id, nome, descrizione").eq("attivo",!0).order("nome",{ascending:!0});if(t)throw t;return e||[]}catch(e){return i.error("Error loading surgery types:",e),[]}}async getListaAgentiPatogeno(){try{const{data:e,error:t}=await a.from("agenti_patogeno").select("id, nome, descrizione").eq("attivo",!0).order("nome",{ascending:!0});if(t)throw t;return e||[]}catch(e){return i.error("Error loading pathogenic agents:",e),[]}}};const _=new class{requests=new Map;defaultTimeout=3e4;stats={total:0,duplicates:0,cancelled:0,completed:0,timedOut:0,active:0};cleanupInterval=null;constructor(e=3e4){this.defaultTimeout=e,this.startAutoCleanup()}generateRequestSignature(e,t={}){const i={method:t.method||"GET",...t.body&&{body:t.body},...t.params&&{params:t.params},...t.headers&&{headers:Object.fromEntries(Object.entries(t.headers).filter(([e])=>!e.toLowerCase().includes("auth")).sort(([e],[t])=>e.localeCompare(t)))}};return`${e}:${JSON.stringify(i)}`}async executeRequest(e,t,n={},a=this.defaultTimeout){const o=this.generateRequestSignature(e,n),r=this.requests.get(o);if(r)return this.stats.duplicates++,i.debug(`Request DUPLICATE: ${o.substring(0,50)}... (returning existing promise)`),r.promise;const s=new AbortController,c=setTimeout(()=>{s.signal.aborted||(s.abort(),this.stats.timedOut++,i.debug(`Request TIMEOUT: ${o.substring(0,50)}...`))},a),l=t(s.signal).then(e=>(this.cleanupRequest(o),this.stats.completed++,e)).catch(e=>{throw this.cleanupRequest(o),"AbortError"!==e.name&&i.error(`Request FAILED: ${o.substring(0,50)}...`,e),e});return this.requests.set(o,{controller:s,promise:l,timestamp:Date.now(),timeout:c}),this.stats.total++,this.stats.active++,i.debug(`Request STARTED: ${o.substring(0,50)}... (active: ${this.stats.active})`),l}cancelRequest(e){const t=this.requests.get(e);return!(!t||t.controller.signal.aborted)&&(t.controller.abort(),this.cleanupRequest(e),this.stats.cancelled++,i.debug(`Request CANCELLED: ${e.substring(0,50)}...`),!0)}cancelAllRequests(){let e=0;for(const[t]of this.requests.entries())this.cancelRequest(t)&&e++;return i.debug(`Cancelled ${e} active requests`),e}cancelRequestsMatching(e){let t=0;const n="string"==typeof e?new RegExp(e):e;for(const[i]of this.requests.entries())n.test(i)&&this.cancelRequest(i)&&t++;return t>0&&i.debug(`Cancelled ${t} requests matching pattern`),t}getStats(){const e=this.stats.total,t=e>0?this.stats.cancelled/e*100:0;return{...this.stats,duplicateRate:Number((e>0?this.stats.duplicates/e*100:0).toFixed(2)),cancellationRate:Number(t.toFixed(2))}}getActiveRequests(){const e=Date.now();return Array.from(this.requests.entries()).map(([t,i])=>({signature:t.substring(0,80)+"...",timestamp:i.timestamp,age:e-i.timestamp}))}cleanupRequest(e){const t=this.requests.get(e);t&&(t.timeout&&clearTimeout(t.timeout),this.requests.delete(e),this.stats.active=Math.max(0,this.stats.active-1))}cleanup(){const e=Date.now();let t=0;for(const[i,n]of this.requests.entries()){(e-n.timestamp>3e5||n.controller.signal.aborted)&&(this.cleanupRequest(i),t++)}t>0&&i.debug(`Request cleanup: ${t} old requests removed`)}startAutoCleanup(){this.cleanupInterval&&clearInterval(this.cleanupInterval),this.cleanupInterval=setInterval(()=>this.cleanup(),6e4)}stopAutoCleanup(){this.cleanupInterval&&(clearInterval(this.cleanupInterval),this.cleanupInterval=null)}resetStats(){this.stats={total:0,duplicates:0,cancelled:0,completed:0,timedOut:0,active:this.requests.size},i.debug("Request statistics reset")}getDebugInfo(){return{activeRequests:this.requests.size,stats:this.getStats(),activeRequestsList:this.getActiveRequests().slice(0,10),memoryUsage:`~${(JSON.stringify(Array.from(this.requests.entries())).length/1024).toFixed(2)}KB`}}};const y=new class{async getAllEventi(e={},t={}){const i=`getAllEventi:${JSON.stringify({filters:e,pagination:t})}`;return _.executeRequest(i,async i=>{try{n.getState().setLoading(!0);const{tipo_evento:i=[],paziente_id:o,paziente_search:r,data_inizio:s,data_fine:c,reparto:l}=e,{page:d=1,limit:u=20,sortColumn:h="data_evento",sortDirection:g="desc"}=t,f="number"==typeof u&&Number.isFinite(u)&&u>0?u:20,v="number"==typeof d&&Number.isFinite(d)&&d>0?d:1;let m=v-1;const _=p.get(e,t);if(_)return _;let y=null;if(r?.trim()&&(y=await this._getPazientiIdsForSearch(r),0===y.length))return this._emptyResult(v);const z=e=>{const t={count:"exact",head:e?.head??!1};let n=a.from("eventi_clinici").select("\n              *,\n              pazienti!inner(\n                id,\n                nome,\n                cognome,\n                codice_rad,\n                reparto_appartenenza,\n                data_dimissione\n              )\n            ",t);return o?n=n.eq("paziente_id",o):y&&(n=n.in("paziente_id",y)),i&&i.length>0&&(n=n.in("tipo_evento",i)),s&&(n=n.gte("data_evento",s)),c&&(n=n.lte("data_evento",c)),l&&(n=n.eq("pazienti.reparto_appartenenza",l)),n};let w=null;if(m>0){const{count:e,error:t}=await z({head:!0});if(t)throw t;w=e??0;const i=w>0?Math.max(0,Math.ceil(w/f)-1):0;m>i&&(m=i)}let E=z();const I=m*f,S=I+f-1;E=E.order(h,{ascending:"asc"===g}).range(I,S);const{data:D,error:b,count:$}=await E;if(b&&"PGRST116"===b.code)return this._emptyResult(m+1);if(b)throw b;const C=w??$??0,T=C>0?Math.ceil(C/f):0,P={eventi:D||[],totalCount:C,currentPage:m+1,totalPages:T,hasNextPage:C>0&&m<T-1,hasPrevPage:m>0};return p.set(e,t,P),P}catch(o){throw await g.handle(o,"loading events"),o}finally{n.getState().setLoading(!1)}},{method:"GET"},3e4)}async getEventiByPaziente(e,t={}){try{let i=a.from("eventi_clinici").select("*").eq("paziente_id",e).order("data_evento",{ascending:!1});t.tipo_evento&&t.tipo_evento.length>0&&(i=i.in("tipo_evento",t.tipo_evento));const{data:n,error:o}=await i;if(o)throw o;return n||[]}catch(i){throw await g.handle(i,"loading patient events"),i}}async searchPazienti(e,t=!0){if(!e?.trim())return[];try{const i=`%${e.trim()}%`;let n=a.from("pazienti").select("id, nome, cognome, codice_rad, reparto_appartenenza, data_dimissione").or(`nome.ilike.${i},cognome.ilike.${i},codice_rad.ilike.${i}`).order("cognome").limit(10);t&&(n=n.is("data_dimissione",null));const{data:o,error:r}=await n;if(r)throw r;return o||[]}catch(n){return i.error("Error searching patients:",n),[]}}async getGiorniPostOperatori(e,t=null){try{const{data:i,error:n}=await a.from("eventi_clinici").select("data_evento, tipo_intervento, descrizione").eq("paziente_id",e).eq("tipo_evento","intervento").order("data_evento",{ascending:!1}).limit(1);if(n)throw n;if(!i||0===i.length)return{giorni:null,ultimoIntervento:null};const o=i[0],r=t?new Date(t):new Date,s=new Date(o.data_evento),c=Math.abs(r.getTime()-s.getTime());return{giorni:Math.ceil(c/864e5),ultimoIntervento:{data:o.data_evento,tipo:o.tipo_intervento||"",descrizione:o.descrizione||void 0}}}catch(n){return i.error("Error calculating post-operative days:",n),{giorni:null,ultimoIntervento:null}}}async _getPazientiIdsForSearch(e){try{const t=`%${e.trim()}%`,{data:i,error:n}=await a.from("pazienti").select("id").or(`nome.ilike.${t},cognome.ilike.${t},codice_rad.ilike.${t}`);if(n)throw n;return i?.map(e=>e.id)||[]}catch(t){return i.error("Error searching patient IDs:",t),[]}}_emptyResult(e){return{eventi:[],totalCount:0,currentPage:e,totalPages:0,hasNextPage:!1,hasPrevPage:!1}}};const z=new class{async getEventiStats(){try{const{data:e,error:t}=await a.from("eventi_clinici").select("tipo_evento, data_evento, pazienti!inner(id)");if(t)throw t;const i=e||[],n={total:i.length,interventi:i.filter(e=>"intervento"===e.tipo_evento).length,infezioni:i.filter(e=>"infezione"===e.tipo_evento).length,ultimoMese:0},o=new Date;return o.setMonth(o.getMonth()-1),n.ultimoMese=i.filter(e=>new Date(e.data_evento)>=o).length,n}catch(e){throw i.error("Error loading event statistics:",e),e}}};const w=new class{async getAllEventi(e={},t={}){return y.getAllEventi(e,t)}async getEventiByPaziente(e,t){return y.getEventiByPaziente(e,t)}async searchPazienti(e,t){return y.searchPazienti(e,t)}async getGiorniPostOperatori(e,t){return y.getGiorniPostOperatori(e,t)}async createEvento(e){return v.createEvento(e)}async updateEvento(e,t){return v.updateEvento(e,t)}async deleteEvento(e){return v.deleteEvento(e)}async resolveInfezione(e,t){return v.resolveInfezione(e,t)}async getListaTipiIntervento(){return m.getListaTipiIntervento()}async getListaAgentiPatogeno(){return m.getListaAgentiPatogeno()}async getEventiStats(){return z.getEventiStats()}invalidateCache(){v.invalidateCache()}invalidateSelectiveCache(e,t){v.invalidateSelectiveCache(e,t)}};let E=null,I=null;async function S(){if(!E){const e=await o(()=>import("./infectionDataManager-DK5Uhw4D.js"),[]);E=e.default}return E}async function D(){if(!I){const e=await o(()=>import("./surgeryDataManager-D7d3_gaM.js"),[]);I=e.default}return I}async function b(){const[e,t]=await Promise.all([S(),D()]);return{infection:e,surgery:t}}const $=10,C=(e={})=>{let t=a.from("pazienti").select("*",{count:"exact"}).not("user_id","is",null);const{reparto:i,diagnosi:n,stato:o,search:r,infetto:s}=e;if(i&&(t=t.eq("reparto_appartenenza",i)),n&&(t=t.eq("diagnosi",n)),"attivo"===o&&(t=t.is("data_dimissione",null)),"dimesso"===o&&(t=t.not("data_dimissione","is",null)),void 0!==s&&(t=t.eq("infetto","true"===s)),r){const e=r.trim().split(/\s+/).filter(e=>e.length>0);if(1===e.length)t=t.or(`nome.ilike.%${e[0]}%,cognome.ilike.%${e[0]}%,codice_rad.ilike.%${e[0]}%`);else if(2===e.length){const[i,n]=e;t=t.or([`nome.ilike.%${i}%`,`nome.ilike.%${n}%`,`cognome.ilike.%${i}%`,`cognome.ilike.%${n}%`,`codice_rad.ilike.%${i}%`,`codice_rad.ilike.%${n}%`].join(","))}else{const i=[];e.forEach(e=>{i.push(`nome.ilike.%${e}%`,`cognome.ilike.%${e}%`,`codice_rad.ilike.%${e}%`)}),t=t.or(i.join(","))}}return t},T={getPaginatedPatients:async(e={},t={})=>{const{page:n=0,limit:a=$,sortColumn:o="data_ricovero",sortDirection:r="desc"}=t;let s=C(e);const c=n*a,l=c+a-1;s=s.order(o,{ascending:"asc"===r}).range(c,l);const{data:d,error:u,count:p}=await s;if(u)throw u;try{const e=(d||[]).filter(e=>e&&"trasferimento_esterno"===e.tipo_dimissione).slice(0,5).map(e=>({id:e.id,codice_clinica:e.codice_clinica}));i.group("[patientApi.getPaginatedPatients] Result summary"),i.log({total:d?.length||0,count:p,externalTransfersSample:e}),i.groupEnd()}catch(h){}return{patients:d||[],totalCount:p||0}},getAllPatients:async(e={})=>{const{sortColumn:t="data_ricovero",sortDirection:n="desc"}=e;let a=C(e);a=a.order(t,{ascending:"asc"===n}).limit(5e3);const{data:o,error:r}=await a;if(r)throw r;try{const e=(o||[]).filter(e=>e&&"trasferimento_esterno"===e.tipo_dimissione).slice(0,5).map(e=>({id:e.id,codice_clinica:e.codice_clinica}));i.group("[patientApi.getAllPatients] Result sample"),i.log({total:o?.length||0,externalTransfersSample:e}),i.groupEnd()}catch(s){}return o||[]},getPatientById:async e=>{const{data:t,error:n}=await a.from("pazienti").select("*").eq("id",e).single();if(n)throw n;try{i.log("[patientApi.getPatientById] Loaded",{id:t?.id,tipo_dimissione:t?.tipo_dimissione,codice_clinica:t?.codice_clinica||null})}catch(o){}return t},createPatient:async e=>{const t={...e},{id:i,...n}=t,{data:o,error:r}=await a.from("pazienti").insert(n).select("*").single();if(r)throw r;return o},updatePatient:async(e,t)=>{try{i.group("[patientApi.updatePatient] Update payload"),i.log({id:e,codice_clinica:t?.codice_clinica??null,tipo_dimissione:t?.tipo_dimissione??null}),i.groupEnd()}catch(r){}const{data:n,error:o}=await a.from("pazienti").update(t).eq("id",e).select().single();if(o)throw o;try{i.group("[patientApi.updatePatient] Update result"),i.log({id:n?.id,tipo_dimissione:n?.tipo_dimissione??null,codice_clinica:n?.codice_clinica??null}),i.groupEnd()}catch(r){}return n},deletePatient:async e=>{const{error:t}=await a.from("pazienti").delete().eq("id",e);if(t)throw t},searchPatients:async(e,t=!1,i=50)=>{const n=e.trim().split(/\s+/).filter(e=>e.length>0);let o=a.from("pazienti").select("id, nome, cognome, codice_rad, data_ricovero, diagnosi, reparto_appartenenza").not("user_id","is",null);if(1===n.length)o=o.or(`nome.ilike.%${n[0]}%,cognome.ilike.%${n[0]}%,codice_rad.ilike.%${n[0]}%`);else if(2===n.length){const[e,t]=n;o=o.or([`nome.ilike.%${e}%`,`nome.ilike.%${t}%`,`cognome.ilike.%${e}%`,`cognome.ilike.%${t}%`,`codice_rad.ilike.%${e}%`,`codice_rad.ilike.%${t}%`].join(","))}else{const e=[];n.forEach(t=>{e.push(`nome.ilike.%${t}%`,`cognome.ilike.%${t}%`,`codice_rad.ilike.%${t}%`)}),o=o.or(e.join(","))}o=o.order("cognome"),t&&(o=o.is("data_dimissione",null));const{data:r,error:s}=await o.limit(Math.max(1,Number(i)||50));if(s)throw s;return r||[]},getStatsData:async()=>{const{data:e,error:t}=await a.from("pazienti").select("data_dimissione, diagnosi, reparto_appartenenza").not("user_id","is",null);if(t)throw t;return e||[]}},P=["Nome","Cognome","Data Nascita","Data Ricovero","Data Dimissione","Diagnosi","Reparto Appartenenza","Reparto Provenienza","Livello Assistenza","Codice RAD","Infetto"];function R(e,t){if(!e)return t.nullValue||"";try{const i=new Date(e);switch(t.dateFormat){case"iso":return i.toISOString().split("T")[0];case"locale":default:return i.toLocaleDateString();case"custom":return t.customDateFormat?i.toLocaleDateString("it-IT",t.customDateFormat):i.toLocaleDateString()}}catch(i){return t.nullValue||""}}function A(e,t){if(null==e)return t.nullValue||"";switch(t.booleanFormat){case"true/false":return e?"true":"false";case"yes/no":default:return e?"Sì":"No";case"1/0":return e?"1":"0"}}const L=(e,t,i="text/plain;charset=utf-8;")=>{const n=new Blob([e],{type:i}),a=document.createElement("a");if(void 0!==a.download){const e=URL.createObjectURL(n);a.setAttribute("href",e),a.setAttribute("download",t),a.style.visibility="hidden",document.body.appendChild(a),a.click(),document.body.removeChild(a),setTimeout(()=>{URL.revokeObjectURL(e)},100)}else{const n=window.open("","_blank");n&&(n.document.write(`\n        <html>\n          <body>\n            <pre>${e}</pre>\n            <p><a href="data:${i},${encodeURIComponent(e)}" download="${t}">Download ${t}</a></p>\n          </body>\n        </html>\n      `),n.document.close())}};const N=new class{async exportPatients(e={}){try{n.getState().setLoading(!0);const t=await T.getAllPatients(e);if(this._logExportSample(t,"CSV"),!t||0===t.length)return c("Nessun dato da esportare per i filtri selezionati."),void 0;const i=((e,t={})=>{const{delimiter:i=",",headers:n=P,includeHeaders:a=!0,dateFormat:o="locale",booleanFormat:r="yes/no",nullValue:s=""}=t;return[...a?n:[],...e.map(e=>{const t=e;return[t.nome||s,t.cognome||s,R(t.data_nascita,{dateFormat:o,nullValue:s}),R(t.data_ricovero,{dateFormat:o,nullValue:s}),R(t.data_dimissione,{dateFormat:o,nullValue:s}),t.diagnosi||s,t.reparto_appartenenza||s,t.reparto_provenienza||s,t.livello_assistenza||s,t.codice_rad||s,A(t.infetto,{booleanFormat:r,nullValue:s})]})].map(e=>(Array.isArray(e)?e:[e]).map(e=>{return`"${t=String(e),t.toString().replace(/"/g,'""')}"`;var t}).join(i)).join("\n")})(t);void L(i,"esportazione_pazienti.csv","text/csv;charset=utf-8;"),s(`Esportati ${t.length} pazienti con successo!`)}catch(t){i.error("Errore nell'esportazione:",t);const e=t instanceof Error?t.message:String(t);throw e.includes("network")||e.includes("fetch")?r("Impossibile connettersi al server. Verifica la tua connessione."):e.includes("permission")||e.includes("autorizzato")?r("Non hai i permessi per esportare questi dati."):r(`Impossibile esportare i dati: ${e}`),t}finally{n.getState().setLoading(!1)}}async exportPatientsJSON(e={}){try{n.getState().setLoading(!0);const t=await T.getAllPatients(e);if(!t||0===t.length)return c("Nessun dato da esportare per i filtri selezionati."),void 0;const i=((e,t={})=>{const{pretty:i=!0,indent:n=2}=t;return JSON.stringify(e,null,i?n:0)})(t);void L(i,"esportazione_pazienti.json","application/json;charset=utf-8;"),s(`Esportati ${t.length} pazienti in JSON con successo!`)}catch(t){i.error("Errore nell'esportazione JSON:",t);const e=t instanceof Error?t.message:String(t);throw e.includes("network")||e.includes("fetch")?r("Impossibile connettersi al server. Verifica la tua connessione."):e.includes("permission")||e.includes("autorizzato")?r("Non hai i permessi per esportare questi dati."):r(`Impossibile esportare i dati in JSON: ${e}`),t}finally{n.getState().setLoading(!1)}}_logExportSample(e,t){try{const n=(e||[]).filter(e=>e&&"trasferimento_esterno"===e.tipo_dimissione).slice(0,5).map(e=>({id:e.id,codice_clinica:e.codice_clinica}));i.group(`[PatientExportService.export${t}] Export dataset sample`),i.log({total:e?.length||0,sampleExternalTransfers:n}),i.groupEnd()}catch(n){}}};const q=new class{transactionLogs;maxLogRetention;cleanupInterval;constructor(){this.transactionLogs=new Map,this.maxLogRetention=864e5,this.cleanupInterval=36e5,this.startLogCleanup()}generateTransactionId(){return`tx_${Date.now()}_${Math.random().toString(36).substr(2,9)}`}initializeTransactionLog(e,t,n={}){const a={id:e,type:t,status:"started",steps:[],initialData:this.sanitizeLogData(n),createdAt:Date.now(),completedAt:null};return this.transactionLogs.set(e,a),i.log(`Transazione ${e} inizializzata: ${t}`),a}logTransactionStep(e,t,n,a={}){const o=this.transactionLogs.get(e);if(!o)return i.error(`Tentativo di loggare step per transazione inesistente: ${e}`),void 0;const r={step:t,status:n,data:this.sanitizeLogData(a),timestamp:Date.now()};o.steps.push(r),i.log(`Transazione ${e} - Step ${t}: ${n}`)}completeTransactionLog(e,t){const n=this.transactionLogs.get(e);if(!n)return i.error(`Tentativo di completare transazione inesistente: ${e}`),void 0;n.status=t,n.completedAt=Date.now(),i.log(`Transazione ${e} completata con stato: ${t}`)}getTransactionLog(e){return this.transactionLogs.get(e)||null}getAllTransactionLogs(){return Array.from(this.transactionLogs.values())}getTransactionStats(){const e=Array.from(this.transactionLogs.values());return{total:e.length,byStatus:e.reduce((e,t)=>(e[t.status]=(e[t.status]||0)+1,e),{}),byType:e.reduce((e,t)=>(e[t.type]=(e[t.type]||0)+1,e),{}),oldestLog:e.length>0?Math.min(...e.map(e=>e.createdAt)):null,newestLog:e.length>0?Math.max(...e.map(e=>e.createdAt)):null}}sanitizeLogData(e){if(!e||"object"!=typeof e)return e;const t={...e};return["password","token","auth","secret","nome","cognome","codice_fiscale","codice_rad","telefono","email","indirizzo","indirizzo_residenza","citta","cap","note","descrizione"].forEach(e=>{t[e]&&(t[e]="[REDACTED]")}),t}startLogCleanup(){setInterval(()=>{this.cleanupOldLogs()},this.cleanupInterval)}cleanupOldLogs(){const e=Date.now();let t=0;for(const[i,n]of this.transactionLogs.entries())e-n.createdAt>this.maxLogRetention&&(this.transactionLogs.delete(i),t++);t>0&&i.log(`Cleanup log transazioni: ${t} log rimossi`)}};const x=new class{async createPatientStep(e,t=!1){try{const n={...e,infetto:t,data_infezione:null},a=await T.createPatient(n);if(!a||!a.id)throw new Error("Creazione paziente fallita: nessun ID restituito");return i.log(`Paziente creato con successo: ID ${a.id}`),a}catch(n){throw i.error("Errore nella creazione paziente:",n),new Error(`Fallimento creazione paziente: ${n?.message??String(n)}`)}}async createInfectionEventStep(e,t){try{const n={paziente_id:e,tipo_evento:"infezione",data_evento:t.data_evento,agente_patogeno_id:t.agente_patogeno_id||null,tipo_patogeno:t.tipo_patogeno||null,descrizione:t.descrizione||null,data_fine_evento:t.data_fine_evento||null},a=await w.createEvento(n);if(!a||!a.id)throw new Error("Creazione evento infezione fallita: nessun ID restituito");return i.log(`Evento infezione creato con successo: ID ${a.id}`),a}catch(n){throw i.error("Errore nella creazione evento infezione:",n),new Error(`Fallimento creazione evento infezione: ${n?.message??String(n)}`)}}async createSurgeryEventStep(e,t){try{const n={paziente_id:e,tipo_evento:"intervento",data_evento:t.data_evento,tipo_intervento_id:t.tipo_intervento_id,descrizione:t.descrizione||null,data_fine_evento:null},a=await w.createEvento(n);if(!a||!a.id)throw new Error("Creazione evento intervento fallita: nessun ID restituito");return i.log(`Evento intervento creato con successo: ID ${a.id}`),a}catch(n){throw i.error("Errore nella creazione evento intervento:",n),new Error(`Fallimento creazione evento intervento: ${n?.message??String(n)}`)}}async verifySynchronizationStep(e){try{await new Promise(e=>setTimeout(e,500));const t=await T.getPatientById(e);if(!t)throw new Error("Paziente non trovato durante verifica sincronizzazione");t.infetto||i.warn(`Paziente ${e}: flag infetto non sincronizzato correttamente`),t.data_infezione||i.warn(`Paziente ${e}: data_infezione non sincronizzata correttamente`),i.log(`Sincronizzazione verificata per paziente ${e}`)}catch(t){i.error("Errore nella verifica sincronizzazione:",t),i.warn("Continuando nonostante errore di verifica sincronizzazione")}}async rollbackPatientCreation(e){try{await T.deletePatient(e),i.log(`Rollback completato: paziente ${e} eliminato`)}catch(t){throw i.error(`Errore nel rollback paziente ${e}:`,t),new Error(`Rollback fallito: ${t?.message??String(t)}`)}}};const k=new class{async handleTransactionFailure(e,t){const n=q.getTransactionLog(e);if(!n)return i.error(`Log transazione ${e} non trovato`),void 0;q.logTransactionStep(e,"handle_failure","started",{error:t.message});const a=n.steps.filter(e=>"completed"===e.status),o=a.some(e=>"create_patient"===e.step),r=a.some(e=>"create_infection_event"===e.step);try{r&&!o?await this.handleInconsistentState(e,t):o&&!r?await this.handlePatientCreatedInfectionFailed(e,t):o?await this.handleLateFailure(e,t):await this.handleEarlyFailure(e,t),q.completeTransactionLog(e,"failed")}catch(s){i.error(`Errore durante gestione fallimento transazione ${e}:`,s),q.completeTransactionLog(e,"rollback_failed")}}async handlePatientCreatedInfectionFailed(e,t){const i=q.getTransactionLog(e).steps.find(e=>"create_patient"===e.step&&"completed"===e.status);if(!i||!i.data||!i.data.patientId)throw new Error("ID paziente non trovato nel log della transazione");const n=i.data.patientId;throw q.logTransactionStep(e,"recovery_options_presented","completed",{type:"error",title:"Creazione Incompleta",message:`Paziente creato con successo, ma creazione evento infezione fallita. \n                Paziente ID: ${n}\n                Errore: ${t.message}`,actions:[{label:"Riprova Evento Infezione",action:"retry_infection",data:{transactionId:e,patientId:n}},{label:"Completa Manualmente",action:"complete_manually",data:{patientId:n}},{label:"Elimina Paziente",action:"rollback_patient",data:{patientId:n},variant:"danger"}]}),r("Paziente creato ma evento infezione fallito. Controlla la sezione notifiche per le opzioni di recovery.",{persistent:!0}),new Error(`Transazione parzialmente completata. Paziente ID: ${n}. ${t.message}`)}async handleEarlyFailure(e,t){q.logTransactionStep(e,"early_failure_handled","completed",{message:"Nessun rollback necessario - nessuna risorsa creata"}),r(`Errore nella creazione: ${t.message}`)}async handleLateFailure(e,t){q.logTransactionStep(e,"late_failure_handled","completed",{message:"Transazione sostanzialmente completata nonostante errore finale",originalError:t.message}),c(`Paziente e evento infezione creati, ma si è verificato un errore nella verifica finale: ${t.message}`)}async handleInconsistentState(e,t){q.logTransactionStep(e,"inconsistent_state_detected","completed",{message:"Stato inconsistente rilevato - richiede intervento manuale",originalError:t.message}),r(`Stato inconsistente rilevato. Contattare l'amministratore. Transazione ID: ${e}`,{persistent:!0})}async retryInfectionCreation(e,t,n){const a=`${e}_retry_${Date.now()}`;try{q.initializeTransactionLog(a,"retry_infection_creation",{originalTransactionId:e,patientId:t,infectionData:n});const i=await x.createInfectionEventStep(t,n);return await x.verifySynchronizationStep(t),q.completeTransactionLog(a,"completed"),s("Evento infezione creato con successo!"),i}catch(o){throw q.completeTransactionLog(a,"failed"),i.error("Errore nel retry creazione infezione:",o),o}}};const O=new class{async validatePatientData(e){if(!e||"object"!=typeof e)throw new Error("Dati paziente non validi");const t=["nome","cognome","data_ricovero"];for(const i of t)if(!e[i]||""===e[i].toString().trim())throw new Error(`Campo paziente obbligatorio mancante: ${i}`)}async validateInfectionData(e){if(!e||"object"!=typeof e)throw new Error("Dati infezione non validi");const t=["data_evento"];for(const i of t)if(!e[i]||""===e[i].toString().trim())throw new Error(`Campo infezione obbligatorio mancante: ${i}`);await this.validateEventDate(e.data_evento,"evento infezione")}async validateSurgeryData(e){if(!e||"object"!=typeof e)throw new Error("Dati intervento non validi");const t=["data_evento","tipo_intervento"];for(const i of t)if(!e[i]||""===e[i].toString().trim())throw new Error(`Campo intervento obbligatorio mancante: ${i}`);if(await this.validateEventDate(e.data_evento,"evento intervento"),e.has_infection&&e.data_infezione){const t=new Date(e.data_infezione),i=new Date(e.data_evento);if(isNaN(t.getTime()))throw new Error("Data infezione associata non valida");if(t<i)throw new Error("La data dell'infezione non può essere precedente all'intervento")}}async validateEventDate(e,t){const i=new Date(e),n=new Date;if(n.setHours(23,59,59,999),isNaN(i.getTime()))throw new Error(`Data ${t} non valida`);if(i>n)throw new Error(`La data dell'${t} non può essere nel futuro`)}async validateTransactionData(e,t,n){switch(await this.validatePatientData(e),n){case"infection":await this.validateInfectionData(t);break;case"surgery":await this.validateSurgeryData(t);break;default:throw new Error(`Tipo evento non supportato: ${n}`)}i.log(`Validazione dati transazione ${n} completata con successo`)}};const F=new class{async executeTransaction(e){const t=q.generateTransactionId();try{q.initializeTransactionLog(t,e.type,e.data),n.getState().setLoading(!0),await this.validateTransaction(t,e);const i=await this.createPatient(t,e),a=await this.createEvents(t,e,i.id);return await this.verifyTransaction(t,i.id),q.completeTransactionLog(t,"completed"),s(e.successMessage),this.formatResult(t,i,a)}catch(a){throw i.error(`Errore nella transazione ${t}:`,a),await k.handleTransactionFailure(t,a),a}finally{n.getState().setLoading(!1)}}async validateTransaction(e,t){q.logTransactionStep(e,"validation","started"),await O.validatePatientData(t.data.patientData);for(const i of t.events)await O.validateTransactionData(t.data.patientData,t.data[i.dataKey],i.type);q.logTransactionStep(e,"validation","completed",{message:"Dati validati con successo"})}async createPatient(e,t){q.logTransactionStep(e,"create_patient","started");const i=t.events.some(e=>"infection"===e.type),n=await x.createPatientStep(t.data.patientData,i);return q.logTransactionStep(e,"create_patient","completed",{patientId:n.id}),n}async createEvents(e,t,i){const n={};for(const a of t.events){const o=`create_${a.type}_event`;let r;switch(q.logTransactionStep(e,o,"started"),a.type){case"infection":r=await x.createInfectionEventStep(i,t.data[a.dataKey]);break;case"surgery":r=await x.createSurgeryEventStep(i,t.data[a.dataKey]);break;default:throw new Error(`Tipo evento non supportato: ${a.type}`)}n[a.resultKey]=r,q.logTransactionStep(e,o,"completed",{eventId:r.id})}if(t.data.surgeryData?.has_infection&&t.data.surgeryData?.data_infezione){const a="create_infection_event";q.logTransactionStep(e,a,"started");const o={data_evento:t.data.surgeryData.data_infezione,agente_patogeno:t.data.surgeryData.agente_patogeno,descrizione:t.data.surgeryData.descrizione_infezione},r=await x.createInfectionEventStep(i,o);n.infectionEvent=r,q.logTransactionStep(e,a,"completed",{eventId:r.id})}return n}async verifyTransaction(e,t){q.logTransactionStep(e,"verify_synchronization","started"),await x.verifySynchronizationStep(t),q.logTransactionStep(e,"verify_synchronization","completed")}formatResult(e,t,i){return{success:!0,transactionId:e,patient:t,...i,message:"Transazione completata con successo"}}};const j=new class{async executePatientWithSurgeryTransaction(e,t){return F.executeTransaction({type:"patient_with_surgery",loadingMessage:"Creazione paziente e evento intervento...",successMessage:"Paziente e evento intervento creati con successo!",data:{patientData:e,surgeryData:t},events:[{type:"surgery",dataKey:"surgeryData",resultKey:"surgeryEvent"}]})}async executePatientWithSurgeryAndInfectionTransaction(e,t,i){return F.executeTransaction({type:"patient_with_surgery_and_infection",loadingMessage:"Creazione paziente, intervento e infezione...",successMessage:"Paziente, intervento e infezione creati con successo!",data:{patientData:e,surgeryData:t,infectionData:i},events:[{type:"surgery",dataKey:"surgeryData",resultKey:"surgeryEvent"},{type:"infection",dataKey:"infectionData",resultKey:"infectionEvent"}]})}async executePatientWithInfectionTransaction(e,t){return F.executeTransaction({type:"patient_with_infection",loadingMessage:"Creazione paziente e evento infezione...",successMessage:"Paziente e evento infezione creati con successo!",data:{patientData:e,infectionData:t},events:[{type:"infection",dataKey:"infectionData",resultKey:"infectionEvent"}]})}async rollbackPatientCreation(e){await x.rollbackPatientCreation(e)}async retryInfectionCreation(e,t,i){return k.retryInfectionCreation(e,t,i)}getTransactionLog(e){return q.getTransactionLog(e)}getAllTransactionLogs(){return q.getAllTransactionLogs()}getTransactionStats(){return q.getTransactionStats()}};const M=new class{async createPatientWithInfection(e,t){try{i.log("Avvio creazione paziente con infezione:",{patientName:`${e.nome} ${e.cognome}`,infectionDate:t.data_evento}),await this._validateInfectionData(t);const n=await j.executePatientWithInfectionTransaction(e,t);return(await S()).clearInfectionData(),i.log("Creazione paziente con infezione completata con successo:",{transactionId:n.transactionId,patientId:n.patient?.id,infectionEventId:n.infectionEvent?.id}),n}catch(n){throw this._handleInfectionError(n,"creazione"),n}}async handleInfectionEventCreation(e,t){try{i.log(`Creazione evento infezione per paziente ${e}`),await this._validateInfectionData(t);const n=(await w.getEventiByPaziente(e,{tipo_evento:["infezione"]})).filter(e=>!e.data_fine_evento);if(n.length>0)throw this._handleActiveInfectionConflict(n[0]),new Error("Paziente ha già un'infezione attiva");const a=await this._createInfectionEvent(e,t);return(await S()).clearInfectionData(),a}catch(n){throw this._handleInfectionError(n,"creazione evento"),n}}async forceCreateInfectionEvent(e,t){try{i.log(`Creazione forzata evento infezione per paziente ${e}`),await this._validateInfectionData(t);const n=await this._createInfectionEvent(e,t);return(await S()).clearInfectionData(),s("Nuovo evento infezione creato con successo!"),n}catch(n){i.error("Errore nella creazione forzata evento infezione:",n);const e=n instanceof Error?n.message:String(n);throw e.includes("JWT")?r("Sessione scaduta. Effettua nuovamente l'accesso."):e.includes("validation")||e.includes("valido")?r(`Dati infezione non validi: ${e}`):r(`Impossibile creare l'infezione: ${e}`),n}}async retryInfectionEventCreation(e,t,n){try{return i.log(`Retry creazione evento infezione - Transazione: ${e}, Paziente: ${t}`),await j.retryInfectionCreation(e,t,n)}catch(a){i.error("Errore nel retry creazione evento infezione:",a);const e=a instanceof Error?a.message:String(a);throw e.includes("JWT")?r("Sessione scaduta. Effettua nuovamente l'accesso."):e.includes("timeout")||e.includes("tempo")?r("Tempo scaduto. Riprova più tardi."):r(`Impossibile completare l'operazione: ${e}`),a}}async _validateInfectionData(e){const t=await S();if(t.setInfectionData(e),!t.hasValidInfectionData()){const e=t.getValidationErrors().map(e=>e.message).join(", ");throw new Error(`Dati infezione non validi: ${e}`)}}async _createInfectionEvent(e,t){const n={paziente_id:e,tipo_evento:"infezione",data_evento:t.data_evento,agente_patogeno:t.agente_patogeno||void 0,descrizione:t.descrizione||void 0,data_fine_evento:void 0},a=await w.createEvento(n);return i.log(`Evento infezione creato con successo: ID ${a.id}`),a}_handleActiveInfectionConflict(e){i.warn(`Paziente ha già un'infezione attiva dal ${e.data_evento}`),c(`Il paziente ha già un'infezione attiva dal ${e.data_evento}. Vuoi comunque creare un nuovo evento di infezione?`,{persistent:!0,actions:[{label:"Crea Comunque",action:"force_create_infection"},{label:"Annulla",action:"cancel_infection"}]})}_handleInfectionError(e,t){const n=e?.message||JSON.stringify(e);i.error(`Errore nella ${t} paziente con infezione:`,n),n.includes("Dati infezione non validi")?r(`Dati infezione non validi: ${n}`):n.includes("Transazione parzialmente completata")?i.warn("Transazione parzialmente completata - recovery options presentate"):n.includes("già un'infezione attiva")||(n.includes("non trovato")?r("Paziente non trovato. Verifica i dati e riprova."):n.includes("JWT")?r("Sessione scaduta. Effettua nuovamente l'accesso."):r(`Impossibile ${t}: ${n}`))}};const V=new class{async createPatientWithSurgery(e,t){try{i.log("Avvio creazione paziente con intervento chirurgico:",{patientName:`${e.nome} ${e.cognome}`,surgeryDate:t.data_evento,surgeryType:t.tipo_intervento}),await this._validateSurgeryData(t);const n=await j.executePatientWithSurgeryTransaction(e,t),{surgery:a}=await b();return a.clearSurgeryData(),i.log("Creazione paziente con intervento completata con successo:",{transactionId:n.transactionId,patientId:n.patient?.id,surgeryEventId:n.surgeryEvent?.id}),n}catch(n){throw this._handleSurgeryError(n,"creazione paziente con intervento"),n}}async createPatientWithSurgeryAndInfection(e,t,n){try{i.log("Avvio creazione paziente con intervento e infezione:",{patientName:`${e.nome} ${e.cognome}`,surgeryDate:t.data_evento,infectionDate:n?.data_evento||t.data_infezione});const{surgery:a,infection:o}=await b();await this._validateSurgeryData(t);let r=n;!r&&a.hasAssociatedInfection()&&(r=a.prepareInfectionEventData()),r&&this._validateInfectionData(r);const s=await j.executePatientWithSurgeryAndInfectionTransaction(e,t,r);return a.clearSurgeryData(),r&&o.clearInfectionData(),i.log("Creazione paziente con intervento e infezione completata con successo:",{transactionId:s.transactionId,patientId:s.patient?.id,surgeryEventId:s.surgeryEvent?.id,infectionEventId:s.infectionEvent?.id}),s}catch(a){throw this._handleSurgeryError(a,"creazione paziente con intervento e infezione"),a}}async _validateSurgeryData(e){const{surgery:t}=await b();if(t.setSurgeryData(e),!t.hasValidSurgeryData()){const e=t.getValidationErrors().map(e=>e.message).join(", ");throw new Error(`Dati intervento non validi: ${e}`)}}async _validateInfectionData(e){const{infection:t}=await b();if(t.setInfectionData(e),!t.hasValidInfectionData()){const e=t.getValidationErrors().map(e=>e.message).join(", ");throw new Error(`Dati infezione non validi: ${e}`)}}_handleSurgeryError(e,t){const n=e?.message||JSON.stringify(e);i.error(`Errore nella ${t}:`,n),n.includes("non validi")?r(`Dati intervento non validi: ${n}`):n.includes("Transazione parzialmente completata")?i.warn("Transazione parzialmente completata - recovery options presentate"):n.includes("JWT")?r("Sessione scaduta. Effettua nuovamente l'accesso."):r(`Impossibile ${t}: ${n}`)}};class W extends Error{field;constructor(e,t){super(t),this.field=e,this.name="ValidationError"}}var K=(e=>(e.CLINIC_56="56",e.CLINIC_60="60",e))(K||{}),B=(e=>(e.ORDINARIA="0",e.TRASFERIMENTO="3",e.PROTETTA="6",e))(B||{}),U=(e=>(e.DIMISSIONE="dimissione",e.TRASFERIMENTO_INTERNO="trasferimento_interno",e.TRASFERIMENTO_ESTERNO="trasferimento_esterno",e.DECESSO="decesso",e))(U||{});const J={nome:"Nome",cognome:"Cognome",data_nascita:"Data Nascita",data_ricovero:"Data Ricovero",diagnosi:"Diagnosi",reparto_appartenenza:"Reparto Appartenenza",reparto_provenienza:"Reparto Provenienza",data_dimissione:"Data Dimissione",diagnosi_secondarie:"Diagnosi Secondarie",livello_assistenza:"Livello di assistenza",codice_rad:"Codice RAD",tipo_dimissione:"Tipo dimissione",reparto_destinazione:"Reparto destinazione",clinica_destinazione:"Clinica destinazione",codice_clinica:"Codice clinica",codice_dimissione:"Codice dimissione",data_infezione:"Data infezione"},G=["nome","cognome","data_nascita","data_ricovero","diagnosi","reparto_appartenenza","reparto_provenienza"],H=["data_dimissione","tipo_dimissione"],Q=Object.values(U),X=Object.values(K),Y=Object.values(B);function Z(e){return null!=e&&("string"!=typeof e||e.trim().length>0)}function ee(e){return J[e]||e}function te(e){return e.join(", ")}const ie={isInFuture(e){const t="string"==typeof e?new Date(e):e,i=new Date;return i.setHours(23,59,59,999),t>i},isBefore:(e,t)=>("string"==typeof e?new Date(e):e)<("string"==typeof t?new Date(t):t),isAfter:(e,t)=>("string"==typeof e?new Date(e):e)>("string"==typeof t?new Date(t):t),validateRange(e,t,i){if(e&&t&&this.isAfter(t,e))throw new W(i.end,`${ee(i.end)} non può essere precedente a ${ee(i.start)}`)},validateNotFuture(e,t){if(e&&this.isInFuture(e))throw new W(t,`${ee(t)} non può essere nel futuro`)}},ne={validateInternalTransfer(e){if(!Z(e.reparto_destinazione))throw new W("reparto_destinazione","Il reparto di destinazione è obbligatorio per i trasferimenti interni")},validateExternalTransfer(e){if(!Z(e.clinica_destinazione))throw new W("clinica_destinazione","La clinica di destinazione è obbligatoria per i trasferimenti esterni");if(!Z(e.codice_clinica))throw new W("codice_clinica","Il codice clinica è obbligatorio per i trasferimenti esterni");const t=String(e.codice_clinica);if(!X.includes(t))throw new W("codice_clinica",`Codice clinica non valido. Valori ammessi: ${te(X)}`)},validateDischargeCode(e,t){if(!Z(t))return;const i=String(t);if(!Y.includes(i))throw new W("codice_dimissione",`Codice dimissione non valido. Valori ammessi: ${te(Y)}`);switch(e){case"dimissione":if(!["0","6"].includes(i))throw new W("codice_dimissione","Per 'dimissione' sono ammessi solo i codici 0 (ordinaria) o 6 (protetta)");break;case"trasferimento_esterno":if("3"!==i)throw new W("codice_dimissione","Per 'trasferimento_esterno' è ammesso solo il codice 3")}},validateDischargeCodeRequired(e,t){const i=["dimissione","trasferimento_esterno"].includes(e),n=["trasferimento_interno","decesso"].includes(e);if(i&&!Z(t))throw new W("codice_dimissione","Il codice dimissione è obbligatorio per il tipo selezionato");if(n&&Z(t))throw new W("codice_dimissione",`Per '${e}' il codice dimissione non deve essere valorizzato`)}};function ae(e){for(const t of G)if(!Z(e[t]))throw new W(t,`Il campo "${ee(t)}" è obbligatorio.`);!function(e){if(e.data_nascita){const t="string"==typeof e.data_nascita?e.data_nascita:e.data_nascita.toISOString();ie.validateNotFuture(t,"data_nascita")}if(e.data_ricovero){const t="string"==typeof e.data_ricovero?e.data_ricovero:e.data_ricovero.toISOString();ie.validateNotFuture(t,"data_ricovero")}if(e.data_dimissione&&e.data_ricovero){const t="string"==typeof e.data_ricovero?e.data_ricovero:e.data_ricovero.toISOString(),i="string"==typeof e.data_dimissione?e.data_dimissione:e.data_dimissione.toISOString();ie.validateRange(t,i,{start:"data_ricovero",end:"data_dimissione"})}if(e.data_infezione){const t="string"==typeof e.data_infezione?e.data_infezione:e.data_infezione.toISOString();if(ie.validateNotFuture(t,"data_infezione"),e.data_ricovero){const i="string"==typeof e.data_ricovero?e.data_ricovero:e.data_ricovero.toISOString();ie.validateRange(i,t,{start:"data_ricovero",end:"data_infezione"})}if(e.data_dimissione){const i="string"==typeof e.data_dimissione?e.data_dimissione:e.data_dimissione.toISOString();ie.validateRange(t,i,{start:"data_infezione",end:"data_dimissione"})}}}(e),function(e){if(!e)return;if(e.length>11)throw new W("codice_rad","Il codice RAD non può superare i 11 caratteri")}(e.codice_rad),function(e){const t=e.tipo_dimissione;if(!t)return;if(!Q.includes(t))throw new W("tipo_dimissione",`Tipo dimissione non valido. Valori ammessi: ${te(Q)}`);"trasferimento_interno"===t?ne.validateInternalTransfer(e):"trasferimento_esterno"===t&&ne.validateExternalTransfer(e);ne.validateDischargeCodeRequired(t,e.codice_dimissione),Z(e.codice_dimissione)&&ne.validateDischargeCode(t,e.codice_dimissione)}(e)}function oe(e){for(const t of H)if(!Z(e[t]))throw new W(t,`Il campo "${ee(t)}" è obbligatorio.`);if(!Q.includes(e.tipo_dimissione))throw new W("tipo_dimissione",`Tipo dimissione non valido. Valori ammessi: ${te(Q)}`);!function(e){if(e.data_dimissione){ie.validateNotFuture(e.data_dimissione,"data_dimissione")}}(e),function(e){const t=e.tipo_dimissione;"trasferimento_interno"===t?ne.validateInternalTransfer(e):"trasferimento_esterno"===t&&ne.validateExternalTransfer(e);ne.validateDischargeCodeRequired(t,e.codice_dimissione),Z(e.codice_dimissione)&&ne.validateDischargeCode(t,e.codice_dimissione)}(e)}const re={nome:"Nome",cognome:"Cognome",codice_rad:"Codice RAD",data_ricovero:"Data Ricovero",reparto_appartenenza:"Reparto Appartenenza",reparto_provenienza:"Reparto Provenienza",diagnosi:"Diagnosi",user_id:"Utente"};function se(e,t={}){const i="string"==typeof e?e:e?.message||"",n="object"==typeof e&&e&&"details"in e?e.details:"",a="object"==typeof e&&e&&"code"in e?e.code:void 0,{entity:o="record",operation:r}=t,s=()=>{const e=[/column\s+'([^']+)'/i,/"([^"]+)"\s+column/i,/Key\s*\(([^)]+)\)/i,/column\s+"([^"]+)"/i];for(const t of e){const e=t.exec(i)||(n?t.exec(n):null);if(e&&e[1])return e[1]}};if("23502"===a||/violates not-null constraint/i.test(i)||/null value in column/i.test(i)){const e=s();if("user_id"===e)return"Utente non autenticato. Effettua nuovamente l'accesso e riprova.";if(!e)return"Compila tutti i campi obbligatori.";const t=re[e]||function(e){return e?e.split("_").filter(Boolean).map(e=>e.charAt(0).toUpperCase()+e.slice(1)).join(" "):""}(e);return`Il campo "${c=t,c?c.charAt(0).toUpperCase()+c.slice(1):c}" è obbligatorio.`}var c;if("23505"===a||/duplicate key value violates unique constraint/i.test(i))return/codice_rad/i.test(i)?`Esiste già un ${o} con lo stesso Codice RAD.`:"Alcuni valori devono essere unici: verifica i dati inseriti.";if("23503"===a||/violates foreign key constraint/i.test(i)){const e=s();return`Valore non valido per ${e&&re[e]?re[e]:"alcuni campi"}. Seleziona un'opzione corretta e riprova.`}if("23514"===a||/violates check constraint/i.test(i))return"Alcuni dati non rispettano i vincoli richiesti. Verifica i campi e riprova.";if("PGRST301"===a||/JWT|auth|unauth/i.test(i))return"Sessione scaduta o non valida. Effettua l'accesso e riprova.";return`Si è verificato un errore durante il ${r||"salvataggio"} del ${o}. Verifica i campi e riprova.`}const ce=a,le=["data_nascita","data_ricovero","data_dimissione","data_infezione"],de=["tipo_dimissione","codice_dimissione"],ue=e=>Object.entries(e).filter(([e,t])=>!e.startsWith("_")&&void 0!==t).reduce((e,[t,i])=>(e[t]=le.includes(t)?(e=>""===e||null==e?null:e instanceof Date?e.toISOString().split("T")[0]:"string"==typeof e?e:null)(i):de.includes(t)?(e=>{if(""===e||null==e)return null;if("string"==typeof e){const t=e.trim();return""===t?null:t}return e??null})(i):i,e),{}),pe=T;const he=new class{cache=new Map;cacheTimeout=3e5;constructor(){this.initCache()}initCache(e=this.cacheTimeout){this.cache=new Map,this.cacheTimeout=e}getCached(e){const t=this.cache.get(e);return t&&Date.now()-t.timestamp<this.cacheTimeout?t.data:null}setCache(e,t){const i={data:t,timestamp:Date.now()};this.cache.set(e,i)}deleteCache(e){this.cache.delete(e)}invalidateCache(){this.cache.clear()}async withLoading(e,t){i.log(`[PatientService] ${e}`),n.getState().setLoading(!0);try{return await t()}finally{n.getState().setLoading(!1)}}handleError(e,t={}){const n=t.operation??"operazione";i.error(`Errore in ${n}:`,e);const a=e instanceof Error?e.message:String(e);if(t.useDbErrorMapping){const i=se(e,t);r(i)}else r(`Errore ${n}: ${a}`)}showSuccess(e){s(e)}async getPatients(e={},t={}){try{const{page:i=0,limit:n=$,sortColumn:a,sortDirection:o}=t,r={page:i,limit:n,sortColumn:a??"data_ricovero",sortDirection:o??"desc"},{patients:s,totalCount:c}=await pe.getPaginatedPatients(e,r);this.logPatientsSample(s,{page:i,limit:n,totalCount:c});const l=i;return{patients:s,totalCount:c,currentPage:l,totalPages:n>0?Math.ceil(c/n):0,hasNextPage:n>0&&(l+1)*n<c,hasPrevPage:l>0}}catch(i){throw this.handleError(i,{operation:"caricamento pazienti"}),i}}async getPatientsWithClinicalEvents(e={},t={}){try{const{page:n=0,limit:a=$,sortColumn:o,sortDirection:r}=t,s={page:n,limit:a,sortColumn:o??"data_ricovero",sortDirection:r??"desc"},{patients:c,totalCount:l}=await pe.getPaginatedPatients(e,s);if(c.length>0){const e=c.map(e=>e.id),{data:t,error:n}=await ce.from("eventi_clinici").select("*").in("paziente_id",e).order("data_evento",{ascending:!1});if(n)i.warn("⚠️ Errore nel caricamento eventi clinici:",n);else{const e=t.reduce((e,t)=>(e[t.paziente_id]||(e[t.paziente_id]=[]),e[t.paziente_id].push(t),e),{});c.forEach(t=>{t.eventi_clinici=e[t.id]||[]})}}this.logPatientsSample(c,{page:n,limit:a,totalCount:l});const d=n;return{patients:c,totalCount:l,currentPage:d,totalPages:a>0?Math.ceil(l/a):0,hasNextPage:a>0&&(d+1)*a<l,hasPrevPage:d>0}}catch(n){throw this.handleError(n,{operation:"caricamento pazienti con eventi clinici"}),n}}async getPatientById(e){const t=`patient_${e}`,n=this.getCached(t);if(n)return n;try{const n=await pe.getPatientById(e);return n&&(this.setCache(t,n),i.log("[PatientService.getPatientById] Received record",{id:n.id,tipo_dimissione:n.tipo_dimissione,codice_clinica:n.codice_clinica??null})),n}catch(a){throw this.handleError(a,{operation:"caricamento paziente"}),a}}async createPatient(e){return this.withLoading("Creazione paziente...",async()=>{ae(e);const{data:{user:t}}=await ce.auth.getUser();if(!t)throw new Error("Utente non autenticato");const i={...ue(e),user_id:t.id,data_dimissione:null,tipo_dimissione:null,codice_dimissione:null,infetto:Boolean(e.infetto)};try{const e=await pe.createPatient(i);return this.invalidateCache(),this.showSuccess("Paziente creato con successo!"),e}catch(n){throw this.handleError(n,{entity:"paziente",operation:"creazione",useDbErrorMapping:!0}),n}})}async updatePatient(e,t,i={showNotification:!0}){return this.withLoading("Aggiornamento paziente...",async()=>{try{const n=ue(t),a=await pe.updatePatient(e,n);return this.deleteCache(`patient_${e}`),!1!==i.showNotification&&this.showSuccess("Paziente aggiornato con successo!"),a}catch(n){throw this.handleError(n,{entity:"paziente",operation:"aggiornamento",useDbErrorMapping:!0}),n}})}async deletePatient(e){return this.withLoading("Eliminazione paziente...",async()=>{try{await pe.deletePatient(e),this.deleteCache(`patient_${e}`),this.invalidateCache(),this.showSuccess("Paziente eliminato con successo!")}catch(t){throw this.handleError(t,{operation:"eliminazione"}),t}})}async dischargePatient(e,t=null){try{const i=t??(new Date).toISOString().split("T")[0];await this.updatePatient(e,{data_dimissione:i},{showNotification:!1}),this.showSuccess("Paziente dimesso con successo!")}catch(i){throw this.handleError(i,{operation:"dimissione"}),i}}async dischargePatientWithTransfer(e,t){return this.withLoading("Dimissione paziente...",async()=>{try{oe(t);const i=await pe.updatePatient(e,t);this.deleteCache(`patient_${e}`);return this.showSuccess(`Paziente ${"dimissione"===t.tipo_dimissione?"dimesso":"trasferito"} con successo!`),i}catch(i){throw this.handleError(i,{operation:"dimissione"}),i}})}async reactivatePatient(e){try{const t={data_dimissione:null,tipo_dimissione:null,reparto_destinazione:null,clinica_destinazione:null,codice_clinica:null,codice_dimissione:null};await this.updatePatient(e,t,{showNotification:!1}),this.showSuccess("Paziente riattivato con successo!")}catch(t){throw this.handleError(t,{operation:"riattivazione"}),t}}async searchPatients(e,t=!1,i=50){try{return await pe.searchPatients(e,t,i)}catch(n){throw this.handleError(n,{operation:"ricerca pazienti"}),n}}async exportPatients(e={}){await N.exportPatients(e)}async exportPatientsJSON(e={}){await N.exportPatientsJSON(e)}async getPatientStats(){try{const e=await pe.getStatsData(),t={total:e.length,active:e.filter(e=>!e.data_dimissione).length,discharged:e.filter(e=>e.data_dimissione).length,byDiagnosis:{},byDepartment:{}};return e.forEach(e=>{e.diagnosi&&(t.byDiagnosis[e.diagnosi]=(t.byDiagnosis[e.diagnosi]||0)+1),e.reparto_appartenenza&&(t.byDepartment[e.reparto_appartenenza]=(t.byDepartment[e.reparto_appartenenza]||0)+1)}),t}catch(e){throw i.error("Errore nel caricamento statistiche:",e),e}}async getTransferHistory(e){try{const t=await this.getPatientById(e);if(!t)throw new Error("Paziente non trovato");const i=[];return t.data_dimissione&&t.tipo_dimissione&&i.push({data:t.data_dimissione,tipo:t.tipo_dimissione,reparto_destinazione:t.reparto_destinazione,clinica_destinazione:t.clinica_destinazione,codice_clinica:t.codice_clinica,codice_dimissione:t.codice_dimissione}),i}catch(t){throw this.handleError(t,{operation:"caricamento cronologia trasferimenti"}),t}}async createPatientWithInfection(e,t){ae(e);const i=await M.createPatientWithInfection(e,t);return this.invalidateCache(),i}async handleInfectionEventCreation(e,t){const i=await M.handleInfectionEventCreation(e,t);return this.deleteCache(`patient_${e}`),i}async retryInfectionEventCreation(e,t,i){return M.retryInfectionEventCreation(e,t,i)}async rollbackPatientCreation(e){await j.rollbackPatientCreation(e),this.deleteCache(`patient_${e}`),this.invalidateCache()}async forceCreateInfectionEvent(e,t){const i=await M.forceCreateInfectionEvent(e,t);return this.deleteCache(`patient_${e}`),i}async createPatientWithSurgery(e,t){ae(e);const i=await V.createPatientWithSurgery(e,t);return this.invalidateCache(),i}async createPatientWithSurgeryAndInfection(e,t,i){ae(e);const n=await V.createPatientWithSurgeryAndInfection(e,t,i);return this.invalidateCache(),n}getTransactionStats(){return j.getTransactionStats()}getTransactionLog(e){return j.getTransactionLog(e)}async handleTemporaryEventsCreation(e,t){return this.withLoading("Salvataggio eventi clinici...",async()=>{try{for(const i of t){const t={...i};delete t.id,delete t.isTemporary,t.paziente_id=e,await w.createEvento(t)}this.showSuccess(`${t.length} eventi clinici salvati con successo`)}catch(i){throw this.handleError(i,{operation:"salvataggio eventi clinici"}),i}})}async createPatientWithTemporaryEvents(e,t){return this.withLoading("Creazione paziente ed eventi clinici...",async()=>{try{const i=await pe.createPatient(e);for(const e of t){const t={...e};delete t.id,delete t.isTemporary,t.paziente_id=i.id,await w.createEvento(t)}return this.showSuccess(`Paziente e ${t.length} eventi clinici creati con successo`),{patient:i,events:t,success:!0}}catch(i){throw this.handleError(i,{operation:"creazione paziente e eventi"}),i}})}logPatientsSample(e,t){try{const n=(e||[]).filter(e=>e&&"trasferimento_esterno"===e.tipo_dimissione).slice(0,5).map(e=>({id:e.id,codice_clinica:e.codice_clinica}));i.group("[patientService.getPatients] Result summary"),i.log({...t,sampleExternalTransfers:n}),i.groupEnd()}catch{}}};export{u as B,D as a,b,w as e,S as g,he as p,_ as r};
