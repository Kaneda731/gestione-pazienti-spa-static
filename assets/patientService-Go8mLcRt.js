import{_ as e}from"./supabase-AmyKTmiY.js";import{l as t,s as i,b as n,n as a}from"./index-B83wxZfZ.js";import{e as o,i as r}from"./infectionDataManager-BDo5SGH0.js";import"./vendor-BU6HxVpN.js";const s=(e={})=>{let t=i.from("pazienti").select("*",{count:"exact"}).not("user_id","is",null);const{reparto:n,diagnosi:a,stato:o,search:r}=e;return n&&(t=t.eq("reparto_appartenenza",n)),a&&(t=t.eq("diagnosi",a)),"attivo"===o&&(t=t.is("data_dimissione",null)),"dimesso"===o&&(t=t.not("data_dimissione","is",null)),r&&(t=t.or(`nome.ilike.%${r}%,cognome.ilike.%${r}%`)),t},c=async(e={},i={})=>{const{page:n=0,limit:a=10,sortColumn:o="data_ricovero",sortDirection:r="desc"}=i;let c=s(e);const l=n*a,d=l+a-1;c=c.order(o,{ascending:"asc"===r}).range(l,d);const{data:p,error:g,count:m}=await c;if(g)throw g;try{const e=(p||[]).filter(e=>e&&"trasferimento_esterno"===e.tipo_dimissione).slice(0,5).map(e=>({id:e.id,codice_clinica:e.codice_clinica}));t.group("[patientApi.getPaginatedPatients] Result summary"),t.log({total:p?.length||0,count:m,externalTransfersSample:e}),t.groupEnd()}catch(f){}return{patients:p||[],totalCount:m||0}},l=async(e={})=>{const{sortColumn:i="data_ricovero",sortDirection:n="desc"}=e;let a=s(e);a=a.order(i,{ascending:"asc"===n});const{data:o,error:r}=await a;if(r)throw r;try{const e=(o||[]).filter(e=>e&&"trasferimento_esterno"===e.tipo_dimissione).slice(0,5).map(e=>({id:e.id,codice_clinica:e.codice_clinica}));t.group("[patientApi.getAllPatients] Result sample"),t.log({total:o?.length||0,externalTransfersSample:e}),t.groupEnd()}catch(c){}return o||[]},d=async e=>{const{data:n,error:a}=await i.from("pazienti").select("*").eq("id",e).single();if(a)throw a;try{t.log("[patientApi.getPatientById] Loaded",{id:n?.id,tipo_dimissione:n?.tipo_dimissione,codice_clinica:n?.codice_clinica||null})}catch(o){}return n},p=async e=>{const{data:t,error:n}=await i.from("pazienti").insert([e]).select().single();if(n)throw n;return t},g=async(e,n)=>{try{t.group("[patientApi.updatePatient] Update payload"),t.log({id:e,codice_clinica:n?.codice_clinica??null,tipo_dimissione:n?.tipo_dimissione??null}),t.groupEnd()}catch(r){}const{data:a,error:o}=await i.from("pazienti").update(n).eq("id",e).select().single();if(o)throw o;try{t.group("[patientApi.updatePatient] Update result"),t.log({id:a?.id,tipo_dimissione:a?.tipo_dimissione??null,codice_clinica:a?.codice_clinica??null}),t.groupEnd()}catch(r){}return a},m=async e=>{const{error:t}=await i.from("pazienti").delete().eq("id",e);if(t)throw t},f=async(e,t=!1)=>{let n=i.from("pazienti").select("id, nome, cognome, codice_rad, data_ricovero, diagnosi, reparto_appartenenza").not("user_id","is",null).or(`nome.ilike.%${e}%,cognome.ilike.%${e}%,codice_rad.ilike.%${e}%`).order("cognome");t&&(n=n.is("data_dimissione",null));const{data:a,error:o}=await n;if(o)throw o;return a||[]},h=async()=>{const{data:e,error:t}=await i.from("pazienti").select("data_dimissione, diagnosi, reparto_appartenenza").not("user_id","is",null);if(t)throw t;return e||[]};function u(e){const t=["nome","cognome","data_nascita","data_ricovero","diagnosi","reparto_appartenenza"];for(const i of t)if(!e[i]||""===e[i].toString().trim())throw new Error(`Il campo ${i} è obbligatorio`);if(e.data_nascita){if(new Date(e.data_nascita)>new Date)throw new Error("La data di nascita non può essere nel futuro")}if(e.data_ricovero){if(new Date(e.data_ricovero)>new Date)throw new Error("La data di ricovero non può essere nel futuro")}if(e.data_dimissione){if(new Date(e.data_dimissione)<new Date(e.data_ricovero))throw new Error("La data di dimissione non può essere precedente alla data di ricovero")}if(e.data_infezione){const t=new Date(e.data_infezione),i=new Date(e.data_ricovero),n=new Date;if(t<i)throw new Error("La data di infezione non può essere precedente alla data di ricovero");if(t>n)throw new Error("La data di infezione non può essere nel futuro");if(e.data_dimissione){if(t>new Date(e.data_dimissione))throw new Error("La data di infezione non può essere successiva alla data di dimissione")}}if(e.codice_rad&&""!==e.codice_rad.trim()&&e.codice_rad.length>11)throw new Error("Il codice RAD non può superare i 11 caratteri");if(e.tipo_dimissione){const t=["dimissione","trasferimento_interno","trasferimento_esterno","decesso"];if(!t.includes(e.tipo_dimissione))throw new Error(`Tipo dimissione non valido. Valori ammessi: ${t.join(", ")}`);if("trasferimento_interno"===e.tipo_dimissione&&(!e.reparto_destinazione||""===e.reparto_destinazione.trim()))throw new Error("Il reparto di destinazione è obbligatorio per i trasferimenti interni");if("trasferimento_esterno"===e.tipo_dimissione){if(!e.clinica_destinazione||""===e.clinica_destinazione.trim())throw new Error("La clinica di destinazione è obbligatoria per i trasferimenti esterni");if(!e.codice_clinica)throw new Error("Il codice clinica è obbligatorio per i trasferimenti esterni");const t=["56","60"];if(!t.includes(e.codice_clinica))throw new Error(`Codice clinica non valido. Valori ammessi: ${t.join(", ")}`)}if("decesso"!==e.tipo_dimissione){if(!e.codice_dimissione)throw new Error("Il codice dimissione è obbligatorio quando si specifica il tipo dimissione (escluso 'decesso')");const t=["0","3","6"];if(!t.includes(e.codice_dimissione))throw new Error(`Codice dimissione non valido. Valori ammessi: ${t.join(", ")}`)}}}const z=new class{constructor(){this.transactionLogs=new Map,this.maxLogRetention=864e5,this.cleanupInterval=36e5,this.startLogCleanup()}async executePatientWithSurgeryTransaction(e,i){const o=this.generateTransactionId();try{this.initializeTransactionLog(o,"patient_with_surgery",{patientData:this.sanitizeLogData(e),surgeryData:this.sanitizeLogData(i)}),n.setLoading(!0,"Creazione paziente e evento intervento..."),await this.validateSurgeryTransactionData(e,i),this.logTransactionStep(o,"validation","completed",{message:"Dati validati con successo"}),this.logTransactionStep(o,"create_patient","started");const t=await this.createPatientStep(e,!1);this.logTransactionStep(o,"create_patient","completed",{patientId:t.id}),this.logTransactionStep(o,"create_surgery_event","started");const r=await this.createSurgeryEventStep(t.id,i);this.logTransactionStep(o,"create_surgery_event","completed",{eventId:r.id});let s=null;if(i.has_infection&&i.data_infezione){this.logTransactionStep(o,"create_infection_event","started");const e={data_evento:i.data_infezione,agente_patogeno:i.agente_patogeno,descrizione:i.descrizione_infezione};s=await this.createInfectionEventStep(t.id,e),this.logTransactionStep(o,"create_infection_event","completed",{eventId:s.id})}return this.logTransactionStep(o,"verify_synchronization","started"),await this.verifySynchronizationStep(t.id),this.logTransactionStep(o,"verify_synchronization","completed"),this.completeTransactionLog(o,"completed"),a.success("Paziente e evento intervento creati con successo!"),{success:!0,transactionId:o,patient:t,surgeryEvent:r,infectionEvent:s,message:"Transazione completata con successo"}}catch(r){throw t.error(`Errore nella transazione ${o}:`,r),await this.handleTransactionFailure(o,r),r}finally{n.setLoading(!1)}}async executePatientWithSurgeryAndInfectionTransaction(e,i,o){const r=this.generateTransactionId();try{this.initializeTransactionLog(r,"patient_with_surgery_and_infection",{patientData:this.sanitizeLogData(e),surgeryData:this.sanitizeLogData(i),infectionData:this.sanitizeLogData(o)}),n.setLoading(!0,"Creazione paziente, intervento e infezione..."),await this.validateSurgeryTransactionData(e,i),await this.validateTransactionData(e,o),this.logTransactionStep(r,"validation","completed",{message:"Dati validati con successo"}),this.logTransactionStep(r,"create_patient","started");const t=await this.createPatientStep(e,!0);this.logTransactionStep(r,"create_patient","completed",{patientId:t.id}),this.logTransactionStep(r,"create_surgery_event","started");const s=await this.createSurgeryEventStep(t.id,i);this.logTransactionStep(r,"create_surgery_event","completed",{eventId:s.id}),this.logTransactionStep(r,"create_infection_event","started");const c=await this.createInfectionEventStep(t.id,o);return this.logTransactionStep(r,"create_infection_event","completed",{eventId:c.id}),this.logTransactionStep(r,"verify_synchronization","started"),await this.verifySynchronizationStep(t.id),this.logTransactionStep(r,"verify_synchronization","completed"),this.completeTransactionLog(r,"completed"),a.success("Paziente, intervento e infezione creati con successo!"),{success:!0,transactionId:r,patient:t,surgeryEvent:s,infectionEvent:c,message:"Transazione completata con successo"}}catch(s){throw t.error(`Errore nella transazione ${r}:`,s),await this.handleTransactionFailure(r,s),s}finally{n.setLoading(!1)}}async executePatientWithInfectionTransaction(e,i){const o=this.generateTransactionId();try{this.initializeTransactionLog(o,"patient_with_infection",{patientData:this.sanitizeLogData(e),infectionData:this.sanitizeLogData(i)}),n.setLoading(!0,"Creazione paziente e evento infezione..."),await this.validateTransactionData(e,i),this.logTransactionStep(o,"validation","completed",{message:"Dati validati con successo"}),this.logTransactionStep(o,"create_patient","started");const t=await this.createPatientStep(e,!0);this.logTransactionStep(o,"create_patient","completed",{patientId:t.id}),this.logTransactionStep(o,"create_infection_event","started");const r=await this.createInfectionEventStep(t.id,i);return this.logTransactionStep(o,"create_infection_event","completed",{eventId:r.id}),this.logTransactionStep(o,"verify_synchronization","started"),await this.verifySynchronizationStep(t.id),this.logTransactionStep(o,"verify_synchronization","completed"),this.completeTransactionLog(o,"completed"),a.success("Paziente e evento infezione creati con successo!"),{success:!0,transactionId:o,patient:t,infectionEvent:r,message:"Transazione completata con successo"}}catch(r){throw t.error(`Errore nella transazione ${o}:`,r),await this.handleTransactionFailure(o,r),r}finally{n.setLoading(!1)}}async validateSurgeryTransactionData(e,i){if(!e||"object"!=typeof e)throw new Error("Dati paziente non validi");const n=["nome","cognome","data_ricovero"];for(const t of n)if(!e[t]||""===e[t].toString().trim())throw new Error(`Campo paziente obbligatorio mancante: ${t}`);if(!i||"object"!=typeof i)throw new Error("Dati intervento non validi");const a=["data_evento","tipo_intervento"];for(const t of a)if(!i[t]||""===i[t].toString().trim())throw new Error(`Campo intervento obbligatorio mancante: ${t}`);const o=new Date(i.data_evento),r=new Date;if(r.setHours(23,59,59,999),isNaN(o.getTime()))throw new Error("Data evento intervento non valida");if(o>r)throw new Error("La data dell'evento di intervento non può essere nel futuro");if(i.has_infection&&i.data_infezione){const e=new Date(i.data_infezione);if(isNaN(e.getTime()))throw new Error("Data infezione associata non valida");if(e<o)throw new Error("La data dell'infezione non può essere precedente all'intervento")}t.log("Validazione dati transazione intervento completata con successo")}async validateTransactionData(e,i){if(!e||"object"!=typeof e)throw new Error("Dati paziente non validi");const n=["nome","cognome","data_ricovero"];for(const t of n)if(!e[t]||""===e[t].toString().trim())throw new Error(`Campo paziente obbligatorio mancante: ${t}`);if(!i||"object"!=typeof i)throw new Error("Dati infezione non validi");const a=["data_evento"];for(const t of a)if(!i[t]||""===i[t].toString().trim())throw new Error(`Campo infezione obbligatorio mancante: ${t}`);const o=new Date(i.data_evento),r=new Date;if(r.setHours(23,59,59,999),isNaN(o.getTime()))throw new Error("Data evento infezione non valida");if(o>r)throw new Error("La data dell'evento di infezione non può essere nel futuro");t.log("Validazione dati transazione completata con successo")}async createPatientStep(e,i=!1){try{const n={...e,infetto:i,data_infezione:null},a=await p(n);if(!a||!a.id)throw new Error("Creazione paziente fallita: nessun ID restituito");return t.log(`Paziente creato con successo: ID ${a.id}`),a}catch(n){throw t.error("Errore nella creazione paziente:",n),new Error(`Fallimento creazione paziente: ${n.message}`)}}async createSurgeryEventStep(e,i){try{const n={paziente_id:e,tipo_evento:"intervento",data_evento:i.data_evento,tipo_intervento:i.tipo_intervento,descrizione:i.descrizione||null,data_fine_evento:null},a=await o.createEvento(n);if(!a||!a.id)throw new Error("Creazione evento intervento fallita: nessun ID restituito");return t.log(`Evento intervento creato con successo: ID ${a.id}`),a}catch(n){throw t.error("Errore nella creazione evento intervento:",n),new Error(`Fallimento creazione evento intervento: ${n.message}`)}}async createInfectionEventStep(e,i){try{const n={paziente_id:e,tipo_evento:"infezione",data_evento:i.data_evento,agente_patogeno:i.agente_patogeno||null,descrizione:i.descrizione||null,data_fine_evento:null},a=await o.createEvento(n);if(!a||!a.id)throw new Error("Creazione evento infezione fallita: nessun ID restituito");return t.log(`Evento infezione creato con successo: ID ${a.id}`),a}catch(n){throw t.error("Errore nella creazione evento infezione:",n),new Error(`Fallimento creazione evento infezione: ${n.message}`)}}async verifySynchronizationStep(e){try{await new Promise(e=>setTimeout(e,500));const i=await d(e);if(!i)throw new Error("Paziente non trovato durante verifica sincronizzazione");i.infetto||t.warn(`Paziente ${e}: flag infetto non sincronizzato correttamente`),i.data_infezione||t.warn(`Paziente ${e}: data_infezione non sincronizzata correttamente`),t.log(`Sincronizzazione verificata per paziente ${e}`)}catch(i){t.error("Errore nella verifica sincronizzazione:",i),t.warn("Continuando nonostante errore di verifica sincronizzazione")}}async handleTransactionFailure(e,i){const n=this.transactionLogs.get(e);if(!n)return t.error(`Log transazione ${e} non trovato`),void 0;this.logTransactionStep(e,"handle_failure","started",{error:i.message});const a=n.steps.filter(e=>"completed"===e.status),o=a.some(e=>"create_patient"===e.step),r=a.some(e=>"create_infection_event"===e.step);try{r&&!o?(t.warn("Evento infezione creato senza paziente - situazione inconsistente"),await this.handleInconsistentState(e,i)):o&&!r?await this.handlePatientCreatedInfectionFailed(e,i):o?await this.handleLateFailure(e,i):await this.handleEarlyFailure(e,i),this.completeTransactionLog(e,"failed")}catch(s){t.error(`Errore durante gestione fallimento transazione ${e}:`,s),this.completeTransactionLog(e,"rollback_failed")}}async handlePatientCreatedInfectionFailed(e,t){const i=this.transactionLogs.get(e).steps.find(e=>"create_patient"===e.step&&"completed"===e.status);if(!i||!i.data||!i.data.patientId)throw new Error("ID paziente non trovato nel log della transazione");const n=i.data.patientId;throw this.logTransactionStep(e,"recovery_options_presented","completed",{type:"error",title:"Creazione Incompleta",message:`Paziente creato con successo, ma creazione evento infezione fallita. \n                Paziente ID: ${n}\n                Errore: ${t.message}`,actions:[{label:"Riprova Evento Infezione",action:"retry_infection",data:{transactionId:e,patientId:n}},{label:"Completa Manualmente",action:"complete_manually",data:{patientId:n}},{label:"Elimina Paziente",action:"rollback_patient",data:{patientId:n},variant:"danger"}]}),a.error("Paziente creato ma evento infezione fallito. Controlla la sezione notifiche per le opzioni di recovery.",{persistent:!0}),new Error(`Transazione parzialmente completata. Paziente ID: ${n}. ${t.message}`)}async handleEarlyFailure(e,t){this.logTransactionStep(e,"early_failure_handled","completed",{message:"Nessun rollback necessario - nessuna risorsa creata"}),a.error(`Errore nella creazione: ${t.message}`)}async handleLateFailure(e,t){this.logTransactionStep(e,"late_failure_handled","completed",{message:"Transazione sostanzialmente completata nonostante errore finale",originalError:t.message}),a.warning(`Paziente e evento infezione creati, ma si è verificato un errore nella verifica finale: ${t.message}`)}async handleInconsistentState(e,t){this.logTransactionStep(e,"inconsistent_state_detected","completed",{message:"Stato inconsistente rilevato - richiede intervento manuale",originalError:t.message}),a.error(`Stato inconsistente rilevato. Contattare l'amministratore. Transazione ID: ${e}`,{persistent:!0})}async rollbackPatientCreation(e){try{await m(e),t.log(`Rollback completato: paziente ${e} eliminato`),a.success("Rollback completato: paziente eliminato")}catch(i){throw t.error(`Errore nel rollback paziente ${e}:`,i),new Error(`Rollback fallito: ${i.message}`)}}async retryInfectionCreation(e,i,n){const o=`${e}_retry_${Date.now()}`;try{this.initializeTransactionLog(o,"retry_infection_creation",{originalTransactionId:e,patientId:i,infectionData:this.sanitizeLogData(n)});const t=await this.createInfectionEventStep(i,n);return await this.verifySynchronizationStep(i),this.completeTransactionLog(o,"completed"),a.success("Evento infezione creato con successo!"),t}catch(r){throw this.completeTransactionLog(o,"failed"),t.error("Errore nel retry creazione infezione:",r),r}}initializeTransactionLog(e,i,n={}){const a={id:e,type:i,status:"started",steps:[],initialData:n,createdAt:Date.now(),completedAt:null};this.transactionLogs.set(e,a),t.log(`Transazione ${e} inizializzata: ${i}`)}logTransactionStep(e,i,n,a={}){const o=this.transactionLogs.get(e);if(!o)return t.error(`Tentativo di loggare step per transazione inesistente: ${e}`),void 0;const r={step:i,status:n,data:this.sanitizeLogData(a),timestamp:Date.now()};o.steps.push(r),t.log(`Transazione ${e} - Step ${i}: ${n}`)}completeTransactionLog(e,i){const n=this.transactionLogs.get(e);if(!n)return t.error(`Tentativo di completare transazione inesistente: ${e}`),void 0;n.status=i,n.completedAt=Date.now(),t.log(`Transazione ${e} completata con stato: ${i}`)}getTransactionLog(e){return this.transactionLogs.get(e)||null}getAllTransactionLogs(){return Array.from(this.transactionLogs.values())}generateTransactionId(){return`tx_${Date.now()}_${Math.random().toString(36).substr(2,9)}`}sanitizeLogData(e){if(!e||"object"!=typeof e)return e;const t={...e};return["password","token","auth","secret","nome","cognome","codice_fiscale","codice_rad","telefono","email","indirizzo","indirizzo_residenza","citta","cap","note","descrizione"].forEach(e=>{t[e]&&(t[e]="[REDACTED]")}),t}startLogCleanup(){setInterval(()=>{this.cleanupOldLogs()},this.cleanupInterval)}cleanupOldLogs(){const e=Date.now();let i=0;for(const[t,n]of this.transactionLogs.entries())e-n.createdAt>this.maxLogRetention&&(this.transactionLogs.delete(t),i++);i>0&&t.log(`Cleanup log transazioni: ${i} log rimossi`)}getTransactionStats(){const e=Array.from(this.transactionLogs.values());return{total:e.length,byStatus:e.reduce((e,t)=>(e[t.status]=(e[t.status]||0)+1,e),{}),byType:e.reduce((e,t)=>(e[t.type]=(e[t.type]||0)+1,e),{}),oldestLog:e.length>0?Math.min(...e.map(e=>e.createdAt)):null,newestLog:e.length>0?Math.max(...e.map(e=>e.createdAt)):null}}};const _=new class{constructor(){this.cache=new Map,this.cacheTimeout=3e5}async getPatients(e={},i={}){try{n.setLoading(!0,"Caricamento pazienti...");const{page:a=0,limit:r=10}=i,{patients:s,totalCount:l}=await c(e,i);try{const e=(s||[]).filter(e=>e&&"trasferimento_esterno"===e.tipo_dimissione).slice(0,5).map(e=>({id:e.id,codice_clinica:e.codice_clinica}));t.group("[patientService.getPatients] Result summary"),t.log({page:a,limit:r,totalCount:l,sampleExternalTransfers:e}),t.groupEnd()}catch(o){}return{patients:s,totalCount:l,currentPage:a,totalPages:Math.ceil(l/r),hasNextPage:(a+1)*r<l,hasPrevPage:a>0}}catch(r){throw t.error("Errore nel caricamento pazienti:",r),a.error(`Errore nel caricamento: ${r.message}`),r}finally{n.setLoading(!1)}}async getPatientById(e){const i=`patient_${e}`,n=this.cache.get(i);if(n&&Date.now()-n.timestamp<this.cacheTimeout)return n.data;try{const n=await d(e);this.cache.set(i,{data:n,timestamp:Date.now()});try{t.log("[patientService.getPatientById] Received",{id:n?.id,tipo_dimissione:n?.tipo_dimissione,codice_clinica:n?.codice_clinica||null})}catch(o){}return n}catch(r){throw t.error("Errore nel caricamento paziente:",r),a.error(`Errore nel caricamento paziente: ${r.message}`),r}}async createPatient(e){try{n.setLoading(!0,"Creazione paziente..."),u(e);const{data:{user:t}}=await i.auth.getUser();if(!t)throw new Error("Utente non autenticato");const o={...e,user_id:t.id,data_dimissione:null,infetto:Boolean(e.infetto)},r=await p(o);return this.invalidateCache(),a.success("Paziente creato con successo!"),r}catch(o){throw t.error("Errore nella creazione paziente:",o),a.error(`Errore nella creazione: ${o.message}`),o}finally{n.setLoading(!1)}}async updatePatient(e,i,o={showNotification:!0}){try{n.setLoading(!0,"Aggiornamento paziente...");const t=await g(e,i);return this.cache.delete(`patient_${e}`),o.showNotification&&a.success("Paziente aggiornato con successo!"),t}catch(r){throw t.error("Errore nell'aggiornamento paziente:",r),a.error(`Errore nell'aggiornamento: ${r.message}`),r}finally{n.setLoading(!1)}}async deletePatient(e){try{n.setLoading(!0,"Eliminazione paziente..."),await m(e),this.cache.delete(`patient_${e}`),this.invalidateCache(),a.success("Paziente eliminato con successo!")}catch(i){throw t.error("Errore nell'eliminazione paziente:",i),a.error(`Errore nell'eliminazione: ${i.message}`),i}finally{n.setLoading(!1)}}async dischargePatient(e,i=null){try{const t=i||(new Date).toISOString().split("T")[0];await this.updatePatient(e,{data_dimissione:t},{showNotification:!1}),a.success("Paziente dimesso con successo!")}catch(n){throw t.error("Errore nella dimissione:",n),a.error(`Errore nella dimissione: ${n.message}`),n}}async dischargePatientWithTransfer(e,i){try{n.setLoading(!0,"Dimissione paziente..."),function(e){const t=["data_dimissione","tipo_dimissione"];for(const n of t)if(!e[n]||""===e[n].toString().trim())throw new Error(`Il campo ${n} è obbligatorio`);const i=["dimissione","trasferimento_interno","trasferimento_esterno","decesso"];if(!i.includes(e.tipo_dimissione))throw new Error(`Tipo dimissione non valido. Valori ammessi: ${i.join(", ")}`);if(e.data_dimissione&&new Date(e.data_dimissione)>new Date)throw new Error("La data di dimissione non può essere nel futuro");if("trasferimento_interno"===e.tipo_dimissione&&(!e.reparto_destinazione||""===e.reparto_destinazione.trim()))throw new Error("Il reparto di destinazione è obbligatorio per i trasferimenti interni");if("trasferimento_esterno"===e.tipo_dimissione){if(!e.clinica_destinazione||""===e.clinica_destinazione.trim())throw new Error("La clinica di destinazione è obbligatoria per i trasferimenti esterni");if(!e.codice_clinica)throw new Error("Il codice clinica è obbligatorio per i trasferimenti esterni");const t=["56","60"];if(!t.includes(e.codice_clinica))throw new Error(`Codice clinica non valido. Valori ammessi: ${t.join(", ")}`)}if("decesso"!==e.tipo_dimissione){if(!e.codice_dimissione)throw new Error("Il codice dimissione è obbligatorio");const t=["0","3","6"];if(!t.includes(e.codice_dimissione))throw new Error(`Codice dimissione non valido. Valori ammessi: ${t.join(", ")}`)}}(i);const t=await g(e,i);this.cache.delete(`patient_${e}`);return a.success(`Paziente ${"dimissione"===i.tipo_dimissione?"dimesso":"trasferito"} con successo!`),t}catch(o){throw t.error("Errore nella dimissione/trasferimento:",o),a.error(`Errore nella dimissione: ${o.message}`),o}finally{n.setLoading(!1)}}async reactivatePatient(e){try{const t={data_dimissione:null,tipo_dimissione:null,reparto_destinazione:null,clinica_destinazione:null,codice_clinica:null,codice_dimissione:null};await this.updatePatient(e,t,{showNotification:!1}),a.success("Paziente riattivato con successo!")}catch(i){throw t.error("Errore nella riattivazione:",i),a.error(`Errore nella riattivazione: ${i.message}`),i}}async searchPatients(e,i=!1){try{return await f(e,i)}catch(n){throw t.error("Errore nella ricerca pazienti:",n),a.error(`Errore nella ricerca: ${n.message}`),n}}async exportPatients(e={}){try{n.setLoading(!0,"Preparazione esportazione...");const o=await l(e);try{const e=(o||[]).filter(e=>e&&"trasferimento_esterno"===e.tipo_dimissione).slice(0,5).map(e=>({id:e.id,codice_clinica:e.codice_clinica}));t.group("[patientService.exportPatients] Export dataset sample"),t.log({total:o?.length||0,sampleExternalTransfers:e}),t.groupEnd()}catch(i){}if(!o||0===o.length)return a.warning("Nessun dato da esportare per i filtri selezionati."),void 0;!function(e,t){const i=new Blob([e],{type:"text/csv;charset=utf-8;"}),n=document.createElement("a");n.href=URL.createObjectURL(i),n.download=t,document.body.appendChild(n),n.click(),document.body.removeChild(n)}([["Nome","Cognome","Data Nascita","Data Ricovero","Data Dimissione","Diagnosi","Reparto Appartenenza","Reparto Provenienza","Livello Assistenza","Codice RAD","Infetto"],...o.map(e=>[e.nome||"",e.cognome||"",e.data_nascita?new Date(e.data_nascita).toLocaleDateString():"",e.data_ricovero?new Date(e.data_ricovero).toLocaleDateString():"",e.data_dimissione?new Date(e.data_dimissione).toLocaleDateString():"",e.diagnosi||"",e.reparto_appartenenza||"",e.reparto_provenienza||"",e.livello_assistenza||"",e.codice_rad||"",e.infetto?"Sì":"No"])].map(e=>e.map(e=>`"${e.toString().replace(/"/g,'""')}"`).join(",")).join("\n"),"esportazione_pazienti.csv"),a.success(`Esportati ${o.length} pazienti con successo!`)}catch(o){throw t.error("Errore nell'esportazione:",o),a.error(`Errore nell'esportazione: ${o.message}`),o}finally{n.setLoading(!1)}}async getPatientStats(){try{const e=await h(),t={total:e.length,active:e.filter(e=>!e.data_dimissione).length,discharged:e.filter(e=>e.data_dimissione).length,byDiagnosis:{},byDepartment:{}};return e.forEach(e=>{t.byDiagnosis[e.diagnosi]=(t.byDiagnosis[e.diagnosi]||0)+1,t.byDepartment[e.reparto_appartenenza]=(t.byDepartment[e.reparto_appartenenza]||0)+1}),t}catch(e){throw t.error("Errore nel caricamento statistiche:",e),e}}async getTransferHistory(e){try{const t=await this.getPatientById(e);if(!t)throw new Error("Paziente non trovato");const i=[];return t.data_dimissione&&t.tipo_dimissione&&i.push({data:t.data_dimissione,tipo:t.tipo_dimissione,reparto_destinazione:t.reparto_destinazione,clinica_destinazione:t.clinica_destinazione,codice_clinica:t.codice_clinica,codice_dimissione:t.codice_dimissione}),i}catch(i){throw t.error("Errore nel caricamento cronologia trasferimenti:",i),a.error(`Errore nel caricamento cronologia: ${i.message}`),i}}invalidateCache(){this.cache.clear()}async createPatientWithInfection(e,i){try{if(t.log("Avvio creazione paziente con infezione:",{patientName:`${e.nome} ${e.cognome}`,infectionDate:i.data_evento}),u(e),r.setInfectionData(i),!r.hasValidInfectionData()){const e=r.getValidationErrors().map(e=>e.message).join(", ");throw new Error(`Dati infezione non validi: ${e}`)}const n=await z.executePatientWithInfectionTransaction(e,i);return r.clearInfectionData(),this.invalidateCache(),t.log("Creazione paziente con infezione completata con successo:",{transactionId:n.transactionId,patientId:n.patient?.id,infectionEventId:n.infectionEvent?.id}),n}catch(n){throw t.error("Errore nella creazione paziente con infezione:",n),n.message.includes("Dati infezione non validi")?a.error(`Errore nei dati di infezione: ${n.message}`):n.message.includes("Transazione parzialmente completata")?t.warn("Transazione parzialmente completata - recovery options presentate"):a.error(`Errore nella creazione: ${n.message}`),n}}async handleInfectionEventCreation(e,i){try{t.log(`Creazione evento infezione per paziente ${e}`);if(!(await this.getPatientById(e)))throw new Error(`Paziente con ID ${e} non trovato`);if(r.setInfectionData(i),!r.hasValidInfectionData()){const e=r.getValidationErrors().map(e=>e.message).join(", ");throw new Error(`Dati infezione non validi: ${e}`)}const n=(await o.getEventiByPaziente(e,{tipo_evento:"infezione"})).filter(e=>!e.data_fine_evento);if(n.length>0)throw t.warn(`Paziente ${e} ha già un'infezione attiva`),a.warning(`Il paziente ha già un'infezione attiva dal ${n[0].data_evento}. Vuoi comunque creare un nuovo evento di infezione?`,{persistent:!0,actions:[{label:"Crea Comunque",action:"force_create_infection"},{label:"Annulla",action:"cancel_infection"}]}),new Error("Paziente ha già un'infezione attiva");const s={paziente_id:e,tipo_evento:"infezione",data_evento:i.data_evento,agente_patogeno:i.agente_patogeno||null,descrizione:i.descrizione||null,data_fine_evento:null},c=await o.createEvento(s);return r.clearInfectionData(),this.cache.delete(`patient_${e}`),t.log(`Evento infezione creato con successo: ID ${c.id}`),c}catch(n){if(t.error(`Errore nella creazione evento infezione per paziente ${e}:`,n),n.message.includes("già un'infezione attiva"))throw n;throw n.message.includes("Dati infezione non validi")?a.error(`Errore nei dati di infezione: ${n.message}`):n.message.includes("non trovato")?a.error("Paziente non trovato"):a.error(`Errore nella creazione evento infezione: ${n.message}`),n}}async retryInfectionEventCreation(e,i,n){try{return t.log(`Retry creazione evento infezione - Transazione: ${e}, Paziente: ${i}`),await z.retryInfectionCreation(e,i,n)}catch(o){throw t.error("Errore nel retry creazione evento infezione:",o),a.error(`Errore nel retry: ${o.message}`),o}}async rollbackPatientCreation(e){try{t.log(`Rollback creazione paziente: ${e}`),await z.rollbackPatientCreation(e),this.cache.delete(`patient_${e}`),this.invalidateCache()}catch(i){throw t.error(`Errore nel rollback paziente ${e}:`,i),a.error(`Errore nel rollback: ${i.message}`),i}}async forceCreateInfectionEvent(e,i){try{if(t.log(`Creazione forzata evento infezione per paziente ${e}`),r.setInfectionData(i),!r.hasValidInfectionData()){const e=r.getValidationErrors().map(e=>e.message).join(", ");throw new Error(`Dati infezione non validi: ${e}`)}const n={paziente_id:e,tipo_evento:"infezione",data_evento:i.data_evento,agente_patogeno:i.agente_patogeno||null,descrizione:i.descrizione||null,data_fine_evento:null},s=await o.createEvento(n);return r.clearInfectionData(),this.cache.delete(`patient_${e}`),a.success("Nuovo evento infezione creato con successo!"),s}catch(n){throw t.error("Errore nella creazione forzata evento infezione:",n),a.error(`Errore nella creazione: ${n.message}`),n}}async createPatientWithSurgery(i,n){try{t.log("Avvio creazione paziente con intervento chirurgico:",{patientName:`${i.nome} ${i.cognome}`,surgeryDate:n.data_evento,surgeryType:n.tipo_intervento}),u(i);const{default:a}=await e(async()=>{const{default:e}=await import("./surgeryDataManager-CbtGeuzn.js");return{default:e}},[]);if(a.setSurgeryData(n),!a.hasValidSurgeryData()){const e=a.getValidationErrors().map(e=>e.message).join(", ");throw new Error(`Dati intervento non validi: ${e}`)}const o=await z.executePatientWithSurgeryTransaction(i,n);return a.clearSurgeryData(),this.invalidateCache(),t.log("Creazione paziente con intervento completata con successo:",{transactionId:o.transactionId,patientId:o.patient?.id,surgeryEventId:o.surgeryEvent?.id}),o}catch(o){throw t.error("Errore nella creazione paziente con intervento:",o),o.message.includes("Dati intervento non validi")?a.error(`Errore nei dati di intervento: ${o.message}`):o.message.includes("Transazione parzialmente completata")?t.warn("Transazione parzialmente completata - recovery options presentate"):a.error(`Errore nella creazione: ${o.message}`),o}}async createPatientWithSurgeryAndInfection(i,n,o){try{t.log("Avvio creazione paziente con intervento e infezione:",{patientName:`${i.nome} ${i.cognome}`,surgeryDate:n.data_evento,infectionDate:o.data_evento||n.data_infezione}),u(i);const{default:a}=await e(async()=>{const{default:e}=await import("./surgeryDataManager-CbtGeuzn.js");return{default:e}},[]);if(a.setSurgeryData(n),!a.hasValidSurgeryData()){const e=a.getValidationErrors().map(e=>e.message).join(", ");throw new Error(`Dati intervento non validi: ${e}`)}let s=o;if(!s&&a.hasAssociatedInfection()&&(s=a.prepareInfectionEventData()),s&&(r.setInfectionData(s),!r.hasValidInfectionData())){const e=r.getValidationErrors().map(e=>e.message).join(", ");throw new Error(`Dati infezione non validi: ${e}`)}const c=await z.executePatientWithSurgeryAndInfectionTransaction(i,n,s);return a.clearSurgeryData(),s&&r.clearInfectionData(),this.invalidateCache(),t.log("Creazione paziente con intervento e infezione completata con successo:",{transactionId:c.transactionId,patientId:c.patient?.id,surgeryEventId:c.surgeryEvent?.id,infectionEventId:c.infectionEvent?.id}),c}catch(s){throw t.error("Errore nella creazione paziente con intervento e infezione:",s),s.message.includes("non validi")?a.error(`Errore nei dati: ${s.message}`):s.message.includes("Transazione parzialmente completata")?t.warn("Transazione parzialmente completata - recovery options presentate"):a.error(`Errore nella creazione: ${s.message}`),s}}getTransactionStats(){return z.getTransactionStats()}getTransactionLog(e){return z.getTransactionLog(e)}async handleTemporaryEventsCreation(e,i){try{n.setLoading(!0,"Salvataggio eventi clinici...");for(const t of i){const i={...t};delete i.id,delete i.isTemporary,i.paziente_id=e,await o.createEvento(i)}a.success(`${i.length} eventi clinici salvati con successo`)}catch(r){throw t.error("Errore nella creazione eventi temporanei:",r),a.error("Errore nel salvare gli eventi clinici"),r}finally{n.setLoading(!1)}}async createPatientWithTemporaryEvents(e,i){try{n.setLoading(!0,"Creazione paziente ed eventi clinici...");const t=await p(e);for(const e of i){const i={...e};delete i.id,delete i.isTemporary,i.paziente_id=t.id,await o.createEvento(i)}return a.success(`Paziente e ${i.length} eventi clinici creati con successo`),{patient:t,events:i,success:!0}}catch(r){throw t.error("Errore nella creazione paziente con eventi temporanei:",r),a.error("Errore nella creazione del paziente e degli eventi"),r}finally{n.setLoading(!1)}}};export{_ as patientService};
