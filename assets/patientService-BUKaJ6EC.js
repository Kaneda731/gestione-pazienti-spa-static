import{l as e,z as t,p as i,e as a,A as n,_ as o,B as r,D as s}from"./core-services-CSrwUk3W.js";import{P as c,p as l,q as d,r as u,t as p,V as h}from"./shared-DM1owLfs.js";const g=new class{cache=new Map;cacheTimeout=3e5;stats={hits:0,misses:0,entries:0,lastCleanup:Date.now()};cleanupInterval=null;constructor(e=3e5){this.cacheTimeout=e,this.startAutoCleanup()}generateCacheKey(e={},t={}){const i={filters:{paziente_search:e.paziente_search?.trim()||"",paziente_id:e.paziente_id||"",tipo_evento:e.tipo_evento||"",data_inizio:e.data_inizio||"",data_fine:e.data_fine||""},pagination:{page:t.page??0,limit:t.limit??10,sortColumn:t.sortColumn||"data_evento",sortDirection:t.sortDirection||"desc"}};return`search_${JSON.stringify(i)}`}get(t={},i={}){const a=this.generateCacheKey(t,i),n=this.cache.get(a);if(n){if(!(Date.now()-n.timestamp>this.cacheTimeout))return this.stats.hits++,e.debug(`Cache HIT: ${a.substring(0,50)}... (TTL: ${(this.cacheTimeout-(Date.now()-n.timestamp))/1e3}s remaining)`),n.result;this.cache.delete(a),e.debug(`Cache EXPIRED: ${a.substring(0,50)}...`)}return this.stats.misses++,null}set(t={},i={},a){const n=this.generateCacheKey(t,i);this.cache.set(n,{result:a,timestamp:Date.now()}),this.stats.entries=this.cache.size,e.debug(`Cache SET: ${n.substring(0,50)}... (${a.totalCount} events)`)}has(e={},t={}){return null!==this.get(e,t)}invalidatePatient(t){let i=0;for(const[e]of this.cache.entries())e.includes(`"paziente_id":"${t}"`)&&(this.cache.delete(e),i++);i>0&&(this.stats.entries=this.cache.size,e.debug(`Cache INVALIDATED: ${i} entries for patient ${t}`))}invalidateEventType(t){let i=0;for(const[e]of this.cache.entries())e.includes(`"tipo_evento":"${t}"`)&&(this.cache.delete(e),i++);i>0&&(this.stats.entries=this.cache.size,e.debug(`Cache INVALIDATED: ${i} entries for event type ${t}`))}invalidateDateRange(t,i){let a=0;for(const[e]of this.cache.entries())e.includes('"data_')&&(this.cache.delete(e),a++);a>0&&(this.stats.entries=this.cache.size,e.debug(`Cache INVALIDATED: ${a} entries for date range ${t} to ${i}`))}clear(){const t=this.cache.size;this.cache.clear(),this.stats={hits:0,misses:0,entries:0,lastCleanup:Date.now()},e.debug(`Cache CLEARED: ${t} entries removed`)}cleanup(){const t=Date.now();let i=0;for(const[e,a]of this.cache.entries())t-a.timestamp>this.cacheTimeout&&(this.cache.delete(e),i++);this.stats.entries=this.cache.size,this.stats.lastCleanup=t,i>0&&e.debug(`Cache CLEANUP: ${i} expired entries removed`)}startAutoCleanup(){this.cleanupInterval&&clearInterval(this.cleanupInterval),this.cleanupInterval=setInterval(()=>this.cleanup(),6e4)}stopAutoCleanup(){this.cleanupInterval&&(clearInterval(this.cleanupInterval),this.cleanupInterval=null)}getStats(){const e=this.stats.hits+this.stats.misses;return{...this.stats,hitRate:Number((e>0?this.stats.hits/e*100:0).toFixed(2))}}setCacheTimeout(t){this.cacheTimeout=Math.max(0,t),e.debug(`Cache timeout set to ${t}ms`)}getCacheTimeout(){return this.cacheTimeout}getCacheKeys(){return Array.from(this.cache.keys()).map(e=>e.substring(0,80)+"...")}getDebugInfo(){return{totalEntries:this.cache.size,cacheTimeout:this.cacheTimeout,stats:this.getStats(),keys:this.getCacheKeys().slice(0,10),memoryUsage:`~${(JSON.stringify(Array.from(this.cache.entries())).length/1024).toFixed(2)}KB`}}};const v=new class{rules=new Map;stats={totalInvalidations:0,selectiveInvalidations:0,fullInvalidations:0,rulesApplied:0,cacheEntriesCleared:0,lastInvalidation:0};constructor(){this.initializeDefaultRules()}initializeDefaultRules(){this.addRule({id:"intervention-events",name:"Intervention Events",description:"Invalidates cache entries related to surgical interventions",eventType:"intervento",affects:["search:*tipo_evento:intervento*","search:*:*","events-paziente_*"],dependencies:[],priority:10}),this.addRule({id:"infection-events",name:"Infection Events",description:"Invalidates cache entries related to infections",eventType:"infezione",affects:["search:*tipo_evento:infezione*","search:*:*","events-paziente_*","patient-infection-status_*"],dependencies:[],priority:10}),this.addRule({id:"patient-data-changes",name:"Patient Data Changes",description:"Invalidates all cache entries when patient data changes",eventType:"patient-update",affects:["search:*:*","events-paziente_*","patient-search_*"],dependencies:[],priority:20}),this.addRule({id:"new-event-statistics",name:"New Event Statistics",description:"Invalidates statistics cache when new events are added",eventType:"create",affects:["event-stats_*","suggested-filters_*"],dependencies:[],priority:5}),e.debug("Initialized default cache invalidation rules")}addRule(t){this.rules.set(t.id,t),e.debug(`Added cache invalidation rule: ${t.name}`)}removeRule(t){const i=this.rules.delete(t);return i&&e.debug(`Removed cache invalidation rule: ${t}`),i}getRules(){return Array.from(this.rules.values())}invalidateCache(t,i,a={}){const n=Date.now();if(this.stats.totalInvalidations++,a.forceFullInvalidation){const t=this.performFullInvalidation();return this.stats.fullInvalidations++,this.stats.lastInvalidation=Date.now(),e.debug(`Performed full cache invalidation in ${Date.now()-n}ms`),{invalidated:!0,entriesCleared:t,rulesApplied:0,strategy:"full"}}const o=this.findApplicableRules(t,i);if(0===o.length)return e.debug(`No applicable invalidation rules for event type: ${t}`),{invalidated:!1,entriesCleared:0,rulesApplied:0,strategy:"none"};o.sort((e,t)=>t.priority-e.priority);const r=new Set;let s=0;for(const e of o)e.condition&&!e.condition(i)||(e.affects.forEach(e=>{this.getCacheKeysByPattern(e,a.patientId).forEach(e=>r.add(e))}),s++,this.stats.rulesApplied++);if(0===r.size)return e.debug("No cache entries would be affected by invalidation rules"),{invalidated:!1,entriesCleared:0,rulesApplied:s,strategy:"none"};const c=this.performSelectiveInvalidation(Array.from(r));return this.stats.selectiveInvalidations++,this.stats.cacheEntriesCleared+=c,this.stats.lastInvalidation=Date.now(),e.debug(`Performed selective cache invalidation in ${Date.now()-n}ms: ${c} entries cleared, ${s} rules applied`),{invalidated:!0,entriesCleared:c,rulesApplied:s,strategy:"selective"}}findApplicableRules(e,t){const i=[];for(const a of this.rules.values())a.eventType!==e?a.dependencies.includes(e)&&i.push(a):i.push(a);return i}getCacheKeysByPattern(e,t){const i=[];if("search:*:*"===e)i.push(...g.getCacheKeys());else if(e.startsWith("search:")){const t=e.replace("search:","");i.push(...g.getCacheKeys().filter(e=>e.includes(t)))}else e.startsWith("events-paziente_")?t&&i.push(`events-paziente_${t}`):e.startsWith("patient-infection-status_")&&t&&i.push(`patient-infection-status_${t}`);return i}performSelectiveInvalidation(e){let t=0;for(const i of e)i.startsWith("search_")?(g.clear(),t++):(i.startsWith("events-paziente_")||i.startsWith("patient-infection-status_"))&&t++;return t}performFullInvalidation(){return g.clear(),1}getStats(){const e=this.stats.totalInvalidations,t=this.stats.totalInvalidations>0?this.stats.rulesApplied/this.stats.totalInvalidations:0;return{...this.stats,selectiveRate:Number((e>0?this.stats.selectiveInvalidations/e*100:0).toFixed(2)),averageRulesPerInvalidation:Number(t.toFixed(2))}}resetStats(){this.stats={totalInvalidations:0,selectiveInvalidations:0,fullInvalidations:0,rulesApplied:0,cacheEntriesCleared:0,lastInvalidation:0},e.debug("Cache invalidation statistics reset")}getDebugInfo(){return{totalRules:this.rules.size,rules:Array.from(this.rules.values()).map(e=>({id:e.id,name:e.name,eventType:e.eventType,affectsCount:e.affects.length,priority:e.priority})),stats:this.getStats()}}};const f=new class{async handle(i,a){e.error(`Error ${a}:`,i);const n={JWT:"Sessione scaduta. Effettua nuovamente l'accesso.",network:"Impossibile connettersi al server.",fetch:"Impossibile connettersi al server.",duplicate:"Questo evento esiste già.","foreign key":"Paziente non trovato.",23503:"Paziente non trovato."};for(const[e,o]of Object.entries(n))if(i.message?.includes(e))return t(o),void 0;t(`Errore ${a}: ${i.message}`)}};const m=new class{validateEvento(e){const t={};if(e.paziente_id||(t.paziente_id="Paziente obbligatorio"),e.tipo_evento||(t.tipo_evento="Tipo evento obbligatorio"),e.data_evento||(t.data_evento="Data evento obbligatoria"),e.data_evento){const i=new Date(e.data_evento),a=new Date;a.setHours(23,59,59,999),isNaN(i.getTime())?t.data_evento="Data non valida":i>a&&(t.data_evento="La data non può essere nel futuro")}return"intervento"===e.tipo_evento&&(e.tipo_intervento_id||(t.tipo_intervento="Specialistica obbligatoria per interventi")),"infezione"===e.tipo_evento&&(e.agente_patogeno_id||e.tipo_patogeno||(t.tipo_batterio="Specificare agente patogeno")),{isValid:0===Object.keys(t).length,errors:t}}};const _=new class{async createEvento(e){try{i.getState().setLoading(!0);const t=m.validateEvento(e);if(!t.isValid){const e=Object.values(t.errors).join(", ");throw new Error(e)}const o={paziente_id:e.paziente_id,tipo_evento:e.tipo_evento,data_evento:e.data_evento};"intervento"===e.tipo_evento&&(e.tipo_intervento_id&&(o.tipo_intervento_id=e.tipo_intervento_id),o.descrizione=e.descrizione_intervento||e.note||null),"infezione"===e.tipo_evento&&(e.agente_patogeno_id&&(o.agente_patogeno_id=e.agente_patogeno_id),o.descrizione=e.note||null,e.tipo_patogeno&&(o.tipo_patogeno=e.tipo_patogeno),e.data_fine_evento&&(o.data_fine_evento=e.data_fine_evento));const{data:r,error:s}=await a.from("eventi_clinici").insert([o]).select().single();if(s)throw s;return"infezione"===e.tipo_evento&&await this._updatePazienteInfezioneStatus(e.paziente_id),this.invalidateCache(),n("Evento creato con successo!"),r}catch(t){throw await f.handle(t,"creazione evento"),t}finally{i.getState().setLoading(!1)}}async updateEvento(t,o){try{i.getState().setLoading(!0);const r=m.validateEvento(o);if(!r.isValid){const e=Object.values(r.errors).join(", ");throw new Error(e)}const s={data_evento:o.data_evento};"intervento"===o.tipo_evento&&(s.descrizione=o.descrizione_intervento||o.note||null,null!=o.tipo_intervento_id&&(s.tipo_intervento_id=o.tipo_intervento_id)),"infezione"===o.tipo_evento&&(s.descrizione=o.note||null,null!=o.agente_patogeno_id&&(s.agente_patogeno_id=o.agente_patogeno_id),o.tipo_patogeno&&(s.tipo_patogeno=o.tipo_patogeno),o.data_fine_evento&&(s.data_fine_evento=o.data_fine_evento)),e.info("Updating event:",{id:t,dataToUpdate:s});const{data:c,error:l}=await a.from("eventi_clinici").update(s).eq("id",t).select().single();if(l)throw e.error("Supabase update error:",{error:l,dataToUpdate:s}),l;return"infezione"===o.tipo_evento&&await this._updatePazienteInfezioneStatus(o.paziente_id),this.invalidateCache(),n("Evento aggiornato con successo!"),c}catch(r){throw await f.handle(r,"aggiornamento evento"),r}finally{i.getState().setLoading(!1)}}async deleteEvento(e){try{i.getState().setLoading(!0);const{data:t,error:o}=await a.from("eventi_clinici").select("paziente_id, tipo_evento").eq("id",e).single();if(o&&"PGRST116"!==o.code)throw o;const{error:r}=await a.from("eventi_clinici").delete().eq("id",e);if(r)throw r;t&&"infezione"===t.tipo_evento&&await this._updatePazienteInfezioneStatus(t.paziente_id),this.invalidateCache(),n("Evento eliminato con successo!")}catch(t){throw await f.handle(t,"eliminazione evento"),t}finally{i.getState().setLoading(!1)}}async resolveInfezione(e,t){try{i.getState().setLoading(!0);const{data:o,error:r}=await a.from("eventi_clinici").select("data_evento, paziente_id").eq("id",e).eq("tipo_evento","infezione").single();if(r)throw r;const s=new Date(o.data_evento);if(new Date(t)<s)throw new Error("La data di risoluzione non può essere precedente alla data dell'infezione");const{data:c,error:l}=await a.from("eventi_clinici").update({data_fine_evento:t}).eq("id",e).select().single();if(l)throw l;return await this._updatePazienteInfezioneStatus(o.paziente_id),this.invalidateCache(),n("Infezione risolta con successo!"),c}catch(o){throw await f.handle(o,"risoluzione infezione"),o}finally{i.getState().setLoading(!1)}}invalidateCache(){g.clear()}invalidateSelectiveCache(e,t){e?v.invalidateCache(e,{},{patientId:t}):this.invalidateCache()}async _updatePazienteInfezioneStatus(t){try{const{data:i,error:n}=await a.from("eventi_clinici").select("id, data_evento").eq("paziente_id",t).eq("tipo_evento","infezione").is("data_fine_evento",null).order("data_evento",{ascending:!1}).limit(1);if(n)throw n;const o=i&&i.length>0,{error:r}=await a.from("pazienti").update({infetto:o,data_infezione:o?i[0].data_evento:null}).eq("id",t);r&&e.error("Supabase patient update error:",r)}catch(i){e.error("Error updating patient infection status:",i)}}};const z=new class{async getListaTipiIntervento(){try{const{data:e,error:t}=await a.from("tipi_intervento").select("id, nome, descrizione").eq("attivo",!0).order("nome",{ascending:!0});if(t)throw t;return e||[]}catch(t){return e.error("Error loading surgery types:",t),[]}}async getListaAgentiPatogeno(){try{const{data:e,error:t}=await a.from("agenti_patogeno").select("id, nome, descrizione").eq("attivo",!0).order("nome",{ascending:!0});if(t)throw t;return e||[]}catch(t){return e.error("Error loading pathogenic agents:",t),[]}}};const y=new class{requests=new Map;defaultTimeout=3e4;stats={total:0,duplicates:0,cancelled:0,completed:0,timedOut:0,active:0};cleanupInterval=null;constructor(e=3e4){this.defaultTimeout=e,this.startAutoCleanup()}generateRequestSignature(e,t={}){const i={method:t.method||"GET",...t.body&&{body:t.body},...t.params&&{params:t.params},...t.headers&&{headers:Object.fromEntries(Object.entries(t.headers).filter(([e])=>!e.toLowerCase().includes("auth")).sort(([e],[t])=>e.localeCompare(t)))}};return`${e}:${JSON.stringify(i)}`}async executeRequest(t,i,a={},n=this.defaultTimeout){const o=this.generateRequestSignature(t,a),r=this.requests.get(o);if(r)return this.stats.duplicates++,e.debug(`Request DUPLICATE: ${o.substring(0,50)}... (returning existing promise)`),r.promise;const s=new AbortController,c=setTimeout(()=>{s.signal.aborted||(s.abort(),this.stats.timedOut++,e.debug(`Request TIMEOUT: ${o.substring(0,50)}...`))},n),l=i(s.signal).then(e=>(this.cleanupRequest(o),this.stats.completed++,e)).catch(t=>{throw this.cleanupRequest(o),"AbortError"!==t.name&&e.error(`Request FAILED: ${o.substring(0,50)}...`,t),t});return this.requests.set(o,{controller:s,promise:l,timestamp:Date.now(),timeout:c}),this.stats.total++,this.stats.active++,e.debug(`Request STARTED: ${o.substring(0,50)}... (active: ${this.stats.active})`),l}cancelRequest(t){const i=this.requests.get(t);return!(!i||i.controller.signal.aborted)&&(i.controller.abort(),this.cleanupRequest(t),this.stats.cancelled++,e.debug(`Request CANCELLED: ${t.substring(0,50)}...`),!0)}cancelAllRequests(){let t=0;for(const[e]of this.requests.entries())this.cancelRequest(e)&&t++;return e.debug(`Cancelled ${t} active requests`),t}cancelRequestsMatching(t){let i=0;const a="string"==typeof t?new RegExp(t):t;for(const[e]of this.requests.entries())a.test(e)&&this.cancelRequest(e)&&i++;return i>0&&e.debug(`Cancelled ${i} requests matching pattern`),i}getStats(){const e=this.stats.total,t=e>0?this.stats.cancelled/e*100:0;return{...this.stats,duplicateRate:Number((e>0?this.stats.duplicates/e*100:0).toFixed(2)),cancellationRate:Number(t.toFixed(2))}}getActiveRequests(){const e=Date.now();return Array.from(this.requests.entries()).map(([t,i])=>({signature:t.substring(0,80)+"...",timestamp:i.timestamp,age:e-i.timestamp}))}cleanupRequest(e){const t=this.requests.get(e);t&&(t.timeout&&clearTimeout(t.timeout),this.requests.delete(e),this.stats.active=Math.max(0,this.stats.active-1))}cleanup(){const t=Date.now();let i=0;for(const[e,a]of this.requests.entries()){(t-a.timestamp>3e5||a.controller.signal.aborted)&&(this.cleanupRequest(e),i++)}i>0&&e.debug(`Request cleanup: ${i} old requests removed`)}startAutoCleanup(){this.cleanupInterval&&clearInterval(this.cleanupInterval),this.cleanupInterval=setInterval(()=>this.cleanup(),6e4)}stopAutoCleanup(){this.cleanupInterval&&(clearInterval(this.cleanupInterval),this.cleanupInterval=null)}resetStats(){this.stats={total:0,duplicates:0,cancelled:0,completed:0,timedOut:0,active:this.requests.size},e.debug("Request statistics reset")}getDebugInfo(){return{activeRequests:this.requests.size,stats:this.getStats(),activeRequestsList:this.getActiveRequests().slice(0,10),memoryUsage:`~${(JSON.stringify(Array.from(this.requests.entries())).length/1024).toFixed(2)}KB`}}};const w=new class{async getAllEventi(e={},t={}){const n=`getAllEventi:${JSON.stringify({filters:e,pagination:t})}`;return y.executeRequest(n,async n=>{try{i.getState().setLoading(!0);const{tipo_evento:n=[],paziente_id:o,paziente_search:r,data_inizio:s,data_fine:c,reparto:l}=e,{page:d=1,limit:u=20,sortColumn:p="data_evento",sortDirection:h="desc"}=t,v="number"==typeof u&&Number.isFinite(u)&&u>0?u:20,f="number"==typeof d&&Number.isFinite(d)&&d>0?d:1;let m=f-1;const _=g.get(e,t);if(_)return _;let z=null;if(r?.trim()&&(z=await this._getPazientiIdsForSearch(r),0===z.length))return this._emptyResult(f);const y=e=>{const t={count:"exact",head:e?.head??!1};let i=a.from("eventi_clinici").select("\n              *,\n              pazienti!inner(\n                id,\n                nome,\n                cognome,\n                codice_rad,\n                reparto_appartenenza,\n                data_dimissione\n              )\n            ",t);return o?i=i.eq("paziente_id",o):z&&(i=i.in("paziente_id",z)),n&&n.length>0&&(i=i.in("tipo_evento",n)),s&&(i=i.gte("data_evento",s)),c&&(i=i.lte("data_evento",c)),l&&(i=i.eq("pazienti.reparto_appartenenza",l)),i};let w=null;if(m>0){const{count:e,error:t}=await y({head:!0});if(t)throw t;w=e??0;const i=w>0?Math.max(0,Math.ceil(w/v)-1):0;m>i&&(m=i)}let E=y();const I=m*v,S=I+v-1;E=E.order(p,{ascending:"asc"===h}).range(I,S);const{data:D,error:P,count:$}=await E;if(P&&"PGRST116"===P.code)return this._emptyResult(m+1);if(P)throw P;const T=w??$??0,C=T>0?Math.ceil(T/v):0,b={eventi:D||[],totalCount:T,currentPage:m+1,totalPages:C,hasNextPage:T>0&&m<C-1,hasPrevPage:m>0};return g.set(e,t,b),b}catch(o){throw await f.handle(o,"loading events"),o}finally{i.getState().setLoading(!1)}},{method:"GET"},3e4)}async getEventiByPaziente(e,t={}){try{let i=a.from("eventi_clinici").select("*").eq("paziente_id",e).order("data_evento",{ascending:!1});t.tipo_evento&&t.tipo_evento.length>0&&(i=i.in("tipo_evento",t.tipo_evento));const{data:n,error:o}=await i;if(o)throw o;return n||[]}catch(i){throw await f.handle(i,"loading patient events"),i}}async searchPazienti(t,i=!0){if(!t?.trim())return[];try{const e=`%${t.trim()}%`;let n=a.from("pazienti").select("id, nome, cognome, codice_rad, reparto_appartenenza, data_dimissione").or(`nome.ilike.${e},cognome.ilike.${e},codice_rad.ilike.${e}`).order("cognome").limit(10);i&&(n=n.is("data_dimissione",null));const{data:o,error:r}=await n;if(r)throw r;return o||[]}catch(n){return e.error("Error searching patients:",n),[]}}async getGiorniPostOperatori(t,i=null){try{const{data:e,error:n}=await a.from("eventi_clinici").select("data_evento, tipo_intervento, descrizione").eq("paziente_id",t).eq("tipo_evento","intervento").order("data_evento",{ascending:!1}).limit(1);if(n)throw n;if(!e||0===e.length)return{giorni:null,ultimoIntervento:null};const o=e[0],r=i?new Date(i):new Date,s=new Date(o.data_evento),c=Math.abs(r.getTime()-s.getTime());return{giorni:Math.ceil(c/864e5),ultimoIntervento:{data:o.data_evento,tipo:o.tipo_intervento||"",descrizione:o.descrizione||void 0}}}catch(n){return e.error("Error calculating post-operative days:",n),{giorni:null,ultimoIntervento:null}}}async _getPazientiIdsForSearch(t){try{const e=`%${t.trim()}%`,{data:i,error:n}=await a.from("pazienti").select("id").or(`nome.ilike.${e},cognome.ilike.${e},codice_rad.ilike.${e}`);if(n)throw n;return i?.map(e=>e.id)||[]}catch(i){return e.error("Error searching patient IDs:",i),[]}}_emptyResult(e){return{eventi:[],totalCount:0,currentPage:e,totalPages:0,hasNextPage:!1,hasPrevPage:!1}}};const E=new class{async getEventiStats(){try{const{data:e,error:t}=await a.from("eventi_clinici").select("tipo_evento, data_evento, pazienti!inner(id)");if(t)throw t;const i=e||[],n={total:i.length,interventi:i.filter(e=>"intervento"===e.tipo_evento).length,infezioni:i.filter(e=>"infezione"===e.tipo_evento).length,ultimoMese:0},o=new Date;return o.setMonth(o.getMonth()-1),n.ultimoMese=i.filter(e=>new Date(e.data_evento)>=o).length,n}catch(t){throw e.error("Error loading event statistics:",t),t}}};const I=new class{async getAllEventi(e={},t={}){return w.getAllEventi(e,t)}async getEventiByPaziente(e,t){return w.getEventiByPaziente(e,t)}async searchPazienti(e,t){return w.searchPazienti(e,t)}async getGiorniPostOperatori(e,t){return w.getGiorniPostOperatori(e,t)}async createEvento(e){return _.createEvento(e)}async updateEvento(e,t){return _.updateEvento(e,t)}async deleteEvento(e){return _.deleteEvento(e)}async resolveInfezione(e,t){return _.resolveInfezione(e,t)}async getListaTipiIntervento(){return z.getListaTipiIntervento()}async getListaAgentiPatogeno(){return z.getListaAgentiPatogeno()}async getEventiStats(){return E.getEventiStats()}invalidateCache(){_.invalidateCache()}invalidateSelectiveCache(e,t){_.invalidateSelectiveCache(e,t)}};let S=null,D=null;async function P(){if(!S){const e=await o(()=>import("./infectionDataManager-DK5Uhw4D.js"),[]);S=e.default}return S}async function $(){if(!D){const e=await o(()=>import("./surgeryDataManager-D7d3_gaM.js"),[]);D=e.default}return D}async function T(){const[e,t]=await Promise.all([P(),$()]);return{infection:e,surgery:t}}const C=(e={})=>{let t=a.from("pazienti").select("*",{count:"exact"}).not("user_id","is",null);const{reparto:i,diagnosi:n,stato:o,search:r,infetto:s}=e;if(i&&(t=t.eq("reparto_appartenenza",i)),n&&(t=t.eq("diagnosi",n)),"attivo"===o&&(t=t.is("data_dimissione",null)),"dimesso"===o&&(t=t.not("data_dimissione","is",null)),console.log("Applying infection filter:",s,"as boolean:","true"===s),void 0!==s&&(t=t.eq("infetto","true"===s)),r){const e=r.trim().split(/\s+/).filter(e=>e.length>0);if(1===e.length)t=t.or(`nome.ilike.%${e[0]}%,cognome.ilike.%${e[0]}%,codice_rad.ilike.%${e[0]}%`);else if(2===e.length){const[i,a]=e;t=t.or([`nome.ilike.%${i}%`,`nome.ilike.%${a}%`,`cognome.ilike.%${i}%`,`cognome.ilike.%${a}%`,`codice_rad.ilike.%${i}%`,`codice_rad.ilike.%${a}%`].join(","))}else{const i=[];e.forEach(e=>{i.push(`nome.ilike.%${e}%`,`cognome.ilike.%${e}%`,`codice_rad.ilike.%${e}%`)}),t=t.or(i.join(","))}}return t},b={getPaginatedPatients:async(t={},i={})=>{const{page:a=0,limit:n=c,sortColumn:o="data_ricovero",sortDirection:r="desc"}=i;let s=C(t);const l=a*n,d=l+n-1;s=s.order(o,{ascending:"asc"===r}).range(l,d);const{data:u,error:p,count:h}=await s;if(p)throw p;try{const t=(u||[]).filter(e=>e&&"trasferimento_esterno"===e.tipo_dimissione).slice(0,5).map(e=>({id:e.id,codice_clinica:e.codice_clinica}));e.group("[patientApi.getPaginatedPatients] Result summary"),e.log({total:u?.length||0,count:h,externalTransfersSample:t}),e.groupEnd()}catch(g){}return{patients:u||[],totalCount:h||0}},getAllPatients:async(t={})=>{const{sortColumn:i="data_ricovero",sortDirection:a="desc"}=t;let n=C(t);n=n.order(i,{ascending:"asc"===a}).limit(5e3);const{data:o,error:r}=await n;if(r)throw r;try{const t=(o||[]).filter(e=>e&&"trasferimento_esterno"===e.tipo_dimissione).slice(0,5).map(e=>({id:e.id,codice_clinica:e.codice_clinica}));e.group("[patientApi.getAllPatients] Result sample"),e.log({total:o?.length||0,externalTransfersSample:t}),e.groupEnd()}catch(s){}return o||[]},getPatientById:async t=>{const{data:i,error:n}=await a.from("pazienti").select("*").eq("id",t).single();if(n)throw n;try{e.log("[patientApi.getPatientById] Loaded",{id:i?.id,tipo_dimissione:i?.tipo_dimissione,codice_clinica:i?.codice_clinica||null})}catch(o){}return i},createPatient:async e=>{const t={...e},{id:i,...n}=t,{data:o,error:r}=await a.from("pazienti").insert(n).select("*").single();if(r)throw r;return o},updatePatient:async(t,i)=>{try{e.group("[patientApi.updatePatient] Update payload"),e.log({id:t,codice_clinica:i?.codice_clinica??null,tipo_dimissione:i?.tipo_dimissione??null}),e.groupEnd()}catch(r){}const{data:n,error:o}=await a.from("pazienti").update(i).eq("id",t).select().single();if(o)throw o;try{e.group("[patientApi.updatePatient] Update result"),e.log({id:n?.id,tipo_dimissione:n?.tipo_dimissione??null,codice_clinica:n?.codice_clinica??null}),e.groupEnd()}catch(r){}return n},deletePatient:async e=>{const{error:t}=await a.from("pazienti").delete().eq("id",e);if(t)throw t},searchPatients:async(e,t=!1,i=50)=>{const n=e.trim().split(/\s+/).filter(e=>e.length>0);let o=a.from("pazienti").select("id, nome, cognome, codice_rad, data_ricovero, diagnosi, reparto_appartenenza").not("user_id","is",null);if(1===n.length)o=o.or(`nome.ilike.%${n[0]}%,cognome.ilike.%${n[0]}%,codice_rad.ilike.%${n[0]}%`);else if(2===n.length){const[e,t]=n;o=o.or([`nome.ilike.%${e}%`,`nome.ilike.%${t}%`,`cognome.ilike.%${e}%`,`cognome.ilike.%${t}%`,`codice_rad.ilike.%${e}%`,`codice_rad.ilike.%${t}%`].join(","))}else{const e=[];n.forEach(t=>{e.push(`nome.ilike.%${t}%`,`cognome.ilike.%${t}%`,`codice_rad.ilike.%${t}%`)}),o=o.or(e.join(","))}o=o.order("cognome"),t&&(o=o.is("data_dimissione",null));const{data:r,error:s}=await o.limit(Math.max(1,Number(i)||50));if(s)throw s;return r||[]},getStatsData:async()=>{const{data:e,error:t}=await a.from("pazienti").select("data_dimissione, diagnosi, reparto_appartenenza").not("user_id","is",null);if(t)throw t;return e||[]}};const L=new class{async exportPatients(a={}){try{i.getState().setLoading(!0);const e=await b.getAllPatients(a);if(this._logExportSample(e,"CSV"),!e||0===e.length)return r("Nessun dato da esportare per i filtri selezionati."),void 0;const t=l(e);d(t,"esportazione_pazienti.csv"),n(`Esportati ${e.length} pazienti con successo!`)}catch(o){e.error("Errore nell'esportazione:",o);const i=o instanceof Error?o.message:String(o);throw i.includes("network")||i.includes("fetch")?t("Impossibile connettersi al server. Verifica la tua connessione."):i.includes("permission")||i.includes("autorizzato")?t("Non hai i permessi per esportare questi dati."):t(`Impossibile esportare i dati: ${i}`),o}finally{i.getState().setLoading(!1)}}async exportPatientsJSON(a={}){try{i.getState().setLoading(!0);const e=await b.getAllPatients(a);if(!e||0===e.length)return r("Nessun dato da esportare per i filtri selezionati."),void 0;const t=u(e);p(t,"esportazione_pazienti.json"),n(`Esportati ${e.length} pazienti in JSON con successo!`)}catch(o){e.error("Errore nell'esportazione JSON:",o);const i=o instanceof Error?o.message:String(o);throw i.includes("network")||i.includes("fetch")?t("Impossibile connettersi al server. Verifica la tua connessione."):i.includes("permission")||i.includes("autorizzato")?t("Non hai i permessi per esportare questi dati."):t(`Impossibile esportare i dati in JSON: ${i}`),o}finally{i.getState().setLoading(!1)}}_logExportSample(t,i){try{const a=(t||[]).filter(e=>e&&"trasferimento_esterno"===e.tipo_dimissione).slice(0,5).map(e=>({id:e.id,codice_clinica:e.codice_clinica}));e.group(`[PatientExportService.export${i}] Export dataset sample`),e.log({total:t?.length||0,sampleExternalTransfers:a}),e.groupEnd()}catch(a){}}};const A=new class{transactionLogs;maxLogRetention;cleanupInterval;constructor(){this.transactionLogs=new Map,this.maxLogRetention=864e5,this.cleanupInterval=36e5,this.startLogCleanup()}generateTransactionId(){return`tx_${Date.now()}_${Math.random().toString(36).substr(2,9)}`}initializeTransactionLog(t,i,a={}){const n={id:t,type:i,status:"started",steps:[],initialData:this.sanitizeLogData(a),createdAt:Date.now(),completedAt:null};return this.transactionLogs.set(t,n),e.log(`Transazione ${t} inizializzata: ${i}`),n}logTransactionStep(t,i,a,n={}){const o=this.transactionLogs.get(t);if(!o)return e.error(`Tentativo di loggare step per transazione inesistente: ${t}`),void 0;const r={step:i,status:a,data:this.sanitizeLogData(n),timestamp:Date.now()};o.steps.push(r),e.log(`Transazione ${t} - Step ${i}: ${a}`)}completeTransactionLog(t,i){const a=this.transactionLogs.get(t);if(!a)return e.error(`Tentativo di completare transazione inesistente: ${t}`),void 0;a.status=i,a.completedAt=Date.now(),e.log(`Transazione ${t} completata con stato: ${i}`)}getTransactionLog(e){return this.transactionLogs.get(e)||null}getAllTransactionLogs(){return Array.from(this.transactionLogs.values())}getTransactionStats(){const e=Array.from(this.transactionLogs.values());return{total:e.length,byStatus:e.reduce((e,t)=>(e[t.status]=(e[t.status]||0)+1,e),{}),byType:e.reduce((e,t)=>(e[t.type]=(e[t.type]||0)+1,e),{}),oldestLog:e.length>0?Math.min(...e.map(e=>e.createdAt)):null,newestLog:e.length>0?Math.max(...e.map(e=>e.createdAt)):null}}sanitizeLogData(e){if(!e||"object"!=typeof e)return e;const t={...e};return["password","token","auth","secret","nome","cognome","codice_fiscale","codice_rad","telefono","email","indirizzo","indirizzo_residenza","citta","cap","note","descrizione"].forEach(e=>{t[e]&&(t[e]="[REDACTED]")}),t}startLogCleanup(){setInterval(()=>{this.cleanupOldLogs()},this.cleanupInterval)}cleanupOldLogs(){const t=Date.now();let i=0;for(const[e,a]of this.transactionLogs.entries())t-a.createdAt>this.maxLogRetention&&(this.transactionLogs.delete(e),i++);i>0&&e.log(`Cleanup log transazioni: ${i} log rimossi`)}};const R=new class{async createPatientStep(t,i=!1){try{const a={...t,infetto:i,data_infezione:null},n=await b.createPatient(a);if(!n||!n.id)throw new Error("Creazione paziente fallita: nessun ID restituito");return e.log(`Paziente creato con successo: ID ${n.id}`),n}catch(a){throw e.error("Errore nella creazione paziente:",a),new Error(`Fallimento creazione paziente: ${a?.message??String(a)}`)}}async createInfectionEventStep(t,i){try{const a={paziente_id:t,tipo_evento:"infezione",data_evento:i.data_evento,agente_patogeno_id:i.agente_patogeno_id||null,tipo_patogeno:i.tipo_patogeno||null,descrizione:i.descrizione||null,data_fine_evento:i.data_fine_evento||null},n=await I.createEvento(a);if(!n||!n.id)throw new Error("Creazione evento infezione fallita: nessun ID restituito");return e.log(`Evento infezione creato con successo: ID ${n.id}`),n}catch(a){throw e.error("Errore nella creazione evento infezione:",a),new Error(`Fallimento creazione evento infezione: ${a?.message??String(a)}`)}}async createSurgeryEventStep(t,i){try{const a={paziente_id:t,tipo_evento:"intervento",data_evento:i.data_evento,tipo_intervento_id:i.tipo_intervento_id,descrizione:i.descrizione||null,data_fine_evento:null},n=await I.createEvento(a);if(!n||!n.id)throw new Error("Creazione evento intervento fallita: nessun ID restituito");return e.log(`Evento intervento creato con successo: ID ${n.id}`),n}catch(a){throw e.error("Errore nella creazione evento intervento:",a),new Error(`Fallimento creazione evento intervento: ${a?.message??String(a)}`)}}async verifySynchronizationStep(t){try{await new Promise(e=>setTimeout(e,500));const i=await b.getPatientById(t);if(!i)throw new Error("Paziente non trovato durante verifica sincronizzazione");i.infetto||e.warn(`Paziente ${t}: flag infetto non sincronizzato correttamente`),i.data_infezione||e.warn(`Paziente ${t}: data_infezione non sincronizzata correttamente`),e.log(`Sincronizzazione verificata per paziente ${t}`)}catch(i){e.error("Errore nella verifica sincronizzazione:",i),e.warn("Continuando nonostante errore di verifica sincronizzazione")}}async rollbackPatientCreation(t){try{await b.deletePatient(t),e.log(`Rollback completato: paziente ${t} eliminato`)}catch(i){throw e.error(`Errore nel rollback paziente ${t}:`,i),new Error(`Rollback fallito: ${i?.message??String(i)}`)}}};const q=new class{async handleTransactionFailure(t,i){const a=A.getTransactionLog(t);if(!a)return e.error(`Log transazione ${t} non trovato`),void 0;A.logTransactionStep(t,"handle_failure","started",{error:i.message});const n=a.steps.filter(e=>"completed"===e.status),o=n.some(e=>"create_patient"===e.step),r=n.some(e=>"create_infection_event"===e.step);try{r&&!o?await this.handleInconsistentState(t,i):o&&!r?await this.handlePatientCreatedInfectionFailed(t,i):o?await this.handleLateFailure(t,i):await this.handleEarlyFailure(t,i),A.completeTransactionLog(t,"failed")}catch(s){e.error(`Errore durante gestione fallimento transazione ${t}:`,s),A.completeTransactionLog(t,"rollback_failed")}}async handlePatientCreatedInfectionFailed(e,i){const a=A.getTransactionLog(e).steps.find(e=>"create_patient"===e.step&&"completed"===e.status);if(!a||!a.data||!a.data.patientId)throw new Error("ID paziente non trovato nel log della transazione");const n=a.data.patientId;throw A.logTransactionStep(e,"recovery_options_presented","completed",{type:"error",title:"Creazione Incompleta",message:`Paziente creato con successo, ma creazione evento infezione fallita. \n                Paziente ID: ${n}\n                Errore: ${i.message}`,actions:[{label:"Riprova Evento Infezione",action:"retry_infection",data:{transactionId:e,patientId:n}},{label:"Completa Manualmente",action:"complete_manually",data:{patientId:n}},{label:"Elimina Paziente",action:"rollback_patient",data:{patientId:n},variant:"danger"}]}),t("Paziente creato ma evento infezione fallito. Controlla la sezione notifiche per le opzioni di recovery.",{persistent:!0}),new Error(`Transazione parzialmente completata. Paziente ID: ${n}. ${i.message}`)}async handleEarlyFailure(e,i){A.logTransactionStep(e,"early_failure_handled","completed",{message:"Nessun rollback necessario - nessuna risorsa creata"}),t(`Errore nella creazione: ${i.message}`)}async handleLateFailure(e,t){A.logTransactionStep(e,"late_failure_handled","completed",{message:"Transazione sostanzialmente completata nonostante errore finale",originalError:t.message}),r(`Paziente e evento infezione creati, ma si è verificato un errore nella verifica finale: ${t.message}`)}async handleInconsistentState(e,i){A.logTransactionStep(e,"inconsistent_state_detected","completed",{message:"Stato inconsistente rilevato - richiede intervento manuale",originalError:i.message}),t(`Stato inconsistente rilevato. Contattare l'amministratore. Transazione ID: ${e}`,{persistent:!0})}async retryInfectionCreation(t,i,a){const o=`${t}_retry_${Date.now()}`;try{A.initializeTransactionLog(o,"retry_infection_creation",{originalTransactionId:t,patientId:i,infectionData:a});const e=await R.createInfectionEventStep(i,a);return await R.verifySynchronizationStep(i),A.completeTransactionLog(o,"completed"),n("Evento infezione creato con successo!"),e}catch(r){throw A.completeTransactionLog(o,"failed"),e.error("Errore nel retry creazione infezione:",r),r}}};const N=new class{async validatePatientData(e){if(!e||"object"!=typeof e)throw new Error("Dati paziente non validi");const t=["nome","cognome","data_ricovero"];for(const i of t)if(!e[i]||""===e[i].toString().trim())throw new Error(`Campo paziente obbligatorio mancante: ${i}`)}async validateInfectionData(e){if(!e||"object"!=typeof e)throw new Error("Dati infezione non validi");const t=["data_evento"];for(const i of t)if(!e[i]||""===e[i].toString().trim())throw new Error(`Campo infezione obbligatorio mancante: ${i}`);await this.validateEventDate(e.data_evento,"evento infezione")}async validateSurgeryData(e){if(!e||"object"!=typeof e)throw new Error("Dati intervento non validi");const t=["data_evento","tipo_intervento"];for(const i of t)if(!e[i]||""===e[i].toString().trim())throw new Error(`Campo intervento obbligatorio mancante: ${i}`);if(await this.validateEventDate(e.data_evento,"evento intervento"),e.has_infection&&e.data_infezione){const t=new Date(e.data_infezione),i=new Date(e.data_evento);if(isNaN(t.getTime()))throw new Error("Data infezione associata non valida");if(t<i)throw new Error("La data dell'infezione non può essere precedente all'intervento")}}async validateEventDate(e,t){const i=new Date(e),a=new Date;if(a.setHours(23,59,59,999),isNaN(i.getTime()))throw new Error(`Data ${t} non valida`);if(i>a)throw new Error(`La data dell'${t} non può essere nel futuro`)}async validateTransactionData(t,i,a){switch(await this.validatePatientData(t),a){case"infection":await this.validateInfectionData(i);break;case"surgery":await this.validateSurgeryData(i);break;default:throw new Error(`Tipo evento non supportato: ${a}`)}e.log(`Validazione dati transazione ${a} completata con successo`)}};const x=new class{async executeTransaction(t){const a=A.generateTransactionId();try{A.initializeTransactionLog(a,t.type,t.data),i.getState().setLoading(!0),await this.validateTransaction(a,t);const e=await this.createPatient(a,t),o=await this.createEvents(a,t,e.id);return await this.verifyTransaction(a,e.id),A.completeTransactionLog(a,"completed"),n(t.successMessage),this.formatResult(a,e,o)}catch(o){throw e.error(`Errore nella transazione ${a}:`,o),await q.handleTransactionFailure(a,o),o}finally{i.getState().setLoading(!1)}}async validateTransaction(e,t){A.logTransactionStep(e,"validation","started"),await N.validatePatientData(t.data.patientData);for(const i of t.events)await N.validateTransactionData(t.data.patientData,t.data[i.dataKey],i.type);A.logTransactionStep(e,"validation","completed",{message:"Dati validati con successo"})}async createPatient(e,t){A.logTransactionStep(e,"create_patient","started");const i=t.events.some(e=>"infection"===e.type),a=await R.createPatientStep(t.data.patientData,i);return A.logTransactionStep(e,"create_patient","completed",{patientId:a.id}),a}async createEvents(e,t,i){const a={};for(const n of t.events){const o=`create_${n.type}_event`;let r;switch(A.logTransactionStep(e,o,"started"),n.type){case"infection":r=await R.createInfectionEventStep(i,t.data[n.dataKey]);break;case"surgery":r=await R.createSurgeryEventStep(i,t.data[n.dataKey]);break;default:throw new Error(`Tipo evento non supportato: ${n.type}`)}a[n.resultKey]=r,A.logTransactionStep(e,o,"completed",{eventId:r.id})}if(t.data.surgeryData?.has_infection&&t.data.surgeryData?.data_infezione){const n="create_infection_event";A.logTransactionStep(e,n,"started");const o={data_evento:t.data.surgeryData.data_infezione,agente_patogeno:t.data.surgeryData.agente_patogeno,descrizione:t.data.surgeryData.descrizione_infezione},r=await R.createInfectionEventStep(i,o);a.infectionEvent=r,A.logTransactionStep(e,n,"completed",{eventId:r.id})}return a}async verifyTransaction(e,t){A.logTransactionStep(e,"verify_synchronization","started"),await R.verifySynchronizationStep(t),A.logTransactionStep(e,"verify_synchronization","completed")}formatResult(e,t,i){return{success:!0,transactionId:e,patient:t,...i,message:"Transazione completata con successo"}}};const k=new class{async executePatientWithSurgeryTransaction(e,t){return x.executeTransaction({type:"patient_with_surgery",loadingMessage:"Creazione paziente e evento intervento...",successMessage:"Paziente e evento intervento creati con successo!",data:{patientData:e,surgeryData:t},events:[{type:"surgery",dataKey:"surgeryData",resultKey:"surgeryEvent"}]})}async executePatientWithSurgeryAndInfectionTransaction(e,t,i){return x.executeTransaction({type:"patient_with_surgery_and_infection",loadingMessage:"Creazione paziente, intervento e infezione...",successMessage:"Paziente, intervento e infezione creati con successo!",data:{patientData:e,surgeryData:t,infectionData:i},events:[{type:"surgery",dataKey:"surgeryData",resultKey:"surgeryEvent"},{type:"infection",dataKey:"infectionData",resultKey:"infectionEvent"}]})}async executePatientWithInfectionTransaction(e,t){return x.executeTransaction({type:"patient_with_infection",loadingMessage:"Creazione paziente e evento infezione...",successMessage:"Paziente e evento infezione creati con successo!",data:{patientData:e,infectionData:t},events:[{type:"infection",dataKey:"infectionData",resultKey:"infectionEvent"}]})}async rollbackPatientCreation(e){await R.rollbackPatientCreation(e)}async retryInfectionCreation(e,t,i){return q.retryInfectionCreation(e,t,i)}getTransactionLog(e){return A.getTransactionLog(e)}getAllTransactionLogs(){return A.getAllTransactionLogs()}getTransactionStats(){return A.getTransactionStats()}};const O=new class{async createPatientWithInfection(t,i){try{e.log("Avvio creazione paziente con infezione:",{patientName:`${t.nome} ${t.cognome}`,infectionDate:i.data_evento}),await this._validateInfectionData(i);const a=await k.executePatientWithInfectionTransaction(t,i);return(await P()).clearInfectionData(),e.log("Creazione paziente con infezione completata con successo:",{transactionId:a.transactionId,patientId:a.patient?.id,infectionEventId:a.infectionEvent?.id}),a}catch(a){throw this._handleInfectionError(a,"creazione"),a}}async handleInfectionEventCreation(t,i){try{e.log(`Creazione evento infezione per paziente ${t}`),await this._validateInfectionData(i);const a=(await I.getEventiByPaziente(t,{tipo_evento:["infezione"]})).filter(e=>!e.data_fine_evento);if(a.length>0)throw this._handleActiveInfectionConflict(a[0]),new Error("Paziente ha già un'infezione attiva");const n=await this._createInfectionEvent(t,i);return(await P()).clearInfectionData(),n}catch(a){throw this._handleInfectionError(a,"creazione evento"),a}}async forceCreateInfectionEvent(i,a){try{e.log(`Creazione forzata evento infezione per paziente ${i}`),await this._validateInfectionData(a);const t=await this._createInfectionEvent(i,a);return(await P()).clearInfectionData(),n("Nuovo evento infezione creato con successo!"),t}catch(o){e.error("Errore nella creazione forzata evento infezione:",o);const i=o instanceof Error?o.message:String(o);throw i.includes("JWT")?t("Sessione scaduta. Effettua nuovamente l'accesso."):i.includes("validation")||i.includes("valido")?t(`Dati infezione non validi: ${i}`):t(`Impossibile creare l'infezione: ${i}`),o}}async retryInfectionEventCreation(i,a,n){try{return e.log(`Retry creazione evento infezione - Transazione: ${i}, Paziente: ${a}`),await k.retryInfectionCreation(i,a,n)}catch(o){e.error("Errore nel retry creazione evento infezione:",o);const i=o instanceof Error?o.message:String(o);throw i.includes("JWT")?t("Sessione scaduta. Effettua nuovamente l'accesso."):i.includes("timeout")||i.includes("tempo")?t("Tempo scaduto. Riprova più tardi."):t(`Impossibile completare l'operazione: ${i}`),o}}async _validateInfectionData(e){const t=await P();if(t.setInfectionData(e),!t.hasValidInfectionData()){const e=t.getValidationErrors().map(e=>e.message).join(", ");throw new Error(`Dati infezione non validi: ${e}`)}}async _createInfectionEvent(t,i){const a={paziente_id:t,tipo_evento:"infezione",data_evento:i.data_evento,agente_patogeno:i.agente_patogeno||void 0,descrizione:i.descrizione||void 0,data_fine_evento:void 0},n=await I.createEvento(a);return e.log(`Evento infezione creato con successo: ID ${n.id}`),n}_handleActiveInfectionConflict(t){e.warn(`Paziente ha già un'infezione attiva dal ${t.data_evento}`),r(`Il paziente ha già un'infezione attiva dal ${t.data_evento}. Vuoi comunque creare un nuovo evento di infezione?`,{persistent:!0,actions:[{label:"Crea Comunque",action:"force_create_infection"},{label:"Annulla",action:"cancel_infection"}]})}_handleInfectionError(i,a){const n=i?.message||JSON.stringify(i);e.error(`Errore nella ${a} paziente con infezione:`,n),n.includes("Dati infezione non validi")?t(`Dati infezione non validi: ${n}`):n.includes("Transazione parzialmente completata")?e.warn("Transazione parzialmente completata - recovery options presentate"):n.includes("già un'infezione attiva")||(n.includes("non trovato")?t("Paziente non trovato. Verifica i dati e riprova."):n.includes("JWT")?t("Sessione scaduta. Effettua nuovamente l'accesso."):t(`Impossibile ${a}: ${n}`))}};const M=new class{async createPatientWithSurgery(t,i){try{e.log("Avvio creazione paziente con intervento chirurgico:",{patientName:`${t.nome} ${t.cognome}`,surgeryDate:i.data_evento,surgeryType:i.tipo_intervento}),await this._validateSurgeryData(i);const a=await k.executePatientWithSurgeryTransaction(t,i),{surgery:n}=await T();return n.clearSurgeryData(),e.log("Creazione paziente con intervento completata con successo:",{transactionId:a.transactionId,patientId:a.patient?.id,surgeryEventId:a.surgeryEvent?.id}),a}catch(a){throw this._handleSurgeryError(a,"creazione paziente con intervento"),a}}async createPatientWithSurgeryAndInfection(t,i,a){try{e.log("Avvio creazione paziente con intervento e infezione:",{patientName:`${t.nome} ${t.cognome}`,surgeryDate:i.data_evento,infectionDate:a?.data_evento||i.data_infezione});const{surgery:n,infection:o}=await T();await this._validateSurgeryData(i);let r=a;!r&&n.hasAssociatedInfection()&&(r=n.prepareInfectionEventData()),r&&this._validateInfectionData(r);const s=await k.executePatientWithSurgeryAndInfectionTransaction(t,i,r);return n.clearSurgeryData(),r&&o.clearInfectionData(),e.log("Creazione paziente con intervento e infezione completata con successo:",{transactionId:s.transactionId,patientId:s.patient?.id,surgeryEventId:s.surgeryEvent?.id,infectionEventId:s.infectionEvent?.id}),s}catch(n){throw this._handleSurgeryError(n,"creazione paziente con intervento e infezione"),n}}async _validateSurgeryData(e){const{surgery:t}=await T();if(t.setSurgeryData(e),!t.hasValidSurgeryData()){const e=t.getValidationErrors().map(e=>e.message).join(", ");throw new Error(`Dati intervento non validi: ${e}`)}}async _validateInfectionData(e){const{infection:t}=await T();if(t.setInfectionData(e),!t.hasValidInfectionData()){const e=t.getValidationErrors().map(e=>e.message).join(", ");throw new Error(`Dati infezione non validi: ${e}`)}}_handleSurgeryError(i,a){const n=i?.message||JSON.stringify(i);e.error(`Errore nella ${a}:`,n),n.includes("non validi")?t(`Dati intervento non validi: ${n}`):n.includes("Transazione parzialmente completata")?e.warn("Transazione parzialmente completata - recovery options presentate"):n.includes("JWT")?t("Sessione scaduta. Effettua nuovamente l'accesso."):t(`Impossibile ${a}: ${n}`)}};var F=(e=>(e.CLINIC_56="56",e.CLINIC_60="60",e))(F||{}),W=(e=>(e.ORDINARIA="0",e.TRASFERIMENTO="3",e.PROTETTA="6",e))(W||{}),j=(e=>(e.DIMISSIONE="dimissione",e.TRASFERIMENTO_INTERNO="trasferimento_interno",e.TRASFERIMENTO_ESTERNO="trasferimento_esterno",e.DECESSO="decesso",e))(j||{});const V={nome:"Nome",cognome:"Cognome",data_nascita:"Data Nascita",data_ricovero:"Data Ricovero",diagnosi:"Diagnosi",reparto_appartenenza:"Reparto Appartenenza",reparto_provenienza:"Reparto Provenienza",data_dimissione:"Data Dimissione",diagnosi_secondarie:"Diagnosi Secondarie",livello_assistenza:"Livello di assistenza",codice_rad:"Codice RAD",tipo_dimissione:"Tipo dimissione",reparto_destinazione:"Reparto destinazione",clinica_destinazione:"Clinica destinazione",codice_clinica:"Codice clinica",codice_dimissione:"Codice dimissione",data_infezione:"Data infezione"},K=["nome","cognome","data_nascita","data_ricovero","diagnosi","reparto_appartenenza","reparto_provenienza"],B=["data_dimissione","tipo_dimissione"],J=Object.values(j),U=Object.values(F),G=Object.values(W);function H(e){return null!=e&&("string"!=typeof e||e.trim().length>0)}function Q(e){return V[e]||e}function X(e){return e.join(", ")}const Y={isInFuture(e){const t="string"==typeof e?new Date(e):e,i=new Date;return i.setHours(23,59,59,999),t>i},isBefore:(e,t)=>("string"==typeof e?new Date(e):e)<("string"==typeof t?new Date(t):t),isAfter:(e,t)=>("string"==typeof e?new Date(e):e)>("string"==typeof t?new Date(t):t),validateRange(e,t,i){if(e&&t&&this.isAfter(t,e))throw new h(i.end,`${Q(i.end)} non può essere precedente a ${Q(i.start)}`)},validateNotFuture(e,t){if(e&&this.isInFuture(e))throw new h(t,`${Q(t)} non può essere nel futuro`)}},Z={validateInternalTransfer(e){if(!H(e.reparto_destinazione))throw new h("reparto_destinazione","Il reparto di destinazione è obbligatorio per i trasferimenti interni")},validateExternalTransfer(e){if(!H(e.clinica_destinazione))throw new h("clinica_destinazione","La clinica di destinazione è obbligatoria per i trasferimenti esterni");if(!H(e.codice_clinica))throw new h("codice_clinica","Il codice clinica è obbligatorio per i trasferimenti esterni");const t=String(e.codice_clinica);if(!U.includes(t))throw new h("codice_clinica",`Codice clinica non valido. Valori ammessi: ${X(U)}`)},validateDischargeCode(e,t){if(!H(t))return;const i=String(t);if(!G.includes(i))throw new h("codice_dimissione",`Codice dimissione non valido. Valori ammessi: ${X(G)}`);switch(e){case"dimissione":if(!["0","6"].includes(i))throw new h("codice_dimissione","Per 'dimissione' sono ammessi solo i codici 0 (ordinaria) o 6 (protetta)");break;case"trasferimento_esterno":if("3"!==i)throw new h("codice_dimissione","Per 'trasferimento_esterno' è ammesso solo il codice 3")}},validateDischargeCodeRequired(e,t){const i=["dimissione","trasferimento_esterno"].includes(e),a=["trasferimento_interno","decesso"].includes(e);if(i&&!H(t))throw new h("codice_dimissione","Il codice dimissione è obbligatorio per il tipo selezionato");if(a&&H(t))throw new h("codice_dimissione",`Per '${e}' il codice dimissione non deve essere valorizzato`)}};function ee(e){for(const t of K)if(!H(e[t]))throw new h(t,`Il campo "${Q(t)}" è obbligatorio.`);!function(e){if(e.data_nascita){const t="string"==typeof e.data_nascita?e.data_nascita:e.data_nascita.toISOString();Y.validateNotFuture(t,"data_nascita")}if(e.data_ricovero){const t="string"==typeof e.data_ricovero?e.data_ricovero:e.data_ricovero.toISOString();Y.validateNotFuture(t,"data_ricovero")}if(e.data_dimissione&&e.data_ricovero){const t="string"==typeof e.data_ricovero?e.data_ricovero:e.data_ricovero.toISOString(),i="string"==typeof e.data_dimissione?e.data_dimissione:e.data_dimissione.toISOString();Y.validateRange(t,i,{start:"data_ricovero",end:"data_dimissione"})}if(e.data_infezione){const t="string"==typeof e.data_infezione?e.data_infezione:e.data_infezione.toISOString();if(Y.validateNotFuture(t,"data_infezione"),e.data_ricovero){const i="string"==typeof e.data_ricovero?e.data_ricovero:e.data_ricovero.toISOString();Y.validateRange(i,t,{start:"data_ricovero",end:"data_infezione"})}if(e.data_dimissione){const i="string"==typeof e.data_dimissione?e.data_dimissione:e.data_dimissione.toISOString();Y.validateRange(t,i,{start:"data_infezione",end:"data_dimissione"})}}}(e),function(e){if(!e)return;if(e.length>11)throw new h("codice_rad","Il codice RAD non può superare i 11 caratteri")}(e.codice_rad),function(e){const t=e.tipo_dimissione;if(!t)return;if(!J.includes(t))throw new h("tipo_dimissione",`Tipo dimissione non valido. Valori ammessi: ${X(J)}`);"trasferimento_interno"===t?Z.validateInternalTransfer(e):"trasferimento_esterno"===t&&Z.validateExternalTransfer(e);Z.validateDischargeCodeRequired(t,e.codice_dimissione),H(e.codice_dimissione)&&Z.validateDischargeCode(t,e.codice_dimissione)}(e)}function te(e){for(const t of B)if(!H(e[t]))throw new h(t,`Il campo "${Q(t)}" è obbligatorio.`);if(!J.includes(e.tipo_dimissione))throw new h("tipo_dimissione",`Tipo dimissione non valido. Valori ammessi: ${X(J)}`);!function(e){if(e.data_dimissione){Y.validateNotFuture(e.data_dimissione,"data_dimissione")}}(e),function(e){const t=e.tipo_dimissione;"trasferimento_interno"===t?Z.validateInternalTransfer(e):"trasferimento_esterno"===t&&Z.validateExternalTransfer(e);Z.validateDischargeCodeRequired(t,e.codice_dimissione),H(e.codice_dimissione)&&Z.validateDischargeCode(t,e.codice_dimissione)}(e)}const ie=a,ae=b;const ne=new class{cache=new Map;cacheTimeout=3e5;constructor(){this.initCache()}initCache(e=this.cacheTimeout){this.cache=new Map,this.cacheTimeout=e}getCached(e){const t=this.cache.get(e);return t&&Date.now()-t.timestamp<this.cacheTimeout?t.data:null}setCache(e,t){const i={data:t,timestamp:Date.now()};this.cache.set(e,i)}deleteCache(e){this.cache.delete(e)}invalidateCache(){this.cache.clear()}async withLoading(t,a){e.log(`[PatientService] ${t}`),i.getState().setLoading(!0);try{return await a()}finally{i.getState().setLoading(!1)}}handleError(i,a={}){const n=a.operation??"operazione";e.error(`Errore in ${n}:`,i);const o=i instanceof Error?i.message:String(i);if(a.useDbErrorMapping){const e=s(i,a);t(e)}else t(`Errore ${n}: ${o}`)}showSuccess(e){n(e)}async getPatients(e={},t={}){try{const{page:i=0,limit:a=c,sortColumn:n,sortDirection:o}=t,r={page:i,limit:a,sortColumn:n??"data_ricovero",sortDirection:o??"desc"},{patients:s,totalCount:l}=await ae.getPaginatedPatients(e,r);this.logPatientsSample(s,{page:i,limit:a,totalCount:l});const d=i;return{patients:s,totalCount:l,currentPage:d,totalPages:a>0?Math.ceil(l/a):0,hasNextPage:a>0&&(d+1)*a<l,hasPrevPage:d>0}}catch(i){throw this.handleError(i,{operation:"caricamento pazienti"}),i}}async getPatientsWithClinicalEvents(t={},i={}){try{const{page:a=0,limit:n=c,sortColumn:o,sortDirection:r}=i,s={page:a,limit:n,sortColumn:o??"data_ricovero",sortDirection:r??"desc"},{patients:l,totalCount:d}=await ae.getPaginatedPatients(t,s);if(l.length>0){const t=l.map(e=>e.id),{data:i,error:a}=await ie.from("eventi_clinici").select("*").in("paziente_id",t).order("data_evento",{ascending:!1});if(a)e.warn("⚠️ Errore nel caricamento eventi clinici:",a);else{const e=i.reduce((e,t)=>(e[t.paziente_id]||(e[t.paziente_id]=[]),e[t.paziente_id].push(t),e),{});l.forEach(t=>{t.eventi_clinici=e[t.id]||[]})}}this.logPatientsSample(l,{page:a,limit:n,totalCount:d});const u=a;return{patients:l,totalCount:d,currentPage:u,totalPages:n>0?Math.ceil(d/n):0,hasNextPage:n>0&&(u+1)*n<d,hasPrevPage:u>0}}catch(a){throw this.handleError(a,{operation:"caricamento pazienti con eventi clinici"}),a}}async getPatientById(t){const i=`patient_${t}`,a=this.getCached(i);if(a)return a;try{const a=await ae.getPatientById(t);return a&&(this.setCache(i,a),e.log("[PatientService.getPatientById] Received record",{id:a.id,tipo_dimissione:a.tipo_dimissione,codice_clinica:a.codice_clinica??null})),a}catch(n){throw this.handleError(n,{operation:"caricamento paziente"}),n}}async createPatient(e){return this.withLoading("Creazione paziente...",async()=>{ee(e);const{data:{user:t}}=await ie.auth.getUser();if(!t)throw new Error("Utente non autenticato");const i={...Object.entries(e).filter(([e,t])=>!e.startsWith("_")&&void 0!==t).reduce((e,[t,i])=>(e[t]=i,e),{}),user_id:t.id,data_dimissione:null,tipo_dimissione:null,codice_dimissione:null,infetto:Boolean(e.infetto)};try{const e=await ae.createPatient(i);return this.invalidateCache(),this.showSuccess("Paziente creato con successo!"),e}catch(a){throw this.handleError(a,{entity:"paziente",operation:"creazione",useDbErrorMapping:!0}),a}})}async updatePatient(e,t,i={showNotification:!0}){return this.withLoading("Aggiornamento paziente...",async()=>{try{const a=Object.entries(t).filter(([e,t])=>!e.startsWith("_")&&void 0!==t).reduce((e,[t,i])=>(e[t]=i,e),{}),n=await ae.updatePatient(e,a);return this.deleteCache(`patient_${e}`),!1!==i.showNotification&&this.showSuccess("Paziente aggiornato con successo!"),n}catch(a){throw this.handleError(a,{entity:"paziente",operation:"aggiornamento",useDbErrorMapping:!0}),a}})}async deletePatient(e){return this.withLoading("Eliminazione paziente...",async()=>{try{await ae.deletePatient(e),this.deleteCache(`patient_${e}`),this.invalidateCache(),this.showSuccess("Paziente eliminato con successo!")}catch(t){throw this.handleError(t,{operation:"eliminazione"}),t}})}async dischargePatient(e,t=null){try{const i=t??(new Date).toISOString().split("T")[0];await this.updatePatient(e,{data_dimissione:i},{showNotification:!1}),this.showSuccess("Paziente dimesso con successo!")}catch(i){throw this.handleError(i,{operation:"dimissione"}),i}}async dischargePatientWithTransfer(e,t){return this.withLoading("Dimissione paziente...",async()=>{try{te(t);const i=await ae.updatePatient(e,t);this.deleteCache(`patient_${e}`);return this.showSuccess(`Paziente ${"dimissione"===t.tipo_dimissione?"dimesso":"trasferito"} con successo!`),i}catch(i){throw this.handleError(i,{operation:"dimissione"}),i}})}async reactivatePatient(e){try{const t={data_dimissione:null,tipo_dimissione:null,reparto_destinazione:null,clinica_destinazione:null,codice_clinica:null,codice_dimissione:null};await this.updatePatient(e,t,{showNotification:!1}),this.showSuccess("Paziente riattivato con successo!")}catch(t){throw this.handleError(t,{operation:"riattivazione"}),t}}async searchPatients(e,t=!1,i=50){try{return await ae.searchPatients(e,t,i)}catch(a){throw this.handleError(a,{operation:"ricerca pazienti"}),a}}async exportPatients(e={}){await L.exportPatients(e)}async exportPatientsJSON(e={}){await L.exportPatientsJSON(e)}async getPatientStats(){try{const e=await ae.getStatsData(),t={total:e.length,active:e.filter(e=>!e.data_dimissione).length,discharged:e.filter(e=>e.data_dimissione).length,byDiagnosis:{},byDepartment:{}};return e.forEach(e=>{e.diagnosi&&(t.byDiagnosis[e.diagnosi]=(t.byDiagnosis[e.diagnosi]||0)+1),e.reparto_appartenenza&&(t.byDepartment[e.reparto_appartenenza]=(t.byDepartment[e.reparto_appartenenza]||0)+1)}),t}catch(t){throw e.error("Errore nel caricamento statistiche:",t),t}}async getTransferHistory(e){try{const t=await this.getPatientById(e);if(!t)throw new Error("Paziente non trovato");const i=[];return t.data_dimissione&&t.tipo_dimissione&&i.push({data:t.data_dimissione,tipo:t.tipo_dimissione,reparto_destinazione:t.reparto_destinazione,clinica_destinazione:t.clinica_destinazione,codice_clinica:t.codice_clinica,codice_dimissione:t.codice_dimissione}),i}catch(t){throw this.handleError(t,{operation:"caricamento cronologia trasferimenti"}),t}}async createPatientWithInfection(e,t){ee(e);const i=await O.createPatientWithInfection(e,t);return this.invalidateCache(),i}async handleInfectionEventCreation(e,t){const i=await O.handleInfectionEventCreation(e,t);return this.deleteCache(`patient_${e}`),i}async retryInfectionEventCreation(e,t,i){return O.retryInfectionEventCreation(e,t,i)}async rollbackPatientCreation(e){await k.rollbackPatientCreation(e),this.deleteCache(`patient_${e}`),this.invalidateCache()}async forceCreateInfectionEvent(e,t){const i=await O.forceCreateInfectionEvent(e,t);return this.deleteCache(`patient_${e}`),i}async createPatientWithSurgery(e,t){ee(e);const i=await M.createPatientWithSurgery(e,t);return this.invalidateCache(),i}async createPatientWithSurgeryAndInfection(e,t,i){ee(e);const a=await M.createPatientWithSurgeryAndInfection(e,t,i);return this.invalidateCache(),a}getTransactionStats(){return k.getTransactionStats()}getTransactionLog(e){return k.getTransactionLog(e)}async handleTemporaryEventsCreation(e,t){return this.withLoading("Salvataggio eventi clinici...",async()=>{try{for(const i of t){const t={...i};delete t.id,delete t.isTemporary,t.paziente_id=e,await I.createEvento(t)}this.showSuccess(`${t.length} eventi clinici salvati con successo`)}catch(i){throw this.handleError(i,{operation:"salvataggio eventi clinici"}),i}})}async createPatientWithTemporaryEvents(e,t){return this.withLoading("Creazione paziente ed eventi clinici...",async()=>{try{const i=await ae.createPatient(e);for(const e of t){const t={...e};delete t.id,delete t.isTemporary,t.paziente_id=i.id,await I.createEvento(t)}return this.showSuccess(`Paziente e ${t.length} eventi clinici creati con successo`),{patient:i,events:t,success:!0}}catch(i){throw this.handleError(i,{operation:"creazione paziente e eventi"}),i}})}logPatientsSample(t,i){try{const a=(t||[]).filter(e=>e&&"trasferimento_esterno"===e.tipo_dimissione).slice(0,5).map(e=>({id:e.id,codice_clinica:e.codice_clinica}));e.group("[patientService.getPatients] Result summary"),e.log({...i,sampleExternalTransfers:a}),e.groupEnd()}catch{}}};export{$ as a,T as b,I as e,P as g,ne as p,y as r};
