import{_ as e}from"./supabase-AmyKTmiY.js";import{e as t,v as n,m as a,a as i,i as o}from"./infectionDataManager-D3FsSUSN.js";import{l as r,s,b as c,n as l}from"./index-CgAkcUkG.js";import"./vendor-BU6HxVpN.js";const d=(e={})=>{let t=s.from("pazienti").select("*",{count:"exact"}).not("user_id","is",null);const{reparto:n,diagnosi:a,stato:i,search:o}=e;return n&&(t=t.eq("reparto_appartenenza",n)),a&&(t=t.eq("diagnosi",a)),"attivo"===i&&(t=t.is("data_dimissione",null)),"dimesso"===i&&(t=t.not("data_dimissione","is",null)),o&&(t=t.or(`nome.ilike.%${o}%,cognome.ilike.%${o}%`)),t},p=async(e={},t={})=>{const{page:n=0,limit:a=10,sortColumn:i="data_ricovero",sortDirection:o="desc"}=t;let s=d(e);const c=n*a,l=c+a-1;s=s.order(i,{ascending:"asc"===o}).range(c,l);const{data:p,error:g,count:h}=await s;if(g)throw g;try{const e=(p||[]).filter(e=>e&&"trasferimento_esterno"===e.tipo_dimissione).slice(0,5).map(e=>({id:e.id,codice_clinica:e.codice_clinica}));r.group("[patientApi.getPaginatedPatients] Result summary"),r.log({total:p?.length||0,count:h,externalTransfersSample:e}),r.groupEnd()}catch(z){}return{patients:p||[],totalCount:h||0}},g=async(e={})=>{const{sortColumn:t="data_ricovero",sortDirection:n="desc"}=e;let a=d(e);a=a.order(t,{ascending:"asc"===n});const{data:i,error:o}=await a;if(o)throw o;try{const e=(i||[]).filter(e=>e&&"trasferimento_esterno"===e.tipo_dimissione).slice(0,5).map(e=>({id:e.id,codice_clinica:e.codice_clinica}));r.group("[patientApi.getAllPatients] Result sample"),r.log({total:i?.length||0,externalTransfersSample:e}),r.groupEnd()}catch(s){}return i||[]},h=async e=>{const{data:t,error:n}=await s.from("pazienti").select("*").eq("id",e).single();if(n)throw n;try{r.log("[patientApi.getPatientById] Loaded",{id:t?.id,tipo_dimissione:t?.tipo_dimissione,codice_clinica:t?.codice_clinica||null})}catch(a){}return t},z=async e=>{const{data:t,error:n}=await s.from("pazienti").insert([e]).select().single();if(n)throw n;return t},m=async(e,t)=>{try{r.group("[patientApi.updatePatient] Update payload"),r.log({id:e,codice_clinica:t?.codice_clinica??null,tipo_dimissione:t?.tipo_dimissione??null}),r.groupEnd()}catch(i){}const{data:n,error:a}=await s.from("pazienti").update(t).eq("id",e).select().single();if(a)throw a;try{r.group("[patientApi.updatePatient] Update result"),r.log({id:n?.id,tipo_dimissione:n?.tipo_dimissione??null,codice_clinica:n?.codice_clinica??null}),r.groupEnd()}catch(i){}return n},u=async e=>{const{error:t}=await s.from("pazienti").delete().eq("id",e);if(t)throw t},f=async(e,t=!1)=>{let n=s.from("pazienti").select("id, nome, cognome, codice_rad, data_ricovero, diagnosi, reparto_appartenenza").not("user_id","is",null).or(`nome.ilike.%${e}%,cognome.ilike.%${e}%,codice_rad.ilike.%${e}%`).order("cognome");t&&(n=n.is("data_dimissione",null));const{data:a,error:i}=await n;if(i)throw i;return a||[]},v=async()=>{const{data:e,error:t}=await s.from("pazienti").select("data_dimissione, diagnosi, reparto_appartenenza").not("user_id","is",null);if(t)throw t;return e||[]};const _=new class{constructor(){this.transactionLogs=new Map,this.maxLogRetention=864e5,this.cleanupInterval=36e5,this.startLogCleanup()}async executePatientWithSurgeryTransaction(e,t){const n=this.generateTransactionId();try{this.initializeTransactionLog(n,"patient_with_surgery",{patientData:this.sanitizeLogData(e),surgeryData:this.sanitizeLogData(t)}),c.setLoading(!0,"Creazione paziente e evento intervento..."),await this.validateSurgeryTransactionData(e,t),this.logTransactionStep(n,"validation","completed",{message:"Dati validati con successo"}),this.logTransactionStep(n,"create_patient","started");const a=await this.createPatientStep(e,!1);this.logTransactionStep(n,"create_patient","completed",{patientId:a.id}),this.logTransactionStep(n,"create_surgery_event","started");const i=await this.createSurgeryEventStep(a.id,t);this.logTransactionStep(n,"create_surgery_event","completed",{eventId:i.id});let o=null;if(t.has_infection&&t.data_infezione){this.logTransactionStep(n,"create_infection_event","started");const e={data_evento:t.data_infezione,agente_patogeno:t.agente_patogeno,descrizione:t.descrizione_infezione};o=await this.createInfectionEventStep(a.id,e),this.logTransactionStep(n,"create_infection_event","completed",{eventId:o.id})}return this.logTransactionStep(n,"verify_synchronization","started"),await this.verifySynchronizationStep(a.id),this.logTransactionStep(n,"verify_synchronization","completed"),this.completeTransactionLog(n,"completed"),l.success("Paziente e evento intervento creati con successo!"),{success:!0,transactionId:n,patient:a,surgeryEvent:i,infectionEvent:o,message:"Transazione completata con successo"}}catch(a){throw r.error(`Errore nella transazione ${n}:`,a),await this.handleTransactionFailure(n,a),a}finally{c.setLoading(!1)}}async executePatientWithSurgeryAndInfectionTransaction(e,t,n){const a=this.generateTransactionId();try{this.initializeTransactionLog(a,"patient_with_surgery_and_infection",{patientData:this.sanitizeLogData(e),surgeryData:this.sanitizeLogData(t),infectionData:this.sanitizeLogData(n)}),c.setLoading(!0,"Creazione paziente, intervento e infezione..."),await this.validateSurgeryTransactionData(e,t),await this.validateTransactionData(e,n),this.logTransactionStep(a,"validation","completed",{message:"Dati validati con successo"}),this.logTransactionStep(a,"create_patient","started");const i=await this.createPatientStep(e,!0);this.logTransactionStep(a,"create_patient","completed",{patientId:i.id}),this.logTransactionStep(a,"create_surgery_event","started");const o=await this.createSurgeryEventStep(i.id,t);this.logTransactionStep(a,"create_surgery_event","completed",{eventId:o.id}),this.logTransactionStep(a,"create_infection_event","started");const r=await this.createInfectionEventStep(i.id,n);return this.logTransactionStep(a,"create_infection_event","completed",{eventId:r.id}),this.logTransactionStep(a,"verify_synchronization","started"),await this.verifySynchronizationStep(i.id),this.logTransactionStep(a,"verify_synchronization","completed"),this.completeTransactionLog(a,"completed"),l.success("Paziente, intervento e infezione creati con successo!"),{success:!0,transactionId:a,patient:i,surgeryEvent:o,infectionEvent:r,message:"Transazione completata con successo"}}catch(i){throw r.error(`Errore nella transazione ${a}:`,i),await this.handleTransactionFailure(a,i),i}finally{c.setLoading(!1)}}async executePatientWithInfectionTransaction(e,t){const n=this.generateTransactionId();try{this.initializeTransactionLog(n,"patient_with_infection",{patientData:this.sanitizeLogData(e),infectionData:this.sanitizeLogData(t)}),c.setLoading(!0,"Creazione paziente e evento infezione..."),await this.validateTransactionData(e,t),this.logTransactionStep(n,"validation","completed",{message:"Dati validati con successo"}),this.logTransactionStep(n,"create_patient","started");const a=await this.createPatientStep(e,!0);this.logTransactionStep(n,"create_patient","completed",{patientId:a.id}),this.logTransactionStep(n,"create_infection_event","started");const i=await this.createInfectionEventStep(a.id,t);return this.logTransactionStep(n,"create_infection_event","completed",{eventId:i.id}),this.logTransactionStep(n,"verify_synchronization","started"),await this.verifySynchronizationStep(a.id),this.logTransactionStep(n,"verify_synchronization","completed"),this.completeTransactionLog(n,"completed"),l.success("Paziente e evento infezione creati con successo!"),{success:!0,transactionId:n,patient:a,infectionEvent:i,message:"Transazione completata con successo"}}catch(a){throw r.error(`Errore nella transazione ${n}:`,a),await this.handleTransactionFailure(n,a),a}finally{c.setLoading(!1)}}async validateSurgeryTransactionData(e,t){if(!e||"object"!=typeof e)throw new Error("Dati paziente non validi");const n=["nome","cognome","data_ricovero"];for(const r of n)if(!e[r]||""===e[r].toString().trim())throw new Error(`Campo paziente obbligatorio mancante: ${r}`);if(!t||"object"!=typeof t)throw new Error("Dati intervento non validi");const a=["data_evento","tipo_intervento"];for(const r of a)if(!t[r]||""===t[r].toString().trim())throw new Error(`Campo intervento obbligatorio mancante: ${r}`);const i=new Date(t.data_evento),o=new Date;if(o.setHours(23,59,59,999),isNaN(i.getTime()))throw new Error("Data evento intervento non valida");if(i>o)throw new Error("La data dell'evento di intervento non può essere nel futuro");if(t.has_infection&&t.data_infezione){const e=new Date(t.data_infezione);if(isNaN(e.getTime()))throw new Error("Data infezione associata non valida");if(e<i)throw new Error("La data dell'infezione non può essere precedente all'intervento")}r.log("Validazione dati transazione intervento completata con successo")}async validateTransactionData(e,t){if(!e||"object"!=typeof e)throw new Error("Dati paziente non validi");const n=["nome","cognome","data_ricovero"];for(const r of n)if(!e[r]||""===e[r].toString().trim())throw new Error(`Campo paziente obbligatorio mancante: ${r}`);if(!t||"object"!=typeof t)throw new Error("Dati infezione non validi");const a=["data_evento"];for(const r of a)if(!t[r]||""===t[r].toString().trim())throw new Error(`Campo infezione obbligatorio mancante: ${r}`);const i=new Date(t.data_evento),o=new Date;if(o.setHours(23,59,59,999),isNaN(i.getTime()))throw new Error("Data evento infezione non valida");if(i>o)throw new Error("La data dell'evento di infezione non può essere nel futuro");r.log("Validazione dati transazione completata con successo")}async createPatientStep(e,t=!1){try{const n={...e,infetto:t,data_infezione:null},a=await z(n);if(!a||!a.id)throw new Error("Creazione paziente fallita: nessun ID restituito");return r.log(`Paziente creato con successo: ID ${a.id}`),a}catch(n){throw r.error("Errore nella creazione paziente:",n),new Error(`Fallimento creazione paziente: ${n.message}`)}}async createSurgeryEventStep(e,n){try{const a={paziente_id:e,tipo_evento:"intervento",data_evento:n.data_evento,tipo_intervento:n.tipo_intervento,descrizione:n.descrizione||null,data_fine_evento:null},i=await t.createEvento(a);if(!i||!i.id)throw new Error("Creazione evento intervento fallita: nessun ID restituito");return r.log(`Evento intervento creato con successo: ID ${i.id}`),i}catch(a){throw r.error("Errore nella creazione evento intervento:",a),new Error(`Fallimento creazione evento intervento: ${a.message}`)}}async createInfectionEventStep(e,n){try{const a={paziente_id:e,tipo_evento:"infezione",data_evento:n.data_evento,agente_patogeno:n.agente_patogeno||null,descrizione:n.descrizione||null,data_fine_evento:null},i=await t.createEvento(a);if(!i||!i.id)throw new Error("Creazione evento infezione fallita: nessun ID restituito");return r.log(`Evento infezione creato con successo: ID ${i.id}`),i}catch(a){throw r.error("Errore nella creazione evento infezione:",a),new Error(`Fallimento creazione evento infezione: ${a.message}`)}}async verifySynchronizationStep(e){try{await new Promise(e=>setTimeout(e,500));const t=await h(e);if(!t)throw new Error("Paziente non trovato durante verifica sincronizzazione");t.infetto||r.warn(`Paziente ${e}: flag infetto non sincronizzato correttamente`),t.data_infezione||r.warn(`Paziente ${e}: data_infezione non sincronizzata correttamente`),r.log(`Sincronizzazione verificata per paziente ${e}`)}catch(t){r.error("Errore nella verifica sincronizzazione:",t),r.warn("Continuando nonostante errore di verifica sincronizzazione")}}async handleTransactionFailure(e,t){const n=this.transactionLogs.get(e);if(!n)return r.error(`Log transazione ${e} non trovato`),void 0;this.logTransactionStep(e,"handle_failure","started",{error:t.message});const a=n.steps.filter(e=>"completed"===e.status),i=a.some(e=>"create_patient"===e.step),o=a.some(e=>"create_infection_event"===e.step);try{o&&!i?(r.warn("Evento infezione creato senza paziente - situazione inconsistente"),await this.handleInconsistentState(e,t)):i&&!o?await this.handlePatientCreatedInfectionFailed(e,t):i?await this.handleLateFailure(e,t):await this.handleEarlyFailure(e,t),this.completeTransactionLog(e,"failed")}catch(s){r.error(`Errore durante gestione fallimento transazione ${e}:`,s),this.completeTransactionLog(e,"rollback_failed")}}async handlePatientCreatedInfectionFailed(e,t){const n=this.transactionLogs.get(e).steps.find(e=>"create_patient"===e.step&&"completed"===e.status);if(!n||!n.data||!n.data.patientId)throw new Error("ID paziente non trovato nel log della transazione");const a=n.data.patientId;throw this.logTransactionStep(e,"recovery_options_presented","completed",{type:"error",title:"Creazione Incompleta",message:`Paziente creato con successo, ma creazione evento infezione fallita. \n                Paziente ID: ${a}\n                Errore: ${t.message}`,actions:[{label:"Riprova Evento Infezione",action:"retry_infection",data:{transactionId:e,patientId:a}},{label:"Completa Manualmente",action:"complete_manually",data:{patientId:a}},{label:"Elimina Paziente",action:"rollback_patient",data:{patientId:a},variant:"danger"}]}),l.error("Paziente creato ma evento infezione fallito. Controlla la sezione notifiche per le opzioni di recovery.",{persistent:!0}),new Error(`Transazione parzialmente completata. Paziente ID: ${a}. ${t.message}`)}async handleEarlyFailure(e,t){this.logTransactionStep(e,"early_failure_handled","completed",{message:"Nessun rollback necessario - nessuna risorsa creata"}),l.error(`Errore nella creazione: ${t.message}`)}async handleLateFailure(e,t){this.logTransactionStep(e,"late_failure_handled","completed",{message:"Transazione sostanzialmente completata nonostante errore finale",originalError:t.message}),l.warning(`Paziente e evento infezione creati, ma si è verificato un errore nella verifica finale: ${t.message}`)}async handleInconsistentState(e,t){this.logTransactionStep(e,"inconsistent_state_detected","completed",{message:"Stato inconsistente rilevato - richiede intervento manuale",originalError:t.message}),l.error(`Stato inconsistente rilevato. Contattare l'amministratore. Transazione ID: ${e}`,{persistent:!0})}async rollbackPatientCreation(e){try{await u(e),r.log(`Rollback completato: paziente ${e} eliminato`),l.success("Rollback completato: paziente eliminato")}catch(t){throw r.error(`Errore nel rollback paziente ${e}:`,t),new Error(`Rollback fallito: ${t.message}`)}}async retryInfectionCreation(e,t,n){const a=`${e}_retry_${Date.now()}`;try{this.initializeTransactionLog(a,"retry_infection_creation",{originalTransactionId:e,patientId:t,infectionData:this.sanitizeLogData(n)});const i=await this.createInfectionEventStep(t,n);return await this.verifySynchronizationStep(t),this.completeTransactionLog(a,"completed"),l.success("Evento infezione creato con successo!"),i}catch(i){throw this.completeTransactionLog(a,"failed"),r.error("Errore nel retry creazione infezione:",i),i}}initializeTransactionLog(e,t,n={}){const a={id:e,type:t,status:"started",steps:[],initialData:n,createdAt:Date.now(),completedAt:null};this.transactionLogs.set(e,a),r.log(`Transazione ${e} inizializzata: ${t}`)}logTransactionStep(e,t,n,a={}){const i=this.transactionLogs.get(e);if(!i)return r.error(`Tentativo di loggare step per transazione inesistente: ${e}`),void 0;const o={step:t,status:n,data:this.sanitizeLogData(a),timestamp:Date.now()};i.steps.push(o),r.log(`Transazione ${e} - Step ${t}: ${n}`)}completeTransactionLog(e,t){const n=this.transactionLogs.get(e);if(!n)return r.error(`Tentativo di completare transazione inesistente: ${e}`),void 0;n.status=t,n.completedAt=Date.now(),r.log(`Transazione ${e} completata con stato: ${t}`)}getTransactionLog(e){return this.transactionLogs.get(e)||null}getAllTransactionLogs(){return Array.from(this.transactionLogs.values())}generateTransactionId(){return`tx_${Date.now()}_${Math.random().toString(36).substr(2,9)}`}sanitizeLogData(e){if(!e||"object"!=typeof e)return e;const t={...e};return["password","token","auth","secret","nome","cognome","codice_fiscale","codice_rad","telefono","email","indirizzo","indirizzo_residenza","citta","cap","note","descrizione"].forEach(e=>{t[e]&&(t[e]="[REDACTED]")}),t}startLogCleanup(){setInterval(()=>{this.cleanupOldLogs()},this.cleanupInterval)}cleanupOldLogs(){const e=Date.now();let t=0;for(const[n,a]of this.transactionLogs.entries())e-a.createdAt>this.maxLogRetention&&(this.transactionLogs.delete(n),t++);t>0&&r.log(`Cleanup log transazioni: ${t} log rimossi`)}getTransactionStats(){const e=Array.from(this.transactionLogs.values());return{total:e.length,byStatus:e.reduce((e,t)=>(e[t.status]=(e[t.status]||0)+1,e),{}),byType:e.reduce((e,t)=>(e[t.type]=(e[t.type]||0)+1,e),{}),oldestLog:e.length>0?Math.min(...e.map(e=>e.createdAt)):null,newestLog:e.length>0?Math.max(...e.map(e=>e.createdAt)):null}}};const y=new class{constructor(){this.cache=new Map,this.cacheTimeout=3e5}async getPatients(e={},t={}){try{c.setLoading(!0,"Caricamento pazienti...");const{page:a=0,limit:i=10}=t,{patients:o,totalCount:s}=await p(e,t);try{const e=(o||[]).filter(e=>e&&"trasferimento_esterno"===e.tipo_dimissione).slice(0,5).map(e=>({id:e.id,codice_clinica:e.codice_clinica}));r.group("[patientService.getPatients] Result summary"),r.log({page:a,limit:i,totalCount:s,sampleExternalTransfers:e}),r.groupEnd()}catch(n){}return{patients:o,totalCount:s,currentPage:a,totalPages:Math.ceil(s/i),hasNextPage:(a+1)*i<s,hasPrevPage:a>0}}catch(a){throw r.error("Errore nel caricamento pazienti:",a),l.error(`Errore nel caricamento: ${a.message}`),a}finally{c.setLoading(!1)}}async getPatientById(e){const t=`patient_${e}`,n=this.cache.get(t);if(n&&Date.now()-n.timestamp<this.cacheTimeout)return n.data;try{const n=await h(e);this.cache.set(t,{data:n,timestamp:Date.now()});try{r.log("[patientService.getPatientById] Received",{id:n?.id,tipo_dimissione:n?.tipo_dimissione,codice_clinica:n?.codice_clinica||null})}catch(a){}return n}catch(i){throw r.error("Errore nel caricamento paziente:",i),l.error(`Errore nel caricamento paziente: ${i.message}`),i}}async createPatient(e){try{c.setLoading(!0,"Creazione paziente..."),n(e);const{data:{user:t}}=await s.auth.getUser();if(!t)throw new Error("Utente non autenticato");const a={...e,user_id:t.id,data_dimissione:null,infetto:Boolean(e.infetto)},i=await z(a);return this.invalidateCache(),l.success("Paziente creato con successo!"),i}catch(t){r.error("Errore nella creazione paziente:",t);const e=a(t,{entity:"paziente",operation:"creazione"});throw l.error(e),t}finally{c.setLoading(!1)}}async updatePatient(e,t,n={showNotification:!0}){try{c.setLoading(!0,"Aggiornamento paziente...");const a=await m(e,t);return this.cache.delete(`patient_${e}`),n.showNotification&&l.success("Paziente aggiornato con successo!"),a}catch(i){r.error("Errore nell'aggiornamento paziente:",i);const e=a(i,{entity:"paziente",operation:"aggiornamento"});throw l.error(e),i}finally{c.setLoading(!1)}}async deletePatient(e){try{c.setLoading(!0,"Eliminazione paziente..."),await u(e),this.cache.delete(`patient_${e}`),this.invalidateCache(),l.success("Paziente eliminato con successo!")}catch(t){throw r.error("Errore nell'eliminazione paziente:",t),l.error(`Errore nell'eliminazione: ${t.message}`),t}finally{c.setLoading(!1)}}async dischargePatient(e,t=null){try{const n=t||(new Date).toISOString().split("T")[0];await this.updatePatient(e,{data_dimissione:n},{showNotification:!1}),l.success("Paziente dimesso con successo!")}catch(n){throw r.error("Errore nella dimissione:",n),l.error(`Errore nella dimissione: ${n.message}`),n}}async dischargePatientWithTransfer(e,t){try{c.setLoading(!0,"Dimissione paziente..."),i(t);const n=await m(e,t);this.cache.delete(`patient_${e}`);return l.success(`Paziente ${"dimissione"===t.tipo_dimissione?"dimesso":"trasferito"} con successo!`),n}catch(n){throw r.error("Errore nella dimissione/trasferimento:",n),l.error(`Errore nella dimissione: ${n.message}`),n}finally{c.setLoading(!1)}}async reactivatePatient(e){try{const t={data_dimissione:null,tipo_dimissione:null,reparto_destinazione:null,clinica_destinazione:null,codice_clinica:null,codice_dimissione:null};await this.updatePatient(e,t,{showNotification:!1}),l.success("Paziente riattivato con successo!")}catch(t){throw r.error("Errore nella riattivazione:",t),l.error(`Errore nella riattivazione: ${t.message}`),t}}async searchPatients(e,t=!1){try{return await f(e,t)}catch(n){throw r.error("Errore nella ricerca pazienti:",n),l.error(`Errore nella ricerca: ${n.message}`),n}}async exportPatients(e={}){try{c.setLoading(!0,"Preparazione esportazione...");const n=await g(e);try{const e=(n||[]).filter(e=>e&&"trasferimento_esterno"===e.tipo_dimissione).slice(0,5).map(e=>({id:e.id,codice_clinica:e.codice_clinica}));r.group("[patientService.exportPatients] Export dataset sample"),r.log({total:n?.length||0,sampleExternalTransfers:e}),r.groupEnd()}catch(t){}if(!n||0===n.length)return l.warning("Nessun dato da esportare per i filtri selezionati."),void 0;!function(e,t){const n=new Blob([e],{type:"text/csv;charset=utf-8;"}),a=document.createElement("a");a.href=URL.createObjectURL(n),a.download=t,document.body.appendChild(a),a.click(),document.body.removeChild(a)}([["Nome","Cognome","Data Nascita","Data Ricovero","Data Dimissione","Diagnosi","Reparto Appartenenza","Reparto Provenienza","Livello Assistenza","Codice RAD","Infetto"],...n.map(e=>[e.nome||"",e.cognome||"",e.data_nascita?new Date(e.data_nascita).toLocaleDateString():"",e.data_ricovero?new Date(e.data_ricovero).toLocaleDateString():"",e.data_dimissione?new Date(e.data_dimissione).toLocaleDateString():"",e.diagnosi||"",e.reparto_appartenenza||"",e.reparto_provenienza||"",e.livello_assistenza||"",e.codice_rad||"",e.infetto?"Sì":"No"])].map(e=>e.map(e=>`"${e.toString().replace(/"/g,'""')}"`).join(",")).join("\n"),"esportazione_pazienti.csv"),l.success(`Esportati ${n.length} pazienti con successo!`)}catch(n){throw r.error("Errore nell'esportazione:",n),l.error(`Errore nell'esportazione: ${n.message}`),n}finally{c.setLoading(!1)}}async getPatientStats(){try{const e=await v(),t={total:e.length,active:e.filter(e=>!e.data_dimissione).length,discharged:e.filter(e=>e.data_dimissione).length,byDiagnosis:{},byDepartment:{}};return e.forEach(e=>{t.byDiagnosis[e.diagnosi]=(t.byDiagnosis[e.diagnosi]||0)+1,t.byDepartment[e.reparto_appartenenza]=(t.byDepartment[e.reparto_appartenenza]||0)+1}),t}catch(e){throw r.error("Errore nel caricamento statistiche:",e),e}}async getTransferHistory(e){try{const t=await this.getPatientById(e);if(!t)throw new Error("Paziente non trovato");const n=[];return t.data_dimissione&&t.tipo_dimissione&&n.push({data:t.data_dimissione,tipo:t.tipo_dimissione,reparto_destinazione:t.reparto_destinazione,clinica_destinazione:t.clinica_destinazione,codice_clinica:t.codice_clinica,codice_dimissione:t.codice_dimissione}),n}catch(t){throw r.error("Errore nel caricamento cronologia trasferimenti:",t),l.error(`Errore nel caricamento cronologia: ${t.message}`),t}}invalidateCache(){this.cache.clear()}async createPatientWithInfection(e,t){try{if(r.log("Avvio creazione paziente con infezione:",{patientName:`${e.nome} ${e.cognome}`,infectionDate:t.data_evento}),n(e),o.setInfectionData(t),!o.hasValidInfectionData()){const e=o.getValidationErrors().map(e=>e.message).join(", ");throw new Error(`Dati infezione non validi: ${e}`)}const a=await _.executePatientWithInfectionTransaction(e,t);return o.clearInfectionData(),this.invalidateCache(),r.log("Creazione paziente con infezione completata con successo:",{transactionId:a.transactionId,patientId:a.patient?.id,infectionEventId:a.infectionEvent?.id}),a}catch(a){throw r.error("Errore nella creazione paziente con infezione:",a),a.message.includes("Dati infezione non validi")?l.error(`Errore nei dati di infezione: ${a.message}`):a.message.includes("Transazione parzialmente completata")?r.warn("Transazione parzialmente completata - recovery options presentate"):l.error(`Errore nella creazione: ${a.message}`),a}}async handleInfectionEventCreation(e,n){try{r.log(`Creazione evento infezione per paziente ${e}`);if(!(await this.getPatientById(e)))throw new Error(`Paziente con ID ${e} non trovato`);if(o.setInfectionData(n),!o.hasValidInfectionData()){const e=o.getValidationErrors().map(e=>e.message).join(", ");throw new Error(`Dati infezione non validi: ${e}`)}const a=(await t.getEventiByPaziente(e,{tipo_evento:"infezione"})).filter(e=>!e.data_fine_evento);if(a.length>0)throw r.warn(`Paziente ${e} ha già un'infezione attiva`),l.warning(`Il paziente ha già un'infezione attiva dal ${a[0].data_evento}. Vuoi comunque creare un nuovo evento di infezione?`,{persistent:!0,actions:[{label:"Crea Comunque",action:"force_create_infection"},{label:"Annulla",action:"cancel_infection"}]}),new Error("Paziente ha già un'infezione attiva");const i={paziente_id:e,tipo_evento:"infezione",data_evento:n.data_evento,agente_patogeno:n.agente_patogeno||null,descrizione:n.descrizione||null,data_fine_evento:null},s=await t.createEvento(i);return o.clearInfectionData(),this.cache.delete(`patient_${e}`),r.log(`Evento infezione creato con successo: ID ${s.id}`),s}catch(a){if(r.error(`Errore nella creazione evento infezione per paziente ${e}:`,a),a.message.includes("già un'infezione attiva"))throw a;throw a.message.includes("Dati infezione non validi")?l.error(`Errore nei dati di infezione: ${a.message}`):a.message.includes("non trovato")?l.error("Paziente non trovato"):l.error(`Errore nella creazione evento infezione: ${a.message}`),a}}async retryInfectionEventCreation(e,t,n){try{return r.log(`Retry creazione evento infezione - Transazione: ${e}, Paziente: ${t}`),await _.retryInfectionCreation(e,t,n)}catch(a){throw r.error("Errore nel retry creazione evento infezione:",a),l.error(`Errore nel retry: ${a.message}`),a}}async rollbackPatientCreation(e){try{r.log(`Rollback creazione paziente: ${e}`),await _.rollbackPatientCreation(e),this.cache.delete(`patient_${e}`),this.invalidateCache()}catch(t){throw r.error(`Errore nel rollback paziente ${e}:`,t),l.error(`Errore nel rollback: ${t.message}`),t}}async forceCreateInfectionEvent(e,n){try{if(r.log(`Creazione forzata evento infezione per paziente ${e}`),o.setInfectionData(n),!o.hasValidInfectionData()){const e=o.getValidationErrors().map(e=>e.message).join(", ");throw new Error(`Dati infezione non validi: ${e}`)}const a={paziente_id:e,tipo_evento:"infezione",data_evento:n.data_evento,agente_patogeno:n.agente_patogeno||null,descrizione:n.descrizione||null,data_fine_evento:null},i=await t.createEvento(a);return o.clearInfectionData(),this.cache.delete(`patient_${e}`),l.success("Nuovo evento infezione creato con successo!"),i}catch(a){throw r.error("Errore nella creazione forzata evento infezione:",a),l.error(`Errore nella creazione: ${a.message}`),a}}async createPatientWithSurgery(t,a){try{r.log("Avvio creazione paziente con intervento chirurgico:",{patientName:`${t.nome} ${t.cognome}`,surgeryDate:a.data_evento,surgeryType:a.tipo_intervento}),n(t);const{default:i}=await e(async()=>{const{default:e}=await import("./surgeryDataManager-CbtGeuzn.js");return{default:e}},[]);if(i.setSurgeryData(a),!i.hasValidSurgeryData()){const e=i.getValidationErrors().map(e=>e.message).join(", ");throw new Error(`Dati intervento non validi: ${e}`)}const o=await _.executePatientWithSurgeryTransaction(t,a);return i.clearSurgeryData(),this.invalidateCache(),r.log("Creazione paziente con intervento completata con successo:",{transactionId:o.transactionId,patientId:o.patient?.id,surgeryEventId:o.surgeryEvent?.id}),o}catch(i){throw r.error("Errore nella creazione paziente con intervento:",i),i.message.includes("Dati intervento non validi")?l.error(`Errore nei dati di intervento: ${i.message}`):i.message.includes("Transazione parzialmente completata")?r.warn("Transazione parzialmente completata - recovery options presentate"):l.error(`Errore nella creazione: ${i.message}`),i}}async createPatientWithSurgeryAndInfection(t,a,i){try{r.log("Avvio creazione paziente con intervento e infezione:",{patientName:`${t.nome} ${t.cognome}`,surgeryDate:a.data_evento,infectionDate:i.data_evento||a.data_infezione}),n(t);const{default:s}=await e(async()=>{const{default:e}=await import("./surgeryDataManager-CbtGeuzn.js");return{default:e}},[]);if(s.setSurgeryData(a),!s.hasValidSurgeryData()){const e=s.getValidationErrors().map(e=>e.message).join(", ");throw new Error(`Dati intervento non validi: ${e}`)}let c=i;if(!c&&s.hasAssociatedInfection()&&(c=s.prepareInfectionEventData()),c&&(o.setInfectionData(c),!o.hasValidInfectionData())){const e=o.getValidationErrors().map(e=>e.message).join(", ");throw new Error(`Dati infezione non validi: ${e}`)}const l=await _.executePatientWithSurgeryAndInfectionTransaction(t,a,c);return s.clearSurgeryData(),c&&o.clearInfectionData(),this.invalidateCache(),r.log("Creazione paziente con intervento e infezione completata con successo:",{transactionId:l.transactionId,patientId:l.patient?.id,surgeryEventId:l.surgeryEvent?.id,infectionEventId:l.infectionEvent?.id}),l}catch(s){throw r.error("Errore nella creazione paziente con intervento e infezione:",s),s.message.includes("non validi")?l.error(`Errore nei dati: ${s.message}`):s.message.includes("Transazione parzialmente completata")?r.warn("Transazione parzialmente completata - recovery options presentate"):l.error(`Errore nella creazione: ${s.message}`),s}}getTransactionStats(){return _.getTransactionStats()}getTransactionLog(e){return _.getTransactionLog(e)}async handleTemporaryEventsCreation(e,n){try{c.setLoading(!0,"Salvataggio eventi clinici...");for(const a of n){const n={...a};delete n.id,delete n.isTemporary,n.paziente_id=e,await t.createEvento(n)}l.success(`${n.length} eventi clinici salvati con successo`)}catch(a){throw r.error("Errore nella creazione eventi temporanei:",a),l.error("Errore nel salvare gli eventi clinici"),a}finally{c.setLoading(!1)}}async createPatientWithTemporaryEvents(e,n){try{c.setLoading(!0,"Creazione paziente ed eventi clinici...");const a=await z(e);for(const e of n){const n={...e};delete n.id,delete n.isTemporary,n.paziente_id=a.id,await t.createEvento(n)}return l.success(`Paziente e ${n.length} eventi clinici creati con successo`),{patient:a,events:n,success:!0}}catch(a){throw r.error("Errore nella creazione paziente con eventi temporanei:",a),l.error("Errore nella creazione del paziente e degli eventi"),a}finally{c.setLoading(!1)}}};export{y as patientService};
