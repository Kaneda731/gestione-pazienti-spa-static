import{m as e,e as t,i as a,v as n,a as i}from"./infectionDataManager-BNwRbl0n.js";import{b as o,n as r,l as s,s as c}from"./index-DS3zBzTz.js";import{_ as l}from"./supabase-B8WzuNbi.js";const d={initCache(e=3e5){this.cache=new Map,this.cacheTimeout=e},getCached(e){const t=this.cache.get(e);return t&&Date.now()-t.timestamp<this.cacheTimeout?t.data:null},setCache(e,t){this.cache.set(e,{data:t,timestamp:Date.now()})},deleteCache(e){this.cache.delete(e)},invalidateCache(){this.cache.clear()}},p={async withLoading(e,t){try{return o.setLoading(!0,e),await t()}finally{o.setLoading(!1)}}},u={handleError(t,a={}){if(s.error(`Errore in ${a.operation||"operazione"}:`,t),a.useDbErrorMapping){const n=e(t,a);r.error(n)}else r.error(`Errore ${a.operation||"nell'operazione"}: ${t.message}`)},showSuccess(e){r.success(e)},showWarning(e){r.warning(e)}},g=10,h=(e={})=>{let t=c.from("pazienti").select("*",{count:"exact"}).not("user_id","is",null);const{reparto:a,diagnosi:n,stato:i,search:o}=e;return a&&(t=t.eq("reparto_appartenenza",a)),n&&(t=t.eq("diagnosi",n)),"attivo"===i&&(t=t.is("data_dimissione",null)),"dimesso"===i&&(t=t.not("data_dimissione","is",null)),o&&(t=t.or(`nome.ilike.%${o}%,cognome.ilike.%${o}%`)),t},f=async(e={},t={})=>{const{page:a=0,limit:n=g,sortColumn:i="data_ricovero",sortDirection:o="desc"}=t;let r=h(e);const c=a*n,l=c+n-1;r=r.order(i,{ascending:"asc"===o}).range(c,l);const{data:d,error:p,count:u}=await r;if(p)throw p;try{const e=(d||[]).filter(e=>e&&"trasferimento_esterno"===e.tipo_dimissione).slice(0,5).map(e=>({id:e.id,codice_clinica:e.codice_clinica}));s.group("[patientApi.getPaginatedPatients] Result summary"),s.log({total:d?.length||0,count:u,externalTransfersSample:e}),s.groupEnd()}catch(f){}return{patients:d||[],totalCount:u||0}},z=async(e={})=>{const{sortColumn:t="data_ricovero",sortDirection:a="desc"}=e;let n=h(e);n=n.order(t,{ascending:"asc"===a});const{data:i,error:o}=await n;if(o)throw o;try{const e=(i||[]).filter(e=>e&&"trasferimento_esterno"===e.tipo_dimissione).slice(0,5).map(e=>({id:e.id,codice_clinica:e.codice_clinica}));s.group("[patientApi.getAllPatients] Result sample"),s.log({total:i?.length||0,externalTransfersSample:e}),s.groupEnd()}catch(r){}return i||[]},y=async e=>{const{data:t,error:a}=await c.from("pazienti").select("*").eq("id",e).single();if(a)throw a;try{s.log("[patientApi.getPatientById] Loaded",{id:t?.id,tipo_dimissione:t?.tipo_dimissione,codice_clinica:t?.codice_clinica||null})}catch(n){}return t},m=async e=>{const{data:t,error:a}=await c.from("pazienti").insert([e]).select().single();if(a)throw a;return t},v=async(e,t)=>{try{s.group("[patientApi.updatePatient] Update payload"),s.log({id:e,codice_clinica:t?.codice_clinica??null,tipo_dimissione:t?.tipo_dimissione??null}),s.groupEnd()}catch(i){}const{data:a,error:n}=await c.from("pazienti").update(t).eq("id",e).select().single();if(n)throw n;try{s.group("[patientApi.updatePatient] Update result"),s.log({id:a?.id,tipo_dimissione:a?.tipo_dimissione??null,codice_clinica:a?.codice_clinica??null}),s.groupEnd()}catch(i){}return a},_=async e=>{const{error:t}=await c.from("pazienti").delete().eq("id",e);if(t)throw t},w=async(e,t=!1,a=50)=>{let n=c.from("pazienti").select("id, nome, cognome, codice_rad, data_ricovero, diagnosi, reparto_appartenenza").not("user_id","is",null).or(`nome.ilike.%${e}%,cognome.ilike.%${e}%,codice_rad.ilike.%${e}%`).order("cognome");t&&(n=n.is("data_dimissione",null));const{data:i,error:o}=await n.limit(Math.max(1,Number(a)||50));if(o)throw o;return i||[]},E=async()=>{const{data:e,error:t}=await c.from("pazienti").select("data_dimissione, diagnosi, reparto_appartenenza").not("user_id","is",null);if(t)throw t;return e||[]};function D(e,t){const a=new Blob([e],{type:"text/csv;charset=utf-8;"}),n=document.createElement("a");n.href=URL.createObjectURL(a),n.download=t,document.body.appendChild(n),n.click(),document.body.removeChild(n)}function S(e,t){const a=new Blob([e],{type:"application/json;charset=utf-8;"}),n=document.createElement("a");n.href=URL.createObjectURL(a),n.download=t,document.body.appendChild(n),n.click(),document.body.removeChild(n)}const I=new class{async exportPatients(e={}){try{o.setLoading(!0,"Preparazione esportazione...");const t=await z(e);if(this._logExportSample(t,"CSV"),!t||0===t.length)return r.warning("Nessun dato da esportare per i filtri selezionati."),void 0;D([["Nome","Cognome","Data Nascita","Data Ricovero","Data Dimissione","Diagnosi","Reparto Appartenenza","Reparto Provenienza","Livello Assistenza","Codice RAD","Infetto"],...t.map(e=>[e.nome||"",e.cognome||"",e.data_nascita?new Date(e.data_nascita).toLocaleDateString():"",e.data_ricovero?new Date(e.data_ricovero).toLocaleDateString():"",e.data_dimissione?new Date(e.data_dimissione).toLocaleDateString():"",e.diagnosi||"",e.reparto_appartenenza||"",e.reparto_provenienza||"",e.livello_assistenza||"",e.codice_rad||"",e.infetto?"Sì":"No"])].map(e=>e.map(e=>`"${e.toString().replace(/"/g,'""')}"`).join(",")).join("\n"),"esportazione_pazienti.csv"),r.success(`Esportati ${t.length} pazienti con successo!`)}catch(t){throw s.error("Errore nell'esportazione:",t),r.error(`Errore nell'esportazione: ${t.message}`),t}finally{o.setLoading(!1)}}async exportPatientsJSON(e={}){try{o.setLoading(!0,"Preparazione esportazione JSON...");const t=await z(e);if(!t||0===t.length)return r.warning("Nessun dato da esportare per i filtri selezionati."),void 0;S(JSON.stringify(t,null,2),"esportazione_pazienti.json"),r.success(`Esportati ${t.length} pazienti in JSON con successo!`)}catch(t){throw s.error("Errore nell'esportazione JSON:",t),r.error(`Errore nell'esportazione JSON: ${t.message}`),t}finally{o.setLoading(!1)}}_logExportSample(e,t){try{const a=(e||[]).filter(e=>e&&"trasferimento_esterno"===e.tipo_dimissione).slice(0,5).map(e=>({id:e.id,codice_clinica:e.codice_clinica}));s.group(`[PatientExportService.export${t}] Export dataset sample`),s.log({total:e?.length||0,sampleExternalTransfers:a}),s.groupEnd()}catch(a){}}};const P=new class{constructor(){this.transactionLogs=new Map,this.maxLogRetention=864e5,this.cleanupInterval=36e5,this.startLogCleanup()}generateTransactionId(){return`tx_${Date.now()}_${Math.random().toString(36).substr(2,9)}`}initializeTransactionLog(e,t,a={}){const n={id:e,type:t,status:"started",steps:[],initialData:this.sanitizeLogData(a),createdAt:Date.now(),completedAt:null};return this.transactionLogs.set(e,n),s.log(`Transazione ${e} inizializzata: ${t}`),n}logTransactionStep(e,t,a,n={}){const i=this.transactionLogs.get(e);if(!i)return s.error(`Tentativo di loggare step per transazione inesistente: ${e}`),void 0;const o={step:t,status:a,data:this.sanitizeLogData(n),timestamp:Date.now()};i.steps.push(o),s.log(`Transazione ${e} - Step ${t}: ${a}`)}completeTransactionLog(e,t){const a=this.transactionLogs.get(e);if(!a)return s.error(`Tentativo di completare transazione inesistente: ${e}`),void 0;a.status=t,a.completedAt=Date.now(),s.log(`Transazione ${e} completata con stato: ${t}`)}getTransactionLog(e){return this.transactionLogs.get(e)||null}getAllTransactionLogs(){return Array.from(this.transactionLogs.values())}getTransactionStats(){const e=Array.from(this.transactionLogs.values());return{total:e.length,byStatus:e.reduce((e,t)=>(e[t.status]=(e[t.status]||0)+1,e),{}),byType:e.reduce((e,t)=>(e[t.type]=(e[t.type]||0)+1,e),{}),oldestLog:e.length>0?Math.min(...e.map(e=>e.createdAt)):null,newestLog:e.length>0?Math.max(...e.map(e=>e.createdAt)):null}}sanitizeLogData(e){if(!e||"object"!=typeof e)return e;const t={...e};return["password","token","auth","secret","nome","cognome","codice_fiscale","codice_rad","telefono","email","indirizzo","indirizzo_residenza","citta","cap","note","descrizione"].forEach(e=>{t[e]&&(t[e]="[REDACTED]")}),t}startLogCleanup(){setInterval(()=>{this.cleanupOldLogs()},this.cleanupInterval)}cleanupOldLogs(){const e=Date.now();let t=0;for(const[a,n]of this.transactionLogs.entries())e-n.createdAt>this.maxLogRetention&&(this.transactionLogs.delete(a),t++);t>0&&s.log(`Cleanup log transazioni: ${t} log rimossi`)}};const T=new class{async createPatientStep(e,t=!1){try{const a={...e,infetto:t,data_infezione:null},n=await m(a);if(!n||!n.id)throw new Error("Creazione paziente fallita: nessun ID restituito");return s.log(`Paziente creato con successo: ID ${n.id}`),n}catch(a){throw s.error("Errore nella creazione paziente:",a),new Error(`Fallimento creazione paziente: ${a.message}`)}}async createInfectionEventStep(e,a){try{const n={paziente_id:e,tipo_evento:"infezione",data_evento:a.data_evento,agente_patogeno:a.agente_patogeno||null,descrizione:a.descrizione||null,data_fine_evento:null},i=await t.createEvento(n);if(!i||!i.id)throw new Error("Creazione evento infezione fallita: nessun ID restituito");return s.log(`Evento infezione creato con successo: ID ${i.id}`),i}catch(n){throw s.error("Errore nella creazione evento infezione:",n),new Error(`Fallimento creazione evento infezione: ${n.message}`)}}async createSurgeryEventStep(e,a){try{const n={paziente_id:e,tipo_evento:"intervento",data_evento:a.data_evento,tipo_intervento:a.tipo_intervento,descrizione:a.descrizione||null,data_fine_evento:null},i=await t.createEvento(n);if(!i||!i.id)throw new Error("Creazione evento intervento fallita: nessun ID restituito");return s.log(`Evento intervento creato con successo: ID ${i.id}`),i}catch(n){throw s.error("Errore nella creazione evento intervento:",n),new Error(`Fallimento creazione evento intervento: ${n.message}`)}}async verifySynchronizationStep(e){try{await new Promise(e=>setTimeout(e,500));const t=await y(e);if(!t)throw new Error("Paziente non trovato durante verifica sincronizzazione");t.infetto||s.warn(`Paziente ${e}: flag infetto non sincronizzato correttamente`),t.data_infezione||s.warn(`Paziente ${e}: data_infezione non sincronizzata correttamente`),s.log(`Sincronizzazione verificata per paziente ${e}`)}catch(t){s.error("Errore nella verifica sincronizzazione:",t),s.warn("Continuando nonostante errore di verifica sincronizzazione")}}async rollbackPatientCreation(e){try{await _(e),s.log(`Rollback completato: paziente ${e} eliminato`)}catch(t){throw s.error(`Errore nel rollback paziente ${e}:`,t),new Error(`Rollback fallito: ${t.message}`)}}};const $=new class{async handleTransactionFailure(e,t){const a=P.getTransactionLog(e);if(!a)return s.error(`Log transazione ${e} non trovato`),void 0;P.logTransactionStep(e,"handle_failure","started",{error:t.message});const n=a.steps.filter(e=>"completed"===e.status),i=n.some(e=>"create_patient"===e.step),o=n.some(e=>"create_infection_event"===e.step);try{o&&!i?await this.handleInconsistentState(e,t):i&&!o?await this.handlePatientCreatedInfectionFailed(e,t):i?await this.handleLateFailure(e,t):await this.handleEarlyFailure(e,t),P.completeTransactionLog(e,"failed")}catch(r){s.error(`Errore durante gestione fallimento transazione ${e}:`,r),P.completeTransactionLog(e,"rollback_failed")}}async handlePatientCreatedInfectionFailed(e,t){const a=P.getTransactionLog(e).steps.find(e=>"create_patient"===e.step&&"completed"===e.status);if(!a||!a.data||!a.data.patientId)throw new Error("ID paziente non trovato nel log della transazione");const n=a.data.patientId;throw P.logTransactionStep(e,"recovery_options_presented","completed",{type:"error",title:"Creazione Incompleta",message:`Paziente creato con successo, ma creazione evento infezione fallita. \n                Paziente ID: ${n}\n                Errore: ${t.message}`,actions:[{label:"Riprova Evento Infezione",action:"retry_infection",data:{transactionId:e,patientId:n}},{label:"Completa Manualmente",action:"complete_manually",data:{patientId:n}},{label:"Elimina Paziente",action:"rollback_patient",data:{patientId:n},variant:"danger"}]}),r.error("Paziente creato ma evento infezione fallito. Controlla la sezione notifiche per le opzioni di recovery.",{persistent:!0}),new Error(`Transazione parzialmente completata. Paziente ID: ${n}. ${t.message}`)}async handleEarlyFailure(e,t){P.logTransactionStep(e,"early_failure_handled","completed",{message:"Nessun rollback necessario - nessuna risorsa creata"}),r.error(`Errore nella creazione: ${t.message}`)}async handleLateFailure(e,t){P.logTransactionStep(e,"late_failure_handled","completed",{message:"Transazione sostanzialmente completata nonostante errore finale",originalError:t.message}),r.warning(`Paziente e evento infezione creati, ma si è verificato un errore nella verifica finale: ${t.message}`)}async handleInconsistentState(e,t){P.logTransactionStep(e,"inconsistent_state_detected","completed",{message:"Stato inconsistente rilevato - richiede intervento manuale",originalError:t.message}),r.error(`Stato inconsistente rilevato. Contattare l'amministratore. Transazione ID: ${e}`,{persistent:!0})}async retryInfectionCreation(e,t,a){const n=`${e}_retry_${Date.now()}`;try{P.initializeTransactionLog(n,"retry_infection_creation",{originalTransactionId:e,patientId:t,infectionData:a});const i=await T.createInfectionEventStep(t,a);return await T.verifySynchronizationStep(t),P.completeTransactionLog(n,"completed"),r.success("Evento infezione creato con successo!"),i}catch(i){throw P.completeTransactionLog(n,"failed"),s.error("Errore nel retry creazione infezione:",i),i}}};const C=new class{async validatePatientData(e){if(!e||"object"!=typeof e)throw new Error("Dati paziente non validi");const t=["nome","cognome","data_ricovero"];for(const a of t)if(!e[a]||""===e[a].toString().trim())throw new Error(`Campo paziente obbligatorio mancante: ${a}`)}async validateInfectionData(e){if(!e||"object"!=typeof e)throw new Error("Dati infezione non validi");const t=["data_evento"];for(const a of t)if(!e[a]||""===e[a].toString().trim())throw new Error(`Campo infezione obbligatorio mancante: ${a}`);await this.validateEventDate(e.data_evento,"evento infezione")}async validateSurgeryData(e){if(!e||"object"!=typeof e)throw new Error("Dati intervento non validi");const t=["data_evento","tipo_intervento"];for(const a of t)if(!e[a]||""===e[a].toString().trim())throw new Error(`Campo intervento obbligatorio mancante: ${a}`);if(await this.validateEventDate(e.data_evento,"evento intervento"),e.has_infection&&e.data_infezione){const t=new Date(e.data_infezione),a=new Date(e.data_evento);if(isNaN(t.getTime()))throw new Error("Data infezione associata non valida");if(t<a)throw new Error("La data dell'infezione non può essere precedente all'intervento")}}async validateEventDate(e,t){const a=new Date(e),n=new Date;if(n.setHours(23,59,59,999),isNaN(a.getTime()))throw new Error(`Data ${t} non valida`);if(a>n)throw new Error(`La data dell'${t} non può essere nel futuro`)}async validateTransactionData(e,t,a){switch(await this.validatePatientData(e),a){case"infection":await this.validateInfectionData(t);break;case"surgery":await this.validateSurgeryData(t);break;default:throw new Error(`Tipo evento non supportato: ${a}`)}s.log(`Validazione dati transazione ${a} completata con successo`)}};const L=new class{async executeTransaction(e){const t=P.generateTransactionId();try{P.initializeTransactionLog(t,e.type,e.data),o.setLoading(!0,e.loadingMessage),await this.validateTransaction(t,e);const a=await this.createPatient(t,e),n=await this.createEvents(t,e,a.id);return await this.verifyTransaction(t,a.id),P.completeTransactionLog(t,"completed"),r.success(e.successMessage),this.formatResult(t,a,n)}catch(a){throw s.error(`Errore nella transazione ${t}:`,a),await $.handleTransactionFailure(t,a),a}finally{o.setLoading(!1)}}async validateTransaction(e,t){P.logTransactionStep(e,"validation","started"),await C.validatePatientData(t.data.patientData);for(const a of t.events)await C.validateTransactionData(t.data.patientData,t.data[a.dataKey],a.type);P.logTransactionStep(e,"validation","completed",{message:"Dati validati con successo"})}async createPatient(e,t){P.logTransactionStep(e,"create_patient","started");const a=t.events.some(e=>"infection"===e.type),n=await T.createPatientStep(t.data.patientData,a);return P.logTransactionStep(e,"create_patient","completed",{patientId:n.id}),n}async createEvents(e,t,a){const n={};for(const i of t.events){const o=`create_${i.type}_event`;let r;switch(P.logTransactionStep(e,o,"started"),i.type){case"infection":r=await T.createInfectionEventStep(a,t.data[i.dataKey]);break;case"surgery":r=await T.createSurgeryEventStep(a,t.data[i.dataKey]);break;default:throw new Error(`Tipo evento non supportato: ${i.type}`)}n[i.resultKey]=r,P.logTransactionStep(e,o,"completed",{eventId:r.id})}if(t.data.surgeryData?.has_infection&&t.data.surgeryData?.data_infezione){const i="create_infection_event";P.logTransactionStep(e,i,"started");const o={data_evento:t.data.surgeryData.data_infezione,agente_patogeno:t.data.surgeryData.agente_patogeno,descrizione:t.data.surgeryData.descrizione_infezione},r=await T.createInfectionEventStep(a,o);n.infectionEvent=r,P.logTransactionStep(e,i,"completed",{eventId:r.id})}return n}async verifyTransaction(e,t){P.logTransactionStep(e,"verify_synchronization","started"),await T.verifySynchronizationStep(t),P.logTransactionStep(e,"verify_synchronization","completed")}formatResult(e,t,a){return{success:!0,transactionId:e,patient:t,...a,message:"Transazione completata con successo"}}};const b=new class{async executePatientWithSurgeryTransaction(e,t){return L.executeTransaction({type:"patient_with_surgery",loadingMessage:"Creazione paziente e evento intervento...",successMessage:"Paziente e evento intervento creati con successo!",data:{patientData:e,surgeryData:t},events:[{type:"surgery",dataKey:"surgeryData",resultKey:"surgeryEvent"}]})}async executePatientWithSurgeryAndInfectionTransaction(e,t,a){return L.executeTransaction({type:"patient_with_surgery_and_infection",loadingMessage:"Creazione paziente, intervento e infezione...",successMessage:"Paziente, intervento e infezione creati con successo!",data:{patientData:e,surgeryData:t,infectionData:a},events:[{type:"surgery",dataKey:"surgeryData",resultKey:"surgeryEvent"},{type:"infection",dataKey:"infectionData",resultKey:"infectionEvent"}]})}async executePatientWithInfectionTransaction(e,t){return L.executeTransaction({type:"patient_with_infection",loadingMessage:"Creazione paziente e evento infezione...",successMessage:"Paziente e evento infezione creati con successo!",data:{patientData:e,infectionData:t},events:[{type:"infection",dataKey:"infectionData",resultKey:"infectionEvent"}]})}async rollbackPatientCreation(e){await T.rollbackPatientCreation(e)}async retryInfectionCreation(e,t,a){return $.retryInfectionCreation(e,t,a)}getTransactionLog(e){return P.getTransactionLog(e)}getAllTransactionLogs(){return P.getAllTransactionLogs()}getTransactionStats(){return P.getTransactionStats()}};const A=new class{async createPatientWithInfection(e,t){try{s.log("Avvio creazione paziente con infezione:",{patientName:`${e.nome} ${e.cognome}`,infectionDate:t.data_evento}),this._validateInfectionData(t);const n=await b.executePatientWithInfectionTransaction(e,t);return a.clearInfectionData(),s.log("Creazione paziente con infezione completata con successo:",{transactionId:n.transactionId,patientId:n.patient?.id,infectionEventId:n.infectionEvent?.id}),n}catch(n){throw this._handleInfectionError(n,"creazione"),n}}async handleInfectionEventCreation(e,n){try{s.log(`Creazione evento infezione per paziente ${e}`),this._validateInfectionData(n);const i=(await t.getEventiByPaziente(e,{tipo_evento:"infezione"})).filter(e=>!e.data_fine_evento);if(i.length>0)throw this._handleActiveInfectionConflict(i[0]),new Error("Paziente ha già un'infezione attiva");const o=await this._createInfectionEvent(e,n);return a.clearInfectionData(),o}catch(i){throw this._handleInfectionError(i,"creazione evento"),i}}async forceCreateInfectionEvent(e,t){try{s.log(`Creazione forzata evento infezione per paziente ${e}`),this._validateInfectionData(t);const n=await this._createInfectionEvent(e,t);return a.clearInfectionData(),r.success("Nuovo evento infezione creato con successo!"),n}catch(n){throw s.error("Errore nella creazione forzata evento infezione:",n),r.error(`Errore nella creazione: ${n.message}`),n}}async retryInfectionEventCreation(e,t,a){try{return s.log(`Retry creazione evento infezione - Transazione: ${e}, Paziente: ${t}`),await b.retryInfectionCreation(e,t,a)}catch(n){throw s.error("Errore nel retry creazione evento infezione:",n),r.error(`Errore nel retry: ${n.message}`),n}}_validateInfectionData(e){if(a.setInfectionData(e),!a.hasValidInfectionData()){const e=a.getValidationErrors().map(e=>e.message).join(", ");throw new Error(`Dati infezione non validi: ${e}`)}}async _createInfectionEvent(e,a){const n={paziente_id:e,tipo_evento:"infezione",data_evento:a.data_evento,agente_patogeno:a.agente_patogeno||null,descrizione:a.descrizione||null,data_fine_evento:null},i=await t.createEvento(n);return s.log(`Evento infezione creato con successo: ID ${i.id}`),i}_handleActiveInfectionConflict(e){s.warn(`Paziente ha già un'infezione attiva dal ${e.data_evento}`),r.warning(`Il paziente ha già un'infezione attiva dal ${e.data_evento}. Vuoi comunque creare un nuovo evento di infezione?`,{persistent:!0,actions:[{label:"Crea Comunque",action:"force_create_infection"},{label:"Annulla",action:"cancel_infection"}]})}_handleInfectionError(e,t){const a=e?.message||JSON.stringify(e);s.error(`Errore nella ${t} paziente con infezione:`,a),a.includes("Dati infezione non validi")?r.error(`Errore nei dati di infezione: ${a}`):a.includes("Transazione parzialmente completata")?s.warn("Transazione parzialmente completata - recovery options presentate"):a.includes("già un'infezione attiva")||(a.includes("non trovato")?r.error("Paziente non trovato"):r.error(`Errore nella ${t}: ${a}`))}};const x=new class{async createPatientWithSurgery(e,t){try{s.log("Avvio creazione paziente con intervento chirurgico:",{patientName:`${e.nome} ${e.cognome}`,surgeryDate:t.data_evento,surgeryType:t.tipo_intervento}),await this._validateSurgeryData(t);const a=await b.executePatientWithSurgeryTransaction(e,t),{default:n}=await l(async()=>{const{default:e}=await import("./surgeryDataManager-CbtGeuzn.js");return{default:e}},[]);return n.clearSurgeryData(),s.log("Creazione paziente con intervento completata con successo:",{transactionId:a.transactionId,patientId:a.patient?.id,surgeryEventId:a.surgeryEvent?.id}),a}catch(a){throw this._handleSurgeryError(a,"creazione paziente con intervento"),a}}async createPatientWithSurgeryAndInfection(e,t,n){try{s.log("Avvio creazione paziente con intervento e infezione:",{patientName:`${e.nome} ${e.cognome}`,surgeryDate:t.data_evento,infectionDate:n?.data_evento||t.data_infezione});const{default:i}=await l(async()=>{const{default:e}=await import("./surgeryDataManager-CbtGeuzn.js");return{default:e}},[]);await this._validateSurgeryData(t);let o=n;!o&&i.hasAssociatedInfection()&&(o=i.prepareInfectionEventData()),o&&this._validateInfectionData(o);const r=await b.executePatientWithSurgeryAndInfectionTransaction(e,t,o);return i.clearSurgeryData(),o&&a.clearInfectionData(),s.log("Creazione paziente con intervento e infezione completata con successo:",{transactionId:r.transactionId,patientId:r.patient?.id,surgeryEventId:r.surgeryEvent?.id,infectionEventId:r.infectionEvent?.id}),r}catch(i){throw this._handleSurgeryError(i,"creazione paziente con intervento e infezione"),i}}async _validateSurgeryData(e){const{default:t}=await l(async()=>{const{default:e}=await import("./surgeryDataManager-CbtGeuzn.js");return{default:e}},[]);if(t.setSurgeryData(e),!t.hasValidSurgeryData()){const e=t.getValidationErrors().map(e=>e.message).join(", ");throw new Error(`Dati intervento non validi: ${e}`)}}_validateInfectionData(e){if(a.setInfectionData(e),!a.hasValidInfectionData()){const e=a.getValidationErrors().map(e=>e.message).join(", ");throw new Error(`Dati infezione non validi: ${e}`)}}_handleSurgeryError(e,t){const a=e?.message||JSON.stringify(e);s.error(`Errore nella ${t}:`,a),a.includes("non validi")?r.error(`Errore nei dati: ${a}`):a.includes("Transazione parzialmente completata")?s.warn("Transazione parzialmente completata - recovery options presentate"):r.error(`Errore nella ${t}: ${a}`)}};const N=new class{constructor(){Object.assign(this,d,p,u),this.initCache()}async getPatients(e={},t={}){try{o.setLoading(!0,"Caricamento pazienti...");const{page:a=0,limit:n=g}=t,{patients:i,totalCount:r}=await f(e,t);return this._logPatientsSample(i,{page:a,limit:n,totalCount:r}),{patients:i,totalCount:r,currentPage:a,totalPages:Math.ceil(r/n),hasNextPage:(a+1)*n<r,hasPrevPage:a>0}}catch(a){throw this.handleError(a,{operation:"caricamento pazienti"}),a}finally{o.setLoading(!1)}}async getPatientById(e){const t=`patient_${e}`,a=this.getCached(t);if(a)return a;try{const a=await y(e);return this.setCache(t,a),s.log("[patientService.getPatientById] Received",{id:a?.id,tipo_dimissione:a?.tipo_dimissione,codice_clinica:a?.codice_clinica||null}),a}catch(n){throw this.handleError(n,{operation:"caricamento paziente"}),n}}async createPatient(e){return this.withLoading("Creazione paziente...",async()=>{n(e);const{data:{user:t}}=await c.auth.getUser();if(!t)throw new Error("Utente non autenticato");const a={...e,user_id:t.id,data_dimissione:null,infetto:Boolean(e.infetto)};try{const e=await m(a);return this.invalidateCache(),this.showSuccess("Paziente creato con successo!"),e}catch(i){throw this.handleError(i,{entity:"paziente",operation:"creazione",useDbErrorMapping:!0}),i}})}async updatePatient(e,t,a={showNotification:!0}){return this.withLoading("Aggiornamento paziente...",async()=>{try{const n=await v(e,t);return this.deleteCache(`patient_${e}`),a.showNotification&&this.showSuccess("Paziente aggiornato con successo!"),n}catch(n){throw this.handleError(n,{entity:"paziente",operation:"aggiornamento",useDbErrorMapping:!0}),n}})}async deletePatient(e){return this.withLoading("Eliminazione paziente...",async()=>{try{await _(e),this.deleteCache(`patient_${e}`),this.invalidateCache(),this.showSuccess("Paziente eliminato con successo!")}catch(t){throw this.handleError(t,{operation:"eliminazione"}),t}})}async dischargePatient(e,t=null){try{const a=t||(new Date).toISOString().split("T")[0];await this.updatePatient(e,{data_dimissione:a},{showNotification:!1}),this.showSuccess("Paziente dimesso con successo!")}catch(a){throw this.handleError(a,{operation:"dimissione"}),a}}async dischargePatientWithTransfer(e,t){return this.withLoading("Dimissione paziente...",async()=>{try{i(t);const a=await v(e,t);this.deleteCache(`patient_${e}`);return this.showSuccess(`Paziente ${"dimissione"===t.tipo_dimissione?"dimesso":"trasferito"} con successo!`),a}catch(a){throw this.handleError(a,{operation:"dimissione"}),a}})}async reactivatePatient(e){try{const t={data_dimissione:null,tipo_dimissione:null,reparto_destinazione:null,clinica_destinazione:null,codice_clinica:null,codice_dimissione:null};await this.updatePatient(e,t,{showNotification:!1}),this.showSuccess("Paziente riattivato con successo!")}catch(t){throw this.handleError(t,{operation:"riattivazione"}),t}}async searchPatients(e,t=!1,a=50){try{return await w(e,t,a)}catch(n){throw this.handleError(n,{operation:"ricerca pazienti"}),n}}async exportPatients(e={}){return I.exportPatients(e)}async exportPatientsJSON(e={}){return I.exportPatientsJSON(e)}async getPatientStats(){try{const e=await E(),t={total:e.length,active:e.filter(e=>!e.data_dimissione).length,discharged:e.filter(e=>e.data_dimissione).length,byDiagnosis:{},byDepartment:{}};return e.forEach(e=>{t.byDiagnosis[e.diagnosi]=(t.byDiagnosis[e.diagnosi]||0)+1,t.byDepartment[e.reparto_appartenenza]=(t.byDepartment[e.reparto_appartenenza]||0)+1}),t}catch(e){throw s.error("Errore nel caricamento statistiche:",e),e}}async getTransferHistory(e){try{const t=await this.getPatientById(e);if(!t)throw new Error("Paziente non trovato");const a=[];return t.data_dimissione&&t.tipo_dimissione&&a.push({data:t.data_dimissione,tipo:t.tipo_dimissione,reparto_destinazione:t.reparto_destinazione,clinica_destinazione:t.clinica_destinazione,codice_clinica:t.codice_clinica,codice_dimissione:t.codice_dimissione}),a}catch(t){throw this.handleError(t,{operation:"caricamento cronologia trasferimenti"}),t}}async createPatientWithInfection(e,t){n(e);const a=await A.createPatientWithInfection(e,t);return this.invalidateCache(),a}async handleInfectionEventCreation(e,t){const a=await A.handleInfectionEventCreation(e,t);return this.deleteCache(`patient_${e}`),a}async retryInfectionEventCreation(e,t,a){return A.retryInfectionEventCreation(e,t,a)}async rollbackPatientCreation(e){await b.rollbackPatientCreation(e),this.deleteCache(`patient_${e}`),this.invalidateCache()}async forceCreateInfectionEvent(e,t){const a=await A.forceCreateInfectionEvent(e,t);return this.deleteCache(`patient_${e}`),a}async createPatientWithSurgery(e,t){n(e);const a=await x.createPatientWithSurgery(e,t);return this.invalidateCache(),a}async createPatientWithSurgeryAndInfection(e,t,a){n(e);const i=await x.createPatientWithSurgeryAndInfection(e,t,a);return this.invalidateCache(),i}getTransactionStats(){return b.getTransactionStats()}getTransactionLog(e){return b.getTransactionLog(e)}async handleTemporaryEventsCreation(e,a){return this.withLoading("Salvataggio eventi clinici...",async()=>{try{for(const n of a){const a={...n};delete a.id,delete a.isTemporary,a.paziente_id=e,await t.createEvento(a)}this.showSuccess(`${a.length} eventi clinici salvati con successo`)}catch(n){throw this.handleError(n,{operation:"salvataggio eventi clinici"}),n}})}async createPatientWithTemporaryEvents(e,a){return this.withLoading("Creazione paziente ed eventi clinici...",async()=>{try{const n=await m(e);for(const e of a){const a={...e};delete a.id,delete a.isTemporary,a.paziente_id=n.id,await t.createEvento(a)}return this.showSuccess(`Paziente e ${a.length} eventi clinici creati con successo`),{patient:n,events:a,success:!0}}catch(n){throw this.handleError(n,{operation:"creazione paziente e eventi"}),n}})}_logPatientsSample(e,t){try{const a=(e||[]).filter(e=>e&&"trasferimento_esterno"===e.tipo_dimissione).slice(0,5).map(e=>({id:e.id,codice_clinica:e.codice_clinica}));s.group("[patientService.getPatients] Result summary"),s.log({...t,sampleExternalTransfers:a}),s.groupEnd()}catch(a){}}},M=Object.freeze(Object.defineProperty({__proto__:null,patientService:N},Symbol.toStringTag,{value:"Module"}));export{g as P,S as a,M as b,D as d,N as p};
